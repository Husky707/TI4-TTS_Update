function getHelperClient(helperObjectName)
    local helperObject = Global.call('getHelper', helperObjectName)
    local function getCallWrapper(functionName)
        helperObject = helperObject == nil and Global.call('getHelper', helperObjectName) or helperObject
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _stratHelper = getHelperClient('TI4_STRATEGY_CARD_HELPER')
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')
local Events = getHelperClient('TI4_EVENT_HELPER')

local Coru = {
 _coroutines = {},
 _coRunner = false,
 _coQueue = {},
 _coKillQueue = {},
 step = {
   ["running"] = function() end,
   ["normal"] = function() end,
   ["suspended"] = function(eachCo, callbackData)
     local status, result = coroutine.resume(eachCo)
     if not status then
       print("Coroutine error: ", result)
       if callbackData and callbackData.callback then callbackData.callback(result) end
       return -1
     else
       if callbackData and callbackData.yieldback then callbackData.yieldback(result) end
     end
   end,
   ["dead"] = function(eachCo, callbackData)
     if callbackData and callbackData.callback then callbackData.callback(1) end
     return -1
   end,
   ["catch"] = function(eachCo, callbackData, badState)
     print("Caught a bad coru state: ", badState)
     if callbackData and callbackData.callback then callbackData.callback(-1) end
     return -1
    end
 },
}

local _elimInProgress = false
local _eliminated = {}--indexed by color [keys] = true or "Resolved" if also cleaned up
local Tokens = {
  identifier = "ElimToken", -- searched from obj.getGMNotes() not by obj.getName()
  scale = {x= 2.20, y = 2.20, z = 2.20},
  activeScale = {x = 4, y = 2.2, z = 4},
  assignments = {},--[tokenGUID] = color
  catchNextSpawn = false,
  existingSet = {},--[tokenGUID] = objRef

  --find the original obj in bag
  sourceContainer = "Tools and Helpers",
  rootGUID = "eb196e",--Temp
}

local Elim = {
  warningMsg = {"WARNING: You are about to drastically alter the board state; the ",
                " player's components will be returned in accordance with the player elimination rules. Proceed?"},
  --[[
  target = elimPlayer,
  colors = zoneColors,
  factions = unpackedFactions,
--]]}

--Public getters----------------------------------------------------------------
--!querying these functions during game load from a save will likely yeild no results, wait a frame for this script to update

function isPlayerEliminated(playerColor)
  return _eliminated[playerColor]
end

--returns: {table} of eliminated player colors indexed by [color] keys = true
function getEliminatedPlayers()
  return copyTable(_eliminated)
end

------------------------------
function declarePlayerEliminated(playerColor, tokenObj)
  if _eliminated[playerColor] then return end
  _eliminated[playerColor] = true

  local faction = assert(_factionHelper.fromColor(playerColor))
  Tokens.markElimination(playerColor, faction, tokenObj)

  broadcastToAll('The '..playerColor..' player has been eliminated!', "Red")
  if faction.eliminationQuotes then
    local quotes = type(faction.eliminationQuotes) == "table" and faction.eliminationQuotes or {faction.eliminationQuotes}
    local quote = quotes[math.random(1, #quotes)]
    safePrint("ALL", quote, playerColor)
  end
  Events.invoke({event = "playerEliminated", params = {color = playerColor, factionName = faction.name}})
end

function resolvePlayerElimination(color, tokenObj)
  if _elimInProgress then printToAll("Cannot resolve more than one elimination at a time, please wait.", color, "Red") return end
  if not _eliminated[color] then
    declarePlayerEliminated(color, tokenObj)
  end
  if _eliminated[color] == "Resolved" then return end
  _eliminated[color] = "Resolved"

  local faction = assert(_factionHelper.fromColor(color))
  Tokens.markElimination(color, faction, tokenObj)
  Elim.Resolve(color)
end

-------------------------------------------------------------------------------
function _searchForEliminations()
  _eliminated = {}
  Tokens.assignments = {}
  Tokens.existingSet = {}
  for _,eachObj in ipairs(getAllObjects()) do
    if eachObj.getGMNotes() == Tokens.identifier then
      local guid = eachObj.getGUID()
      Tokens.existingSet[guid] = true
      local target = _zoneHelper.zoneFromPosition(eachObj.getPosition())
      if target then
        _eliminated[target] = "Resolved"
        --flagging as resolved for now. This will prevent automation of cleanup, but should be fine as this only fires on load
        --Could fix by detecting if faction components have been packed, but not implementing now
        Tokens.assignments[guid] = target
        Tokens.assignments[target] = guid
      end
    end
  end
end

Tokens.markElimination = function(color, faction, token)
  if Tokens.assignments[color] then return end
  faction = assert(faction or _factionHelper.fromColor(color))

  local function tryGetPosition()
    local sheet = getObjectFromGUID(faction.factionSheetGuid)
    local _rotation = sheet.getRotation()
    local _pos = sheet.getPosition()
    _pos.y = _pos.y + 0.01
    _rotation.y = _rotation.y + 15
    return _pos, _rotation
  end
  local success, position, rotation = pcall(tryGetPosition)

  local _isInPosition = false
  local function findAToken()
    local copyAssigned = false
    --find an unassigned token
    for eachGUID,eachObj in pairs(Tokens.existingSet or {}) do
      copyAssigned = eachGUID
      if not Tokens.assignments[eachGUID] then
        return eachObj
      end
    end

    local function onSpawn(clone)
      local newGuid = clone.getGUID()
      ignoreDeletedItem(newGuid)
      clone.setLock(true)
      clone.setScale(Tokens.activeScale)
    end

    --else find and copy an assigned token
    if copyAssigned then
      local obj = getObjectFromGUID(copyAssigned)
      local spawnData = {
        data = obj.getData(),
        position = position,
        rotation = rotation,
        scale = Tokens.activeScale,
        callback_function = onSpawn
      }
      Tokens.catchNextSpawn = true
      local clone = spawnObjectData(spawnData)
      _isInPosition = true
      return clone
    end
    --else find from toolbag
    for _,eachObj in ipairs(getAllObjects()) do
      if eachObj.getName() == Tokens.sourceContainer then
        Tokens.catchNextSpawn = true
        _isInPosition = true
        local foundToken = eachObj.takeObject({
          position          = position,
          rotation          = rotation,
          callback_function = onSpawn,
          smooth            = false,
          guid              = Tokens.rootGUID,
          top               = false,
        })
        return foundToken
      end
    end
    return false
  end
  token = token or findAToken
  if not token then return end

  local guid = token.getGUID()
  Tokens.assignments[guid] = color
  Tokens.assignments[color] = guid
  token.clearContextMenu()
  if _eliminated[color] ~= "Resolved" then Tokens.setContextMenu("Assigned", token) end
  token.setLock(true)
  if not _isInPosition and position and rotation then
    token.setScale(Tokens.activeScale)
    token.setPositionSmooth(position, false, true)
    token.setRotationSmooth(rotation)
  end
end

Tokens.setContextMenu = function(contextMode, obj)
  local function setAssigned()
    obj.addContextMenuItem("Resolve Elimination", _contextResolveElimination)
  end

  local function setInZone()
    obj.addContextMenuItem("Declare Elimination", _contextDeclarationElimination)
    obj.addContextMenuItem("Resolve Elimination", _contextDeclareAndResolve)
  end

  local switch = {
    ["Assigned"] = setAssigned,
    ["InZone"] = setInZone,
    ["catch"] = function() error("Caught typo in Tokens.setContextMenu >"..contextMode.."<") end
  }
  local try = switch[contextMode] and contextMode or "catch"
  switch[try]()
end

--Token manipulation events-----------------------------------------------------

--Inform players of how the token works
local _infoCooldown = false
function onObjectDrop(player_color, obj)
  if obj.getGMNotes() ~= Tokens.identifier then return end

  local guid = obj.getGUID()
  if Tokens.assignments[guid] then return end
  if not obj.is_face_down then obj.flip() end

  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if not zone then
    obj.clearContextMenu()
    if not _infoCooldown or Time.time - _infoCooldown > 4 then
      _infoCooldown = Time.time
      printToAll("To declare an elimination, place the elimination token in a player's play area and flip it.\nThen to automate that elimination, right-click the token and select [Resolve].", "White")
    end
  elseif not Tokens.assignments[zone] then
    printToAll("Flip the token to declare the "..zone.." player eliminated.", "Orange")
    Tokens.setContextMenu("InZone", obj)
  end
end

--Manage pick-up of assigned tokens
function onObjectPickUp(player_color, obj)
  local guid = obj.getGUID()
  if not Tokens.assignments[guid] then return end

  local spawnData = {
    data = obj.getData(),
    position = obj.getPosition(),
    rotation = obj.getRotation(),
    scale = Tokens.activeScale,
  }
  Tokens.catchNextSpawn = true
  local clone = spawnObjectData(spawnData)
  local assignedColor = Tokens.assignments[guid]
  local newGuid = clone.getGUID()
  clone.setLock(true)
  ignoreDeletedItem(newGuid)
  Tokens.assignments[newGuid] = assignedColor
  Tokens.assignments[assignedColor] = newGuid
  Tokens.assignments[guid] = nil
  obj.setScale(Tokens.scale)
  obj.clearContextMenu()
  Tokens.setContextMenu("Assigned", clone)
end

--Flip new tokens to show Flip instructions
function onObjectSpawn(obj)
  if obj.getGMNotes() ~= Tokens.identifier then return end
  Tokens.existingSet[obj.getGUID()] = obj
  if Tokens.catchNextSpawn then Tokens.catchNextSpawn = false return end

  if not obj.is_face_down then obj.flip() end
end

--Resolve elimination flip
function onObjectRotate(obj, spin, flip, player_color, old_spin, old_flip)
  if flip == old_flip or flip ~= 0 then return end --only interested in flips and flips to face-up
  if obj.getGMNotes() ~= Tokens.identifier then return end

  local guid = obj.getGUID()
  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if zone and not Tokens.assignments[zone] then
    declarePlayerEliminated(zone, obj)
    --local msg = {"Would you also like the automator to resolve this elimination?\n\n", Elim.warningMsg[1], zone, Elim.warningMsg[2]}
    Player[player_color].showConfirmDialog("Would you also like the automator to resolve this elimination?", function() resolvePlayerElimination(zone, obj) end)
  end
end

--prevent the flipping of engaged elim tokens
function onPlayerAction(player, action, targets)
  if action ~= Player.Action.FlipOver then return end
  for _,each in ipairs(targets or {}) do
    --Dont flip engaged tokens
    if Tokens.assignments[each.getGUID()] then return false end

    if Tokens.identifier == each.getGMNotes() then
      local zone = _zoneHelper.zoneFromPosition(each.getPosition())

      --Dont flip tokens that are not in a play area
      if not zone then return false end
      if _elimInProgress then printToColor("Please wait, an elimination is being resolved.", player.color, "Red") return end

      --Dont flip tokens in an eliminated player's play area
      if Tokens.assignments[zone] then
        printToAll("The "..zone.." player is already eliminated.", "Yellow")
        return false
      end
    end
  end
end

function onObjectDestroy(dying_object)
  Tokens.existingSet[dying_object.getGUID()] = nil
end

--Context Menu Funcs------------------------------------------------------------
function _contextResolveElimination(color, position, obj)
  if _elimInProgress then printToColor("Please wait, an elimination is being resolved.", color, "Red") return end
  assert(obj.getGMNotes() == Tokens.identifier)
  Player[color].clearSelectedObjects()
  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if not zone then
    printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
    return
  end

  local function onConfirmed()
    --re-fetch zone in case another player moved it while menu is open
    local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
    if not zone then
      printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
      return
    end

    obj.clearContextMenu()
    resolvePlayerElimination(zone, obj)
  end
  Player[color].showConfirmDialog(Elim.warningMsg[1]..zone..Elim.warningMsg[2], onConfirmed)
end

function _contextDeclarationElimination(color, position, obj)
  if _elimInProgress then printToColor("Please wait, an elimination is being resolved.", color, "Red") return end
  assert(obj.getGMNotes() == Tokens.identifier)
  Player[color].clearSelectedObjects()
  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if not zone then
    printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
    return
  end

  declarePlayerEliminated(zone, obj)
end

function _contextDeclareAndResolve(color, position, obj)
  if _elimInProgress then printToColor("Please wait, an elimination is being resolved.", color, "Red") return end
  assert(obj.getGMNotes() == Tokens.identifier)
  Player[color].clearSelectedObjects()
  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if not zone then
    printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
    return
  end

  local function onConfirmed()
    --re-fetch zone in case another player moved it while menu is open
    local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
    if not zone then
      printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
      return
    end

    obj.clearContextMenu()
    declarePlayerEliminated(zone, obj)
    resolvePlayerElimination(zone, obj)
  end
  Player[color].showConfirmDialog(Elim.warningMsg[1]..zone..Elim.warningMsg[2], onConfirmed)
end

--Elimination Automation--------------------------------------------------------
Elim.getHands = function()
  local result = {}
  for _, player in ipairs(Player.getPlayers()) do
      local handCount = player.getHandCount()
      for i = 1, handCount do
          for _, object in ipairs(player.getHandObjects(i)) do
              result[object.guid] = player.color
          end
      end
  end
  return result
end

Elim.Resolve = function(elimPlayer)
  if _elimInProgress then return end
  assert(elimPlayer and type(elimPlayer) == "string", (elimPlayer or "nil").. " is not a valid player that can be eliminated.")

  Elim.target = assert(elimPlayer)
  --Elim.targetZone = _zoneHelper.zoneAttributes(elimPlayer) --assert(Elim.targetZone, "The "..elimPlayer.." does not have a zone.")
  Elim.targetZone = assert(copyTable(_zoneHelper.zoneAttributes(elimPlayer)), "The "..elimPlayer.." does not have a zone.")
  Elim.colors = _zoneHelper.zones()
  Elim.factions = _factionHelper.allFactions() or {}
  Elim.commandTokens = {}
  Elim.units = {}
  Elim.proms = {}
  Elim.strats = {}
  Elim.misc = {}
  Elim.containers = {}
  Elim.speakerToken = {}

  _elimInProgress = Elim.target

  --Step 1. Gather the names of *all objects that we will need to find
    --Names are stored as [keys] in their respective tables

  --[[faction.elimInstructions = {
    DO = {guid = self.getGUID(), func = "doFuncName"},--params: {color = eliminatedColor} --no return, just do what u need to do
    ignore = {
      ME = {
        names = {}, --"string" or table of {"strings"}. Objects with these names will not be returned
        guids = {}, --"guid" or table of {"guids"}. Objects with these guids will not be returned
        GET = {guid = self.getGUID(), func = "getFuncName"},--params:{color}, return: {names = {}, guids = {}}
      },
      OTHERS = {}
    },
    include = {
      ME = {},
      OTHERS = {}
    }
  }--]]
  local _factionInstructions = {names = {}, guids = {}}--name and guid tables have [key] = bool where true == include, false == exclude
  --gather faction specific elim instructions
  for fCol,eachFaction in pairs(Elim.factions) do
    local data = eachFaction.elimInstructions or false
    if data then
      if data.ignore then --get ignores
        if Elim.target == fCol then --Get .ME vals
          if data.ignore.ME then
            for _,each in ipairs(data.ignore.ME.names or {}) do
              _factionInstructions.names[each] = false
            end
            for _,each in ipairs(data.ignore.ME.guids or {}) do
              _factionInstructions.guids[each] = false
            end
            local gets = data.ignore.ME.GET and tryCall(data.ignore.ME.GET) or {}
            if type(gets) == "table" then
              for _,each in ipairs(gets) do
                _factionInstructions.names[each] = false
              end
              for _,each in ipairs(gets) do
                _factionInstructions.guids[each] = false
              end
            end
          end
        elseif data.ignore.OTHERS then --get .OTHERS vals
          for _,each in ipairs(data.ignore.OTHERS.names or {}) do
            _factionInstructions.names[each] = false
          end
          for _,each in ipairs(data.ignore.OTHERS.guids or {}) do
            _factionInstructions.guids[each] = false
          end
          local gets = data.ignore.OTHERS.GET and tryCall(data.ignore.OTHERS.GET) or {}
          if type(gets) == "table" then
            for _,each in ipairs(gets) do
              _factionInstructions.names[each] = false
            end
            for _,each in ipairs(gets) do
              _factionInstructions.guids[each] = false
            end
          end
        end
      end
      --get includes (will override matching ignore [keys])
      if data.include then
        if Elim.target == fCol then --Get .ME vals
          if data.include.ME then
            for _,each in ipairs(data.include.ME.names or {}) do
              _factionInstructions.names[each] = true
            end
            for _,each in ipairs(data.include.ME.guids or {}) do
              _factionInstructions.guids[each] = true
            end
            local gets = data.include.ME.GET and tryCall(data.include.ME.GET) or {}
            if type(gets) == "table" then
              for _,each in ipairs(gets) do
                _factionInstructions.names[each] = true
              end
              for _,each in ipairs(gets) do
                _factionInstructions.guids[each] = true
              end
            end
          end
        elseif data.include.OTHERS then --get .OTHERS vals
          for _,each in ipairs(data.include.OTHERS.names or {}) do
            _factionInstructions.names[each] = true
          end
          for _,each in ipairs(data.include.OTHERS.guids or {}) do
            _factionInstructions.guids[each] = true
          end
          local gets = data.include.OTHERS.GET and tryCall(data.include.OTHERS.GET) or {}
          if type(gets) == "table" then
            for _,each in ipairs(gets) do
              _factionInstructions.names[each] = true
            end
            for _,each in ipairs(gets) do
              _factionInstructions.guids[each] = true
            end
          end
        end
      end
    end
  end

  local containers = {}
  local units = {}
  local proms = {}
  --build objectName sets that include a player color: [name] = color
  for _,color in ipairs(Elim.colors) do
    proms["Support for the Throne ("..color..")"] = color
    proms["Trade Agreement ("..color..")"] = color
    proms["Political Secret ("..color..")"] = color
    proms["Ceasefire ("..color..")"] = color
    proms["Alliance ("..color..")"] = color
    units[color .. ' Infantry'] = color
    units[color .. ' Fighter'] = color
    units[color .. ' Destroyer'] = color
    units[color .. ' Carrier'] = color
    units[color .. ' Cruiser'] = color
    units[color .. ' Dreadnought'] = color
    units[color .. ' War Sun'] = color
    units[color .. ' Space Dock'] = color
    units[color .. ' PDS'] = color
    units[color .. ' Mech'] = color
    if Elim.factions[color] then
      units[Elim.factions[color].flagship] = color
      local allyName = Elim.factions[color].shortName or Elim.factions[color].frankenName
      proms[allyName .. " Alliance"] = color
      for _,eachNote in ipairs(Elim.factions[color].promissoryNotes or {}) do
        proms[eachNote] = color
      end
    end
  end

  local commandTokens = {[Elim.target.." Command Token"] = true}
  containers[Elim.target.." Command Tokens Bag"] = "commandTokens"
  if Elim.factions[Elim.target] then
    commandTokens[Elim.factions[Elim.target].tokenName .. " Command Token"] = true
    containers[Elim.factions[Elim.target].tokenName .. " Command Tokens Bag"] = "commandTokens"
  end
  local strats = _stratHelper.getStrategyCards()
  for _,each in pairs(strats or {}) do each = true end --cast to boolean

  --Step 2. Search the table for objects of interest and save the objReference
    --Generally saved in a list as,{name = "", guid = "", obj = objRef, color = colorOwner}

  local function categorizeObj(name, guid, obj)
    if _factionInstructions.names[name] == false or _factionInstructions.guids[guid] == false then return end --explicitly compare to false, these are excluded objs
    --Handle objects by expected names
    if proms[name] then
      table.insert(Elim.proms, {name = name, guid = guid, obj = obj, color = proms[name]})
      return
    elseif containers[name] then
      Elim.containers[containers[name]] = obj
      return
    elseif units[name] then --Elim.units[guid] = {name = name, obj = obj}
      table.insert(Elim.units, {name = name, guid = guid, obj = obj, color = units[name]})
      return
    elseif commandTokens[name] then --Elim.commandTokens[guid] = obj return
      table.insert(Elim.commandTokens, {name = name, guid = guid, obj = obj})
      return
    elseif strats[name] then
      local isInZone = _zoneHelper.zoneFromPosition(obj.getPosition())
      if isInZone == Elim.target then table.insert(Elim.strats, {name = name, guid = guid, obj = obj}) end--Elim.strats[guid] = obj end
      return
    elseif name == "Speaker Token" and _boundingBoxContains(Elim.targetZone.boundingBox, obj.getPosition())then
      Elim.speakerToken = {guid = guid, obj = obj}
      return
    elseif _factionInstructions.names[name] or _factionInstructions.guids[guid] then --uncategorized include
      table.insert(Elim.misc, {name = name, guid = guid, obj = obj})
      return
    end
    --handle unknown object bassed on location
    --hand set
    --zone set
    local oPos = obj.getPosition()
    if not _boundingBoxContains(Elim.targetZone.boundingBox, oPos) then return end
    --handle in target player's zone
  end
  for _,eachObj in ipairs(getAllObjects()) do
    local oName = eachObj.getName()
    local oGuid = eachObj.getGUID()
    categorizeObj(oName, oGuid, eachObj)
  end

  --Step 3. In a coroutine, resolve the return of found objects

  local coru = coroutine.create(function()
    safePrint("ALL","=-_________________________-=", "Yellow")
    safeBroadcast("ALL","|        Resolving Elimination...       |", Elim.target)

    --run faction specific DO actions
    for fCol,eachFaction in pairs(Elim.factions or {}) do
      local instructs = eachFaction.elimInstructions or false
      if instructs and instructs.DO then
        tryCall(instructs.DO, {color = Elim.target})
        coroutine.yield(0)
        coroutine.yield(0)
      end
    end

    Elim.returnCommandTokens()
    coroutine.yield(0)

    Elim.returnUnits()
    coroutine.yield(0)

    --Move Speaker token left
    Elim.shiftSpeaker()
    coroutine.yield(0)

    Elim.returnProms()
    coroutine.yield(0)

    --Others reclaim proms from elim'd player
    Elim.reclaimProms()
    coroutine.yield(0)

    Elim.returnStrats()
    coroutine.yield(0)

    --Return secrets

    --Discard agendas

    --Discard action cards

    --Handle faction specific

    Events.invokeAsync({event = "resolvePlayerEliminated", params = {color = Elim.target}})
    coroutine.yield(0)

    safePrint("ALL", "|        Elimination Resolved         |", "Teal")
    _elimInProgress = false
    return 1
  end)
  Coru.run(coru)
end

--!todo: Find notes on the secrets mat
--return elim player's proms
Elim.returnProms = function()
  safePrint("ALL", "|\n|~Returning Promissory Notes...", "Yellow")
  coroutine.yield(0)
  local _noteCount = 0
  local _printNotes = {["Grey"] = {"| "}} for _,eachColor in ipairs(Elim.colors) do _printNotes[eachColor] = {"| "} end
  local handObjs = Elim.getHands()--[guid] = handColor

  local _supportParnter = false --in case the note was copy pasted: 1 on secret mat, 1 in the play area. Prevents double logging
  local function _handleSFT(noteData)
    local function _broadcastSupport(supportColor)
      if _supportParnter == supportColor then return end --dont double log if the card was coppied to secrets mat
        _supportParnter = supportColor
        table.insert(_printNotes[supportColor], "Support For The Throne")
        safeBroadcast("ALL", "! The "..supportColor.." has lost the "..Elim.target.." player's Support For The Throne !\nMove their score back on the score track", supportColor)
    end

    --is it in a player's play area?
    local _inZone = _boundingBoxContains(Elim.targetZone.boundingBox, noteData.obj.getPosition())
    if _inZone then
      if _inZone == Elim.target then return end
      --else
      _noteCount = _noteCount + 1
      _broadcastSupport(_inZone)
      noteData.obj.deal(1, Elim.target)
      coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
      return
    end

    --In another player's hand?
    local _inHand = handObjs[noteData.guid] or false
    if _inHand then
      if _inHand == Elim.target then return end
      _broadcastSupport(_inHand)
      _noteCount = _noteCount + 1
      noteData.obj.deal(1, Elim.target)
      coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
      return
    end

    --on the secrets mat?

  end

  local function _logNote(noteData)
    local _inHand = handObjs[noteData.guid] or false
    if _inHand then
      if _inHand == Elim.target then return end

      _noteCount = _noteCount + 1
      table.insert(_printNotes[_inHand], noteData.name)
      noteData.obj.deal(1, Elim.target)
      coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
      return
    end

    local objPos = noteData.obj.getPosition()
    if _boundingBoxContains(Elim.targetZone.boundingBox, objPos) then return end--note already returned

    local _inZone = _zoneHelper.zoneFromPosition(objPos)
    if _inZone then
      _noteCount = _noteCount + 1
      table.insert(_printNotes[_inZone], noteData.name)
      noteData.obj.deal(1, Elim.target)
      coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
      return
    end

    --else its in an unknown location
    _noteCount = _noteCount + 1
    table.insert(_printNotes["Grey"], noteData.name)
    noteData.obj.deal(1, Elim.target)
    coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  end

  for _,eachNote in ipairs(Elim.proms) do
    if eachNote.color == Elim.target then
      --make sure the objRef is still live
      eachNote.obj = eachNote.obj ~= nil and eachNote.obj or getObjectFromGUID(eachNote.obj)
      if eachNote.obj ~= nil then
        if eachNote.name == "Support for the Throne ("..Elim.target..")" then
          _handleSFT(eachNote)
        else
          _logNote(eachNote)
        end
      end
    end
  end
  --printResult
  safePrint("ALL", "|   Found and returned ".._noteCount.." notes:", "Yellow")
  for eachCol,found in pairs(_printNotes) do
    if #found > 1 then
      safePrint("ALL", table.concat(found, " - "), eachCol)
    end
  end
end

--!todo --Find on secrets mat
--other players get their proms back
Elim.reclaimProms = function()
  safePrint("ALL", "|\n|~Returning other players\' Promissory Notes...", "Yellow")
  coroutine.yield(0)
  local _noteCount = 0
  local _printNotes = {} for _,eachColor in ipairs(Elim.colors) do _printNotes[eachColor] = {"| "} end
  local handObjs = Elim.getHands()--[guid] = handColor

  local function _logNote(noteData)
    local _inHand = handObjs[noteData.guid] or false
    if _inHand then
      if _inHand ~= Elim.target then return end

      _noteCount = _noteCount + 1
      table.insert(_printNotes[noteData.color], noteData.name)
      noteData.obj.deal(1, noteData.color)
      coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
      return
    end

    if _boundingBoxContains(Elim.targetZone.boundingBox, noteData.obj.getPosition()) then
      _noteCount = _noteCount + 1
      table.insert(_printNotes[noteData.color], noteData.name)
      noteData.obj.deal(1, noteData.color)
      coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
      return
   end
  end

  for _,eachNote in ipairs(Elim.proms) do
    if eachNote.color ~= Elim.target then
      --make sure the objRef is still live
      eachNote.obj = eachNote.obj ~= nil and eachNote.obj or getObjectFromGUID(eachNote.obj)
      if eachNote.obj ~= nil then _logNote(eachNote) end
    end
  end
  safePrint("ALL", "|   Found and returned ".._noteCount.." notes", "Yellow")
  for eachCol,noteNames in pairs(_printNotes) do
    if #noteNames > 1 then --all colors have a prefix at i == i, ignore this
      safePrint("ALL", table.concat(noteNames, " - "), eachCol)
    end
  end
end

Elim.shiftSpeaker = function()
  if not next(Elim.speakerToken) then return end

  safePrint("ALL", "|\n|~Moving the speaker token left...", "Yellow")
  coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  local speakerToken = Elim.speakerToken.obj ~= nil and Elim.speakerToken.obj or getObjectFromGUID(Elim.speakerToken.guid) or false
  local function leftNeighborFrom(color, _abortCase)
    for i,eachCol in ipairs(Elim.colors or {}) do
      if eachCol == color then
        local left = i == #Elim.colors and 1 or i + 1
        if _eliminated[Elim.colors[left]] then
          if _abortCase == color then--we looped through all players, no one is worthy
            --Case wont be reached in a legit game scenario
            return false
          else return leftNeighborFrom(Elim.colors[left], Elim.target)
          end
        else --left player is not eliminated, exalt them
          return Elim.colors[left]
        end
      end
    end
  end
  local newSpeaker = leftNeighborFrom(Elim.target) or false
  local zoneAttrs = newSpeaker and _zoneHelper.zoneAttributes(newSpeaker)
  if not newSpeaker then
    safePrint("ALL","!Failed! Could not identify the next speaker", "Red")
    coroutine.yield(0)
    return
  elseif not zoneAttrs then
    safePrint("ALL","!Failed! Could not find the "..newSpeaker.." player's zone.", "Red")
    coroutine.yield(0)
    return
  elseif not speakerToken then
    safePrint("ALL","!Failed! Bad reference to the Speaker Token.", "Red")
    coroutine.yield(0)
    return
  end

  local pos = {
      x = zoneAttrs.center.x,
      y = zoneAttrs.center.y + 5,
      z = zoneAttrs.center.z + 6 * (zoneAttrs.center.z < 0 and 1 or -1)
  }
  local rot = {
      x = 0,
      y = zoneAttrs.rotation.y,
      z = 0
  }
  local collide = false
  local fast = false
  speakerToken.setPositionSmooth(pos, collide, fast)
  speakerToken.setRotationSmooth(rot, collide, fast)
  coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  safePrint("ALL","|    The "..newSpeaker.." is now the speaker", newSpeaker)
end

Elim.returnCommandTokens = function()
  safePrint("ALL", "|\n|~Returning command tokens...", "Yellow")
  if Elim.containers["commandTokens"] == nil then
    safePrint("ALL", "|!FAILED! Could not find "..Elim.target.."\'s Command Tokens Bag", "RED")
    return
  end
  --else
    local _count = 0
    for _,eachToken in ipairs(Elim.commandTokens) do
      local activeObj = eachToken.obj ~= nil and eachToken.obj or getObjectFromGUID(eachToken.guid)
      if activeObj then Elim.containers["commandTokens"].putObject(activeObj) _count = _count + 1 end
      coroutine.yield(0)
      coroutine.yield(0)
    end
    safePrint("ALL", "|   Success: Returned ".._count.." tokens.","Yellow")
end

Elim.returnUnits = function()
  if not Elim.units or not next(Elim.units) then
    safePrint("ALL", "|!FAILED! Did not locate any units.", "RED")
    return
  end

  --!todo Get fighter stacks
  --return elim player's units and any units they have captured
  safePrint("ALL", "|\n|~Returning units...", "Yellow")
  local targetUnits = {}--{{n,obj,col,guid},}
  local othersUnits = {}--{{n,obj,col,guid},}
  local unitBags = {}--[color][unitType] = objRef
  local _missingBags = {}
  for _,each in ipairs(Elim.colors) do unitBags[each] = {} _missingBags[each] = {} end--init
  --separate unit objs by owner. separate unit bags from unit pieces
  --other players' units are returned if thay are captured in the elim player's zone
  for _,eachUnit in ipairs(Elim.units) do
    eachUnit.obj = eachUnit.obj ~= nil and eachUnit.obj or getObjectFromGUID(eachUnit.guid)
    local liveRef = eachUnit.obj
    if liveRef then
      if liveRef.tag == "Bag" then
        unitBags[eachUnit.color][eachUnit.name] = liveRef
      else
        local targetSet = eachUnit.color == Elim.target and targetUnits or othersUnits
        table.insert(targetSet, eachUnit)
      end
    end
  end
  for _,eachUnit in ipairs(targetUnits) do
    if unitBags[Elim.target][eachUnit.name] then
      unitBags[Elim.target][eachUnit.name].putObject(eachUnit.obj)
      coroutine.yield(0)
      coroutine.yield(0)
    else
      _missingBags[Elim.target][eachUnit.name] = true
    end
  end
  coroutine.yield(0)
  --report failures
  if next(_missingBags[Elim.target] or {}) then
    local pTable = {"! Failed to find unit bags for:"}
    for each,_ in pairs(_missingBags[Elim.target]) do
      table.inset(pTable,each)
    end
    safePrint("ALL", table.concat(pTable, ", "), "Red")
  end
  coroutine.yield(0)
  --find captued units
  _missingBags[Elim.target] = nil
  local _isMissingBags = false
  local captureCount = 0
  local function _maybeReturnUnit(unitData)
    unitData.obj = unitData.obj ~= nil and unitData.obj or getObjectFromGUID(unitData.guid)
    local liveRef = unitData.obj
    if not liveRef then return end

    local oPos = liveRef.getPosition()
    if not _boundingBoxContains(Elim.targetZone.boundingBox, oPos) then return end
    --Also need to make sure units are not on a system tile. Some map layouts (and Creuss Tile) may be inside the bounding box
    local _onTile = _systemHelper.systemFromPosition(oPos)
    if _onTile then return end

    local bag = not _missingBags[unitData.color][unitData.name] and unitBags[unitData.color] and unitBags[unitData.color][unitData.name]
    if not bag then
      _isMissingBags = true
      _missingBags[unitData.color][unitData.name] = true
      return
    end

    --return unit
    captureCount = captureCount + 1
    bag.putObject(liveRef)
    coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  end
  for _,eachUnit in ipairs(othersUnits) do
    _maybeReturnUnit(eachUnit)
  end
  --report captures
  if captureCount > 0 then
    safePrint("ALL","|  Returned "..captureCount.." captured units", "Green")
    --report failures
    if _isMissingBags then
      local pTable = {"! Failed to find unit bags for:"}
      for eachCol,missing in pairs(_missingBags) do
        for eachU,_ in pairs(missing or {}) do
          table.insert(pTable,eachU)
        end
      end
      safePrint("ALL", table.concat(pTable, ", "), "Red")
    end
  end
  coroutine.yield(0)
end

Elim.returnStrats = function()
  if not next(Elim.strats) then return end

  safePrint("ALL", "|\n|~Returning Strategy Card(s)...", "Yellow")
  coroutine.yield(0)
  local _printStrats = {"|  Returned:"}
  for _,eachStrat in ipairs(Elim.strats) do
    table.insert(_printStrats, eachStrat.name)
    _stratHelper.returnStrategyCard({name = eachStrat.name, ignoreStability = true})
    coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  end
  --print result
  local _comma = #_printStrats > 2 and ", " or " "
  safePrint("ALL", table.concat(_printStrats, _comma), "Yellow")
  coroutine.yield(0)
end

--------------------------------------------------------------------------------
--printToAll and broadcastToAll sometimes throw erros if a player is not seated
--players = "ALL" or "color" or table of Cols
--txtCol = "color" or "MATCH" to match the color of recipient
function safePrint(players, msg, txtCol)
  local function getTargets()
    local t = {}
    if players == "ALL" then
      local P = Player.getPlayers()
      for _,each in ipairs(P or {}) do
        if each.seated then table.insert(t, each.color) end
      end
      return t
    end
    --else
    players = type(players) == "table" and players or {players}
    for _,each in ipairs(players) do
      if Player[each].seated then table.insert(t, each) end
    end
    return t
  end
  local targets = getTargets() or {}
  for _,each in ipairs(targets) do
    printToColor(msg, each, txtCol == "MATCH" and each or txtCol)
  end
end

function safeBroadcast(players, msg, txtCol)
  local function getTargets()
    local t = {}
    if players == "ALL" then
      local P = Player.getPlayers()
      for _,each in ipairs(P or {}) do
        if each.seated then table.insert(t, each.color) end
      end
      return t
    end
    players = type(players) == "table" and players or {players}
    for _,each in ipairs(players) do
      if Player[each].seated then table.insert(t, each) end
    end
    return t
  end
  local targets = getTargets() or {}
  for _,each in ipairs(targets) do
    broadcastToColor(msg, each, txtCol == "MATCH" and each or txtCol)
  end
end

-------------------------------------------------------------------------------
function CoroutineRunner()
  while next(Coru._coroutines) do
    local deadList = {}
    --Progress each coroutine
    for eachCo,callbackData in pairs(Coru._coroutines) do
      local status = coroutine.status(eachCo)
      status = Coru.step[status] and status or "catch"
      local isDead = Coru.step[status](eachCo, callbackData) == -1 or status == "dead"
      if isDead then table.insert(deadList, eachCo) end
    end

    --Empty killQueue
    for _,each in ipairs(Coru._coKillQueue) do
      table.insert(deadList, each)
    end
    Coru._coKillQueue = {}

    --Remove dead coroutines
    for _,each in ipairs(deadList) do
      Coru._coroutines[each] = nil
    end

    coroutine.yield(0)
    --Add any waiting coroutines here
    for _,each in ipairs(Coru._coQueue) do
      Coru._coroutines[each.co] = {callback = each.callback, yieldback = each.yieldback}
    end
    Coru._coQueue = {}
  end

  Coru._coRunner = false
  return 1
end

--callbackData = { yieldback = func (called each time co yeilds), callback = func (called when co ends)}
Coru.run = function(newCo, callbackData)
  if Coru._coRunner then
    table.insert(Coru._coQueue, {co = newCo, callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback})
  else
    Coru._coroutines[newCo] = {callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback}
    Coru._coRunner = startLuaCoroutine(self, "CoroutineRunner")
  end
end

Coru.stop = function(co)
  for _,each in ipairs(Coru._coQueue) do
    if each.co == co then
      if each.callback then each.callback(-1) end
      each = nil
      break
    end
  end
  if not Coru._coroutines[co] then return end

  if Coru._coRunner then
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    table.insert(Coru._coKillQueue, co)
  else
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    Coru._coroutines[co] = nil
  end
end

Coru.wait = function(t, callback)
  local newWait = coroutine.create(function()
    local t1 = Time.time
    while Time.time - t1 < t do
      coroutine.yield(0)
    end
    return 1
  end)

  Coru.run(newWait, {callback = callback})
  return newWait
end
-------------------------------------------------------------------------------
function copyTable(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and copyTable(v) or v
        end
        t = copy
    end
    return t
end

local _deletedItemsGuid = false
function ignoreDeletedItem(guid)
    local deletedItems = _deletedItemsGuid and getObjectFromGUID(_deletedItemsGuid)
    if not deletedItems then
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == 'TI4 Deleted Items' then
                _deletedItemsGuid = object.getGUID()
                deletedItems = object
                break
            end
        end
    end
    if deletedItems then
        deletedItems.call('ignoreGuid', guid)
    end
end

function _boundingBoxContains(boxXZ, position)
    assert(type(boxXZ) == 'table' and boxXZ.min and type(position) == 'table' and position.x)
    local gteMin = position.x >= boxXZ.min.x and position.z >= boxXZ.min.z
    local lteMax = position.x <= boxXZ.max.x and position.z <= boxXZ.max.z
    return gteMin and lteMax
end

function tryCall(callData, params)
  local function try()
    --validate
    assert(callData and type(callData) == "table")
    callData.obj = assert(callData.obj ~= nil and callData.obj or getObjectFromGUID(callData.guid))
    assert(callData.obj ~= nil and type(callData.obj) == "userdata", "callback obj could not be found")
    assert(callData.func and type(callData.func) == "string" and callData.obj.getVar(callData.func), 'missing ' .. callData.obj.getName() .. '.' .. callData.func)
    --build params
    local passParams = params == nil and {} or type(params) == "table" and params or {params}
    local dataParams = callData.params == nil and {} or type(callData.params) == "table" and callData.params or {callData.params}
    local mergedParams = {} --params will overide callData.params values that have the same key
    for k,v in pairs(dataParams) do mergedParams[k] = v end
    for k, v in pairs(passParams) do
      if type(k) == "number" then table.insert(mergedParams, v)
      else mergedParams[k] = v
      end
    end
    --call
    return callData.obj.call(callData.func, mergedParams)
  end
  local success, result = pcall(try)
  if not success then print("Failed callback: callData incorrectly formated: ", result) return end
  return result
end
-------------------------------------------------------------------------------
function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_ELIMINATION_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    _searchForEliminations()
end
-------------------------------------------------------------------------------
-- @author Darrell

local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)