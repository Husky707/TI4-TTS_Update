--------------------
--[[Copy/paste common use case:
local Events = getHelperClient("TI4_EVENT_HELPER")

function onLoad(save_state)
  Events.addListener({eventName = "exampleEvent", objGUID = self.getGUID()})
end

--your callback function cannot have the 'local' scope
function onExampleEvent(params)
  print("Got event notification!")
  print("The ", params.color, " player pinged the table!")
  --run your logic
end

--Ping the table to invoke the event
function onPlayerPing(player, position)
  Events.invoke({event = "exampleEvent", params = {position = position, color = player.color} })
end
--]]
------------------------------------------------------------------------------------------------------------------------

--List of built in game events and where they are Called
--You can create your own events using createEvent(params). See below for details
local events =
{
  ["phaseStart"] = { --params = {prev = "", phase = "SETUP|DRAFT|STRATEGY|ACTION|AGENDA"}
    defaultCallback = "onPhaseStart",
  },
  ["phaseEnd"] = { --params = {next = "", phase = "SETUP|DRAFT|STRATEGY|ACTION|AGENDA"}
    defaultCallback = "onPhaseEnd",
  },

  ["planetExplored"] = { --params: {name = "planetName", system = "system'sGUID", color = "exploringPlayer", abilities = {}, result = {[cardName] = cardGUID} }
    defaultCallback = "onPlanetExplored",
  },
  ["frontierExplored"] = {--params: {system = "system'sGUID", color = "exploringPlayer", tokenPos = {vector}, abilities = {}, result = {[cardName] = cardGUID}}
    defaultCallback = "onFrontierExplored"
  },

  ["playerEliminated"] = {--params = {color = "eliminatedPlayerColor"}
    defaultCallback = "onPlayerEliminated"
  },
  ["resolvePlayerEliminated"] = {--params = {color = "eliminatedPlayerColor"} For scripts that want to alter board state after the automator resolved the elim
    defaultCallback = "onResolvePlayerEliminated"
  }
}

local _workingEvents = {}--{[eventName] = co}
local Coru = {
 _coroutines = {},
 _coRunner = false,
 _coQueue = {},
 _coKillQueue = {},
 step = {
   ["running"] = function() end,
   ["normal"] = function() end,
   ["suspended"] = function(eachCo, callbackData)
     local status, result = coroutine.resume(eachCo)
     if not status then
       print("Coroutine error: ", result)
       if callbackData and callbackData.callback then callbackData.callback(result) end
       return -1
     else
       if callbackData and callbackData.yieldback then callbackData.yieldback(result) end
     end
   end,
   ["dead"] = function(eachCo, callbackData)
     if callbackData and callbackData.callback then callbackData.callback(1) end
     return -1
   end,
   ["catch"] = function(eachCo, callbackData, badState)
     print("Caught a bad coru state: ", badState)
     if callbackData and callbackData.callback then callbackData.callback(-1) end
     return -1
    end
 },
}

--Interact with the event system here--------------------------------------------
--Public functions: addListener, removeListener, invoke, invokeAsync, createEvent

--[[params:
    eventName = string name of target event,
    objGUID = guid of the listening object that contains the callback function
    callback = *optional- string name of callback function. Defaults to "on" .. EventName ex: turnStart -> onTurnStart (notice capitalization!!)--]]
    --p: ({eventName, objGUID, callback})
function addListener(params)
  assert(params.eventName and type(params.eventName) == 'string')
  assert(params.objGUID and type(params.objGUID) == 'string')
  assert(params.callback == nil or type(params.callback) == 'string', "Callback should be the string name of your callback function. Ommitting defaults to onEventName.")

  local event = events[params.eventName]
  local guid = params.objGUID
  local obj = getObjectFromGUID(guid)
  assert(event, params.eventName .. " is not a registered event.")

  local currentListeners = event.listeners or {}
  --determine callback function
  local cb = params.callback or event.defaultCallback
  currentListeners[guid] = { listenObject = obj, callback = cb, guid = params.objGUID}
  event.listeners = currentListeners

  --print(obj.getName() .. " is listening to " .. params.eventName)
  return true
end

--Params: {eventName, objGUID}
--removal is done automatically if a listening object is nil when an event callback is sent to it
function removeListener(params)
  assert(params.eventName and type(params.eventName) == 'string')
  assert(params.objGUID)

  assert(events[params.eventName], "Tried to remove listener from an unregistered event.")
  events[params.eventName].listeners[params.objGUID] = nil
end

--params: {event = "", params = {Any data you want to pass with the event}, async = bool (separate listeners across frames in a coru)}
function invoke(params)
  if params.async then return invokeAsync(params) end
  assert(params.event and type(params.event) == 'string')
  assert(events[params.event], "Failed to invoke: Event >"..params.event.."<  is not registered.")

  if _workingEvents[params.event] then
    return false, "Event is being invoked."
  end

  local listeners = events[params.event].listeners or {}
  if not next(listeners) then return end

  --call events. Mark nil objects for removal
  --print("Invoking " .. params.event .. ".")
  local nilObjs = {}
  for id,each in pairs(listeners) do
    each.listenObject = each.listenObject ~= nil and each.listenObject or getObjectFromGUID(each.guid)
    if each.listenObject ~= nil then
      tryCall(each, params.params)
    else
      table.insert(nilObjs, id)
    end
  end

  --remove nil refs
  for _,each in pairs(nilObjs) do
    listeners[each] = nil
  end
end

--same as invoke, but spreads listener calls across frames in a coru
--returns false, "already invoking" if the invoke fails
function invokeAsync(params)
  assert(params.event and type(params.event) == 'string')
  assert(events[params.event], "Failed to invoke: Event >"..params.event.."<  is not registered.")
  if _workingEvents[params.event] then
    return false, "already invoking"
  end
  _workingEvents[params.event] = true

  local listeners = events[params.event].listeners or {}
  if not next(listeners) then return true end

  local _co = coroutine.create(function()
    --print("Invoking " .. params.event .. ".")
    --call events. Mark nil objects for removal
    local nilObjs = {}
    for id,each in pairs(listeners) do
      each.listenObject = each.listenObject ~= nil and each.listenObject or getObjectFromGUID(each.guid)
      if each.listenObject ~= nil then
        tryCall(each, params.params)
        coroutine.yield(0)
      else
        table.insert(nilObjs, id)
      end
    end

    --remove nil refs
    for _,each in pairs(nilObjs) do
      listeners[each] = nil
    end

    _workingEvents[params.event] = false
  end)

  Coru.run(_co)
end

--params: {eventName, callbackName(*optional-- defaults to "onEventName")}
function createEvent(params)
    local function _firstToUpper(str)
      return (str:gsub("^%l", string.upper))
    end
  assert(params.eventName and type(params.eventName) == 'string')
  assert(params.callbackName == nil or type(params.callbackName) == 'string')
  local callback = params.callbackName or "on".._firstToUpper(params.eventName)

  if events[params.eventName] then
    print(params.eventName .. " already exists. Choose a unique name.")
    return false
  end

  --print("Event created: " .. params.eventName  .. " calls>" .. callback .."<")
  events[params.eventName] = { listeners = {}, defaultCallback = callback}
  return true
end

-------------------------------------------------------------------------------
function tryCall(callData, params)
  local function try()
    assert(callData and type(callData) == "table")
    local callObj = callData.listenObject ~= nil and callData.listenObject or getObjectFromGUID(callData.guid)
    assert(callObj ~= nil)
    assert(callData.callback and type(callData.callback) == "string" and callObj.getVar(callData.callback), 'missing ' .. callObj.getName() .. '.' .. callData.callback)

    return callObj.call(callData.callback, params)
  end
  local success, result = pcall(try)
  if not success then
    --print("Failed callback: callData incorrectly formated. ", result)
    return
  end
  return result
end

-------------------------------------------------------------------------------
function CoroutineRunner()
  while next(Coru._coroutines) do
    local deadList = {}
    --Progress each coroutine
    for eachCo,callbackData in pairs(Coru._coroutines) do
      local status = coroutine.status(eachCo)
      status = Coru.step[status] and status or "catch"
      local isDead = Coru.step[status](eachCo, callbackData) == -1 or status == "dead"
      if isDead then table.insert(deadList, eachCo) end
    end

    --Empty killQueue
    for _,each in ipairs(Coru._coKillQueue) do
      table.insert(deadList, each)
    end
    Coru._coKillQueue = {}

    --Remove dead coroutines
    for _,each in ipairs(deadList) do
      Coru._coroutines[each] = nil
    end

    coroutine.yield(0)
    --Add any waiting coroutines here
    for _,each in ipairs(Coru._coQueue) do
      Coru._coroutines[each.co] = {callback = each.callback, yieldback = each.yieldback}
    end
    Coru._coQueue = {}
  end

  Coru._coRunner = false
  return 1
end

--callbackData = { yieldback = func (called each time co yeilds), callback = func (called when co ends)}
Coru.run = function(newCo, callbackData)
  if Coru._coRunner then
    table.insert(Coru._coQueue, {co = newCo, callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback})
  else
    Coru._coroutines[newCo] = {callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback}
    Coru._coRunner = startLuaCoroutine(self, "CoroutineRunner")
  end
end

Coru.stop = function(co)
  for _,each in ipairs(Coru._coQueue) do
    if each.co == co then
      if each.callback then each.callback(-1) end
      each = nil
      break
    end
  end
  if not Coru._coroutines[co] then return end

  if Coru._coRunner then
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    table.insert(Coru._coKillQueue, co)
  else
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    Coru._coroutines[co] = nil
  end
end

Coru.wait = function(t, callback)
  local newWait = coroutine.create(function()
    local t1 = Time.time
    while Time.time - t1 < t do
      coroutine.yield(0)
    end
    return 1
  end)

  Coru.run(newWait, {callback = callback})
  return newWait
end
-------------------------------------------------------------------------------
function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_EVENT_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)
end
-------------------------------------------------------------------------------
-- @author Darrell

local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)