
function getHelperClient(helperObjectName)
    local helperObject = Global.call('getHelper', helperObjectName)
    local function getCallWrapper(functionName)
        helperObject = helperObject == nil and Global.call('getHelper', helperObjectName) or helperObject
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

local _activeEffects = {}
local _toggleCards = {} --indexed by object names{[name] = true}
local _toggleUpdate = false

-- abilities are what enable players to use gameEffects. Abilities are used within a CONTEXT
local CONTEXT = {
  "any", "unitAbilities", "commodities", "adjacency", "draw_actionCard", "draw_..."
}
local _gameEffects = {
  ["ion storm"] = {
    id = "ion strom",
    sources = {
      {id = "Ion Storm Token", context = "adjacency", targetType = "ALL", refs = {OBJECTS = {"Ion Storm Token"}}},
    }
  },
  ["link all wormholes"] = {
    id = "link all wormholes",
    sources = {
      { id = "Emissary Taivra",
        targetType = "ALL",
        context = "adjacency",
        refs = { OBJECTS = {{name = "Emissary Taivra", requireFaceup = true, requireActive = "true"}}}
      }
    },
  },
}

--[[params: {
      context = "contextName", --required. What type of abilities are you looking for
      color = "color" *optional, gets abilities for this color or for all colors if nil
      forceUpdate = bool*optional --active abilities are only updated once per frame if called. Force update to refresh it again this frame
    }-]]
--[[return: = { --single {table} or, if getting all colors, a table with {[color] = {return}} keys for each [color]
  ["_effectID"] = {
    count = #,--how many times should this effect be applied
    sources = { --groups the individual sources found by source id
      [sourceID] = {
        count,
        refs = {["ObjOrAbilityName"] = {count, objs}
      }}
    },
  }
}--]]
function getActiveAbilities(params)
  assert(params and type(params) == "table")
  assert(params.context and CONTEXT[params.context])
  _gatherSourceObjs()

  if not params.forceUpdate and _activeEffects[params.context] then
    return not params.color and _activeEffects[params.context] or _activeEffects[params.context][params.color] or {}
  end
  Wait.frames(function() _activeEffects[params.context] = nil end, 1)
  _getActiveSources(params.context)
  _getActiveEffects(params.context)
  return not params.color and _activeEffects[params.context] or _activeEffects[params.context][params.color] or {}
end

--[[params: "string" or {name = ""}, --card objects with this name will become toggleable--]]
--Alliance cards should not be registerd, they are detected automatically if a commander is registered
function registerToggleCard(params)
  local name = type(params) == "string" and params or params.name
  _toggleCards[params.name] = true

  if _toggleUpdate then return end
  _toggleUpdate = true
  Wait.frames(function() _toggleUpdate = false _applyToggleActiveCards() end, 3)
end

--params = objRef or {obj = objRef}
function isToggleActiveCardActive(params)
  assert(params ~= nil)
  local obj = type(params) == "userdata" and params or params.obj
  return _isToggleActiveCardActive(obj)
end

--[[ --Ability format:
local gameEffect = {
  id = "", --give this ability a unique id
  description = "",
  stackable = true, --can this effect be applied multiple times to the same player
  --Sources determine when this effect is in play and who it effects
  --An effects may have multiple different sources; think of a source as an ability that is in play that grants the effect
  sources = {
    {
      context = "", -- "" or {table strings}; See CONTEXT for available names
      isUniversalRule = false, --Is this rule allways in play (within context)?
      stackable = true, --can this source stack with itself to apply multiple times?
      --if not universal, refs are how we determine if this source is active/in play
      refs = {
        OBJECTS = {"stringName", objectTable}, --Look for objects that may enable this rule
         --mixed table of stings/objectTables. objectTables allow additional settings

         {--objectTable =
          --*How to find this object(include only 1)
          *name = "",
          *guid = "",

          requireFaceup = false,
          requireActive = false, --Does the object have a toggle Active button; this will create a toggel button on the object if it is a card
          isDiscardable = false, --set to true to prevent this object from being found in its discard pile
        },
        FACTION_ABILITIES = {"abilityName_1",...},
        GET = {obj = self, func = "getSource"},
        --params: {context, id = "id of gameEffect", color = "color of player in question"}
        --return: bool, true if this source is active/in play
      }

      --If this source is active/in play, who will it effect?
      targetType = "OWNER"|"OTHERS"|"ALL"|"GET", --"OTHERS" == NOT OWNER
      --If target is "GET", you must include getTarget
      --getTarget = {obj = self, func = "myTargetFuncName"},
        --params: {context, id = "id of this gameEffect", objs = _foundObjects, abilities = _activeAbilityOwners}
        --return: {[color] = #} table of colors to target and how many times to stack the effect

      --Are there any players that cannot be targeted by this source?
      targetIgnore = {
        PROMMISSORY = "ComponentName",-- Finds the faction with this note and ignores it
        FACTION = {""},
        FACTION_ABILITY = {""},
        GET = {obj = self, func = ""}
          --params: {color, context, id}
          --return: boolean; true to ignore color target
      },

      --*internal values
      --isActive = bool,
      --_foundObjects = {objRef}--objects from refs that have been found (and are faceup/active if required)
      --_activeAbilityOwners = {[color] = {ListOfAbilityNames}}, --color indexed list of colors whose factions have an ability found in refs.FACTION_ABILITIES
  }},
  --*internal vars
  _contexts = {},--indexed by name, build from all contexts of sources
    --perContext: _activeTargets = false, --or {[color] = #} table of color targets, and the number of times targeted
    --_activeSourceNames = {[color]}

  applyEffect = function(context, color, activeEffects)
  end
}
--]]

local _sourceObjsThisFrame = false
function _gatherSourceObjs()
  if _sourceObjsThisFrame then return end
  Wait.frames(function() _sourceObjsThisFrame = false end, 1)
  _sourceObjsThisFrame = true

  local objsToFind = {guids = {}, names = {}}
  for eachEffect,data in pairs(_gameEffects) do
    for _,eachSource in ipairs(data.sources or {}) do
      eachSource._foundObjects = {}
      if eachSource.refs then
        --gather objects to batch search later
        for _,OBJ in ipairs(eachSource.refs.OBJECTS or {}) do
          local findByName = type(OBJ) == "string" and OBJ or OBJ.name or false
          local intoTable = findByName and objsToFind.names or objsToFind.guids
          local key = findByName or OBJ.guid
          intoTable[key] = intoTable[key] or {}
          local isTbl = type(OBJ) == "table"
          local val = {
            source = eachSource,
            requireFaceup = isTbl and OBJ.requireFaceup,
            requireActive = isTbl and OBJ.requireActive,
            isDiscardable = isTbl and OBJ.isDiscardable,
          }
          table.insert(intoTable[key], val)
        end
      end
    end
  end

  for _,eachObj in ipairs(getAllObjects()) do
    local objName = eachObj.getName()
    local objGuid = eachObj.getGUID()

    local mergedResults = copyTable(objsToFind.guids[objGuid] or {})
    local foundObjs = objsToFind.names[objName] or {}
    for _,each in ipairs(foundObjs) do
      table.insert(mergedResults, each)
    end

    local _isDiscared = nil
    local function _getIsDiscarded(guid)
      if _isDiscared ~= nil then return _isDiscared end
      _isDiscared = _deckHelper.isDiscard(guid)
      return _isDiscared
    end

    local _isToggledActive = nil
    local function _getIsToggledActive(obj)
      if _isToggledActive ~= nil then return _isToggledActive end
      _isToggledActive = isToggleActiveCardActive(obj)
      return _isToggledActive
    end

    for _,eachRef in ipairs(mergedResults) do
      if (not eachRef.requireFaceup or not eachObj.is_face_down)
        and (not eachRef.requireActive or _getIsToggledActive(eachObj))
        and (not eachRef.isDiscardable or not _getIsDiscarded(objGUID))
      then
        eachRef.source._foundObjects = eachRef.source._foundObjects or {}
        table.insert(eachRef.source._foundObjects, eachObj)
      else
      end
    end
  end
end

function _getActiveSources(context)
  assert(context and CONTEXT[context])
  local abilitiesToFind = {}
  local function unpackedFactionsWithAbility(abilityName)
    --Returns a table of faction names that have this ability and that are also unpacked
    local result = {}
    local _factions = _factionHelper.allFactions()
    --This func may be run while _colorToFaction is being built, so we'll have to run through _factionData to get factions with a color field
    for factionName,data in pairs(_factions or {}) do
      if data.color then --Faction is unpacked
        for _,eachAbility in ipairs(data.abilities) do
          if eachAbility == abilityName then table.insert(result, factionName) break end
        end
      end
    end

    return next(result) and result or false
  end

  for eachEffect,data in pairs(_gameEffects) do
    if data._hasContext[context] then
      data._activeTargets[context] = {}
      for _,eachSource in ipairs(data.sources or {}) do
        if eachSource._hasContext[context] then
          --is it a universal rule or have we already found some of its source objects
          eachSource.isActive = eachSource.isUniversalRule or next(eachSource._foundObjects) and true or false
          eachSource._activeAbilityOwners = {}
          if eachSource.refs then
            if eachSource.refs.GET then
              eachSource.isActive = eachSource.isActive or tryCall(eachSource.refs.GET) or false
            end
            --gather faction abilities to find in bulk
            for _,each in ipairs(eachSource.refs.FACTION_ABILITIES or {}) do
              abilitiesToFind[each] = abilitiesToFind[each] or {}
              table.insert(abilitiesToFind[each], eachSource)
            end
          end
        end
      end
    end
  end

  --get the color of factions with a target ability
  for abiliytName,data in pairs(abilitiesToFind) do
    for _,eachFaction in ipairs(unpackedFactionsWithAbility(abilityName) or {}) do
      for _,eachSource in ipairs(data) do
        eachSource.source.isActive = true
        eachSource._activeAbilityOwners[eachFaction.color] = eachSource._activeAbilityOwners[eachFaction.color] or {} --init color table
        eachSource._activeAbilityOwners[eachFaction.color][abilityName] = true --add abilityName as key
      end
    end
  end
end

function _getActiveEffects(context)
  assert(context and CONTEXT[context])
  _activeEffects[context] = {}
  for _,eachEffect in pairs(_gameEffects) do
    if eachEffect._hasContext[context] then
      _getEffectTargets(context, eachEffect)
    end
  end
end

function _getEffectTargets(context, effect)
  if not effect._hasContext[context] then return end
  local _result = {}
  --params: {color = zoneColor, name = objOrAbilityName, source = source, obj = eachObj}
  local function documentSource(params)
    local id = params.source.id or "No source ID"
    _result[params.color] = _result[params.color] or {count = 0, sources = {}}

    _result[params.color].sources[params.name] = _result[params.color].sources[params.name] or {count = 0, refs = {}}
    local sourceTable = _result[params.color].sources[params.name]
    sourceTable.count = not params.source.stackable and 1 or sourceTable.count + (params.count or 1)
    --add found obj/ability to refs table
    sourceTable.refs[params.name] = sourceTable.refs[params.name] or {objs = {}, count = 0}
    local refTable = sourceTable.refs[params.name]
    if params.obj then table.insert(refTable.objs, params.obj) end
    refTable.count = refTable.count + (refTable.count or 1)
  end

  local function getTargetsFromGet(source)
    local result = tryCall(source.getTarget, {context = context, id = effect.id, objs = source._foundObjects, abilities = source._activeAbilityOwners}) or false
    if not result then return end

    assert(type(result) == "table")
    assert(result.targets and type(result.targets) == "table")

    result.name = result.name or "Unnamed source"
    for eachCol,count in pairs(result.targets or {}) do
      count = type(count) == "boolean" and 1 or count
      documentSource({source = source, name = result.name, color = eachCol, count = count})
    end
    return result
  end

  local function getTargetsFromOwner(source)
    --if an ability obj is in a player zone, add that player to targets
    for _,eachObj in ipairs(source._foundObjects or {}) do
      local zoneColor = _zoneHelper.zoneFromPosition(eachObj.getPosition())
      if zoneColor then
        documentSource({color = zoneColor, name = eachObj.getName, source = source, obj = eachObj})
      end
    end
    --if a faction has the specified ability, add that player to targets
    for eachCol,abilities in pairs(source._activeAbilityOwners or {}) do
      for eachAbility,_ in pairs(abilities) do
        documentSource({color = eachCol, name = eachAbility, source = source})
      end
    end
  end

  local allCols = _zoneHelper.zones()
  local function getTargetsFromOther(source)
    local function addOthers(excludeCol, result)
      for _,each in ipairs(allCols) do
        if each ~= excludeCol then
          result.color = each
          documentSource(result)
        end
      end
    end

    --if an ability obj is in a player zone, add other players to targets
    for _,eachObj in ipairs(source._foundObjects or {}) do
      local zoneColor = _zoneHelper.zoneFromPosition(eachObj.getPosition())
      if zoneColor then addOthers(zoneColor, {name = eachObj.getName(), source = source, obj = eachObj}) end
    end
    --if a faction has the specified ability, add other players to targets
    for eachCol,abilities in pairs(source._activeAbilityOwners or {}) do
      for eachAbility,_ in pairs(abilities) do
        addOthers(eachCol,{name = eachAbility, source = source})
      end
    end
  end

  local function getTargetsFromAll(source)
    local stackable = source.stackable and effect.stackable
    for _,each in ipairs(allCols) do
      for _,eachObj in ipairs(source._foundObjects or {}) do
        documentSource({color = each, obj = eachObj, name = eachObj.getName(), source = source})
      end
      local _abilities = source._activeAbilityOwners and source._activeAbilityOwners[each] or {}
      for eachAbility,_ in pairs(_abilities) do
        documentSource({color = each, name = eachAbility, source = source})
      end
    end
  end

  local switch = {
    ["GET"] = getTargetsFromGet,
    ["OWNER"] = getTargetsFromOwner,
    ["OTHER"] = getTargetsFromOther,
    ["ALL"] = getTargetsFromAll,
    ["catch"] = function(rule, source)
      local errMsg = { val = source.targetType or "nil", rule = rule.id or "nil"}
      error("Caught bad value >"..errMsg.val.."< for targetType in a source for gameEffect >"..errMsg.rule.."<")
      return
    end
  }

  _activeEffects[context] = _activeEffects[context] or {}
  for _,eachSource in ipairs(effect.sources or {}) do
    if eachSource.isActive and eachSource._hasContext[context] then
      local try = switch[eachSource.targetType] and eachSource.targetType or "catch"
      switch[try](eachSource)
    end
  end

  --get final counts in result table and insert result into context
  for eachColor, effectResult in pairs(_result) do
    effectResult.count = not effect.stackable and 1 or 0
    if effect.stackable then
      for _,eachSource in pairs(effectResult.sources) do
        effectResult.count = effectResult.count + eachSource.count
      end
    end

    _activeEffects[context][eachColor] = _activeEffects[context][eachColor] or {}
    _activeEffects[context][eachColor][effect.id] = effectResult
  end
end

function tryCall(callData, params)
  local function try()
    assert(callData and type(callData) == "table")
    assert(callData.obj ~= nil and type(callData.obj) == "userdata")
    assert(callData.func and type(callData.func) == "string" and callData.obj.getVar(callData.func), 'missing ' .. callData.obj.getName() .. '.' .. callData.func)
    local passParams = params == nil and {} or type(params) == "table" and params or {params}
    local dataParams = callData.params == nil and {} or type(callData.params) == "table" and callData.params or {callData.params}
    local mergedParams = {} --params will overide callData.params values that have the same key
    for k,v in pairs(dataParams) do mergedParams[k] = v end
    for k, v in pairs(passParams) do
      if type(k) == "number" then table.insert(mergedParams, v)
      else mergedParams[k] = v
      end
    end
    return callData.obj.call(callData.func, mergedParams)
  end
  local success, result = pcall(try)
  if not success then print("Failed callback: callData incorrectly formated. ", result) return end
  return result
end

-------------------------------------------------------------------------------
local TOGGLE_ACTIVE_STATE = {
    idle = {
        label = 'Idle',
        buttonColor = { r = 1, g = 1, b = 1 },
        textColor = { r = 0, g = 0, b = 0 },
    },
    active = {
        label = 'Active',
        buttonColor = { r = 1, g = 0, b = 0 },
        textColor = { r = 0, g = 0, b = 0 },
    }
}

function _isToggleActiveCard(object)
  if not object.tag == "Card" then return false end
  local name = object.getName()
  if _toggleCards[name] then return true end

  local shortName = string.match(name, '^(.*) Alliance$')
  if shortName then
    local faction = shortName and _factionHelper.fromTokenName(shortName)
    local commander = faction and faction.commander
    return _toggleCards[commander] or false
  end

  return false
end

function _isToggleActiveCardActive(object)
    local buttons = object.getButtons()
    local button = buttons and #buttons > 0 and buttons[1]
    return button and button.label == TOGGLE_ACTIVE_STATE.active.label
end

function _onToggleActiveCard(buttonContainer, clickerColor, altClick)
    local buttons = buttonContainer.getButtons()
    local button = buttons and #buttons > 0 and buttons[1]
    if button then
        if _isToggleActiveCardActive(buttonContainer) then
            button.label = TOGGLE_ACTIVE_STATE.idle.label
            button.color = TOGGLE_ACTIVE_STATE.idle.buttonColor
            button.font_color = TOGGLE_ACTIVE_STATE.idle.textColor
        else
            button.label = TOGGLE_ACTIVE_STATE.active.label
            button.color = TOGGLE_ACTIVE_STATE.active.buttonColor
            button.font_color = TOGGLE_ACTIVE_STATE.active.textColor
        end
        buttonContainer.editButton(button)
    end
end

function _applyToggleActiveCard(object)
    local scale = object.getScale()
    local iscale = {
        x = scale.x,  -- what is going on here??
        y = 1,
        z = 1/scale.z,
    }
    local bounds = object.getBoundsNormalized()
    local pos = {
        x = 0,
        y = 1,
        z = ((bounds.size.z / scale.z) / 2) + 0.15
    }
    object.clearButtons()
    object.createButton({
        click_function = '_onToggleActiveCard',
        function_owner = self,
        label          = TOGGLE_ACTIVE_STATE.idle.label,
        position       = pos,
        rotation       = { x = 0, y = 0, z = 0 },
        scale          = iscale,
        width          = 650,
        height         = 250,
        font_size      = 200,
        color          = TOGGLE_ACTIVE_STATE.idle.buttonColor,
        font_color     = TOGGLE_ACTIVE_STATE.idle.textColor,
        tooltip        = 'Toggle active'
    })
end

function _applyToggleActiveCards()
    for _, object in ipairs(getAllObjects()) do
        if _isToggleActiveCard(object) then
            _applyToggleActiveCard(object)
        end
    end
end

function onObjectSpawn(object)
    if _isToggleActiveCard(object) then
        _applyToggleActiveCard(object)
    end
end

--------------------------------------------------------------------------------
function onPlayerPing(player, position)
  local result = getActiveAbilities({context = "adjacency", color = "Blue"})
  for id,each in pairs(_gameEffects) do
    print(id, " isActive: ", each.sources[1].isActive)
  end
  printTable(result)
end
--------------------------------------------------------------------------------
function initEffects()
  for _,each in ipairs(CONTEXT) do
    CONTEXT[each] = true
  end
  for _,each in pairs(_gameEffects) do
    each._hasContext = each._hasContext or {}
    each._activeTargets = {}
    each._activeSourceNames = {}

    for _,eachSource in ipairs(each.sources or {}) do
      eachSource.isActive = false
      eachSource._foundObjects = {}
      eachSource._activeAbilityOwners = {}
      eachSource._hasContext = {}
      for _,eachContext in ipairs(type(eachSource.context) == "table" and eachSource.context or {eachSource.context} or {}) do
        each._hasContext[eachContext] = true
        eachSource._hasContext[eachContext] = true
      end
    end
  end
end

function onLoad(saveState)
  initEffects()

  -- Make toggle cards toggle-able.
  Wait.frames(_applyToggleActiveCards, 8)

  --Format helper object
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_ABILITY_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)
end
--------------------------------------------------------------------------------

function copyTable(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and copyTable(v) or v
        end
        t = copy
    end
    return t
end

function printTable(table)
  if not table or type(table) ~= 'table' then print("Error: printTable() requires a table param.") return end

  local function typeToPrintable(input)
   if type(input) == 'boolean' then return input and "true" or "false" end
   if type(input) == 'userdata' then return "userData" end
   return input
  end

  for k,v in pairs(table) do
    local kString = typeToPrintable(k)
    if type(v) == 'table' then
      print("--" .. kString .. " table:")
      printTable(v)
    else
      print(kString .. ": " .. typeToPrintable(v))
    end
  end
end

local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)