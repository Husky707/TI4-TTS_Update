--- Faction attributes.
-- @author Darrell
-- #include <~/TI4-TTS/TI4/Helpers/TI4_FactionHelper>
--
-- Get faction tables with:
-- - factionName string, matches a key in the faction attributes table.
-- - tokenName string, "TOKEN_NAME Command Token" or "TOKEN_NAME Owner Token".
-- - color string (from command sheet in case no seated player).
-- - actionCards number.
-- - commandTokens number.

-- Users should copy this getHelperClient function, and use via:
--
-- local factionHelper = getHelperClient('TI4_FACTION_HELPER')
-- local faction = factionHelper.fromColor('Red')
-- print(faction.name)
--
-- Where one can call any main function in this file via the helper.
function getHelperClient(helperObjectName)
    local helperObject = Global.call('getHelper', helperObjectName)
    local function getCallWrapper(functionName)
        helperObject = helperObject == nil and Global.call('getHelper', helperObjectName) or helperObject
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _deckHelper = getHelperClient('TI4_DECK_HELPER')
local _exploreHelper = getHelperClient('TI4_EXPLORE_HELPER')
local _strategyCardHelper = getHelperClient('TI4_STRATEGY_CARD_HELPER')
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _unitHelper = getHelperClient('TI4_UNIT_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

function _exportFaction(f)
    local function scrub(s)
        if type(s) ~= 'string' then
            return
        end
        s = string.gsub(s, '[^%w %(%)]', '')
        s = string.lower(s):gsub(' ', '_')
        while(string.match(s, '^_')) do
            s = s:sub(2)
        end
        while(string.match(s, '_$')) do
            s = s:sub(1, -2)
        end
        s = s:gsub('__', '_')
        return s
    end
    local function scrubList(tbl)
        local result = {}
        for _, v in ipairs(tbl) do
            table.insert(result, scrub(v))
        end
        return result
    end

    local techs = {}
    for _, v in ipairs(f.factionTech or {}) do
        if not _unitHelper.getUnitOverrides()[v] then
            table.insert(techs, v)
        end
    end

    local units = { f.flagship }
    for _, v in ipairs(f.units or {}) do
        v = v:gsub(' I$', '')
        v = v:gsub(' II$', ' 2')
        table.insert(units, v)
    end

    local startingUnits = {}
    for k, v in pairs(f.startingUnits) do
        startingUnits[scrub(k)] = v
    end

    return {
        faction = scrub(f.shortName or f.frankenName),
        source = scrub(f.source),
        abilities = scrubList(f.abilities),
        commodities = f.commodities,
        home = f.home,
        leaders = {
            agents = { 'UNKNOWN_XXX'},
            commanders = { scrub(f.commander) },
            heroes = { scrub(f.hero) },
        },
        promissoryNotes = scrubList(f.promissoryNotes),
        techs = scrubList(techs),
        units = scrubList(units),
        startingTech = scrubList(f.startingTech),
        startingUnits = startingUnits,
    }
end

local _colorToFaction = {}
local _lowerTokenNameToFaction = {}
local _factionCardNameToAbilityFunc = false
local _factionData = {}
--see injection section for full documentation
function newFaction(fullName, factionData)
  assert(fullName and type(fullName) == "string")
  assert(factionData and type(factionData) == "table")

  local name = fullName
  local proxy = {tokenName = factionData.tokenName, name = fullName}
  local mt = {
    __index = function(table, key)
      --Every time .commodities is read, it will update and return the faction's commodity value
      --This allows commodity values to be varialbe and to be mutated by abilities
      if key == "commodities" then
        return getCommodities(table.name)
      end

      local value = _factionData[table.name][key]
      local getVal = type(value) == "table" and value.GET
      if getVal then return tryCall(value) or value.default end
      --All other faction data querries return as usual
      return  value
    end,

    __newindex = _factionData[table.name],

    __eq = function(a, b)--Called if a and b are both tables
      return a.tokenName and b.tokenName and a.tokenName == b.tokenName
    end
  }

  factionData.name = fullName
  _factionData[name] = factionData
  _factionData[name].printedCommodities = factionData.printedCommodities or factionData.commodities
  setmetatable(proxy, mt)
  return proxy
end

--Each faction in this field is now a proxy table to enable the use of metatables for getters/setters
local _factionAttributes = {
  ['The Arborec'] = newFaction('The Arborec', {
      source = 'base',
      tokenName = 'Arborec',
      frankenName = 'Arborec',
      home = 5,
      startingUnits = { Infantry = 4, Fighter = 2, Cruiser = 1, Carrier = 1, Space_Dock = 1, PDS = 1 },
      startingTech = { 'Magen Defense Grid' },
      factionTech = { "Letani Warrior II", "Bioplasmosis" },
      flagship = 'Duha Menaimon',
      flagshipDescription = 'After you activate this system, you may produce up to 5 units in this system.',
      abilities = { 'Mitosis' },
      units = { 'Letani Warrior I', 'Letani Warrior II', 'Letani Behemoth' },
      commander = 'Dirzuga Rophal',
      hero = 'Letani Miasmiala',
      commodities = 3,
      promissoryNotes = { 'Stymie', 'Stymie Ω' },
  }),
  ['The Barony Of Letnev'] = newFaction('The Barony Of Letnev', {
      source = 'base',
      tokenName = 'Barony of Letnev',
      frankenName = 'Letnev',
      home = 10,
      startingUnits = { Infantry = 3, Fighter = 1, Destroyer = 1, Carrier = 1, Dreadnought = 1, Space_Dock = 1 },
      startingTech = { 'Antimass Deflectors', 'Plasma Scoring' },
      factionTech = { "L4 Disruptors", "Non-Euclidean Shielding" },
      flagship = 'Arc Secundus',
      flagshipDescription = "Other players’ units in this system lose PLANETARY SHIELD.  At the start of each space combat round, repair this ship.  BOMBARDMENT 5 (X3)",
      abilities = { 'Munitions Reserves', 'Armada' },
      units = { 'Dunlain Reaper' },
      commander = 'Rear Admiral Farran',
      hero = 'Darktalon Treilla',
      commodities = 2,
      promissoryNotes = { 'War Funding', 'War Funding Ω' },
  }),
  ['The Clan Of Saar'] = newFaction('The Clan Of Saar', {
      source = 'base',
      tokenName = 'Clan of Saar',
      frankenName = 'Saar',
      home = 11,
      startingUnits = { Infantry = 4, Fighter = 2, Cruiser = 1, Carrier = 2, Space_Dock = 1 },
      startingTech = { 'Antimass Deflectors' },
      factionTech = { "Chaos Mapping", "Floating Factory II" },
      flagship = 'Son of Ragh',
      flagshipDescription = 'ANTI-FIGHTER BARRAGE 6 (X4)',
      abilities = { 'Scavenge', 'Nomadic' },
      units = { 'Floating Factory I', 'Floating Factory II', 'Scavenger Zeta' },
      commander = 'Rowl Sarrig',
      hero = 'Gurno Aggero',
      commodities = 3,
      promissoryNotes = { "Ragh's Call" },
  }),
  ['The Embers Of Muaat'] = newFaction('The Embers Of Muaat', {
      source = 'base',
      tokenName = 'Embers of Muaat',
      frankenName = 'Muaat',
      home = 4,
      startingUnits = { Infantry = 4, Fighter = 2, War_Sun = 1, Space_Dock = 1 },
      startingTech = { 'Plasma Scoring' },
      factionTech = { "Prototype War Sun II", "Magmus Reactor" },
      flagship = 'The Inferno',
      flagshipDescription = "ACTION: Spend 1 token from your strategy pool to place 1 cruiser in this unit’s system.",
      abilities = { 'Star Forge', 'Gashlai Physiology' },
      units = { 'Prototype War Sun I', 'Prototype War Sun II', 'Ember Colossus' },
      commander = 'Magmus',
      hero = "Adjudicator Ba'al",
      commodities = 4,
      promissoryNotes = { 'Fires of the Gashlai' },
  }),
  ['The Emirates Of Hacan'] = newFaction('The Emirates Of Hacan', {
      source = 'base',
      tokenName = 'Emirates of Hacan',
      frankenName = 'Hacan',
      home = 16,
      startingUnits = { Infantry = 4, Fighter = 2, Cruiser = 1, Carrier = 2, Space_Dock = 1 },
      startingTech = { 'Antimass Deflectors', 'Sarween Tools' },
      factionTech = { "Quantum Datahub Node", "Production Biomes" },
      flagship = 'Wrath of Kenara',
      flagshipDescription = 'After you roll a die during a space combat in this system, you may spend 1 trade good to apply +1 to the result.',
      abilities = { 'Masters of Trade', 'Guild Ships', 'Arbiters' },
      units = { 'Pride of Kenara' },
      commander = 'Gila the Silvertongue',
      hero = 'Harrugh Gefhara',
      commodities = 6,
      promissoryNotes = { 'Trade Convoys' },
  }),
  ['The Federation Of Sol'] = newFaction('The Federation Of Sol', {
      source = 'base',
      tokenName = 'Federation of Sol',
      frankenName = 'Sol',
      home = 1,
      startingUnits = { Infantry = 5, Fighter = 3, Destroyer = 1, Carrier = 2, Space_Dock = 1 },
      startingTech = { 'Antimass Deflectors', 'Neural Motivator' },
      factionTech = { "Spec Ops II", "Advanced Carrier II" },
      flagship = 'Genesis',
      flagshipDescription = "At the end of the status phase, place 1 infantry from your reinforcements in this system’s space area.",
      abilities = { 'Orbital Drop', 'Versatile' },
      units = { 'Advanced Carrier I', 'Advanced Carrier II', 'Spec Ops I', 'Spec Ops II', 'ZS Thunderbolt M2' },
      commander = 'Claire Gibson',
      hero = 'Jace X, 4th Air Legion',
      commodities = 4,
      promissoryNotes = { 'Military Support' },
  }),
  ['The Ghosts Of Creuss'] = newFaction('The Ghosts Of Creuss', {
      source = 'base',
      tokenName = 'Ghosts of Creuss',
      frankenName = 'Creuss',
      home = 51,
      startingUnits = { Infantry = 4, Fighter = 2, Destroyer = 2, Carrier = 1, Space_Dock = 1 },
      startingTech = { 'Gravity Drive' },
      factionTech = { "Wormhole Generator", "Dimensional Splicer" },
      flagship = 'Hil Colish',
      flagshipDescription = "This ship’s system contains a delta wormhole.  During movement, this ship may move before or after your other ships.",
      abilities = { 'Quantum Entanglement', 'Slipstream', 'Creuss Gate' },
      units = { 'Icarus Drive' },
      commander = 'Sai Seravus',
      hero = 'Riftwalker Meian',
      commodities = 4,
      promissoryNotes = { 'Creuss Iff' },
  }),
  ['The L1Z1X Mindnet'] = newFaction('The L1Z1X Mindnet', {
      source = 'base',
      tokenName = 'L1Z1X Mindnet',
      frankenName = 'L1Z1X',
      home = 6,
      startingUnits = { Infantry = 5, Fighter = 3, Carrier = 1, Dreadnought = 1, Space_Dock = 1, PDS = 1 },
      startingTech = { 'Neural Motivator', 'Plasma Scoring' },
      factionTech = { "Super-Dreadnought II", "Inheritance Systems" },
      flagship = '[0.0.1]',
      flagshipDescription = 'During a space combat, hits produced by this ship and by your dreadnoughts in this system must be assigned to non-fighter ships if able.',
      abilities = { 'Assimilate', 'Harrow' },
      units = { 'Super-Dreadnought I', 'Super-Dreadnought II', 'Annihilator' },
      commander = '2RAM',
      hero = 'The Helmsman',
      commodities = 2,
      promissoryNotes = { 'Cybernetic Enhancements', 'Cybernetic Enhancements Ω' },
  }),
  ['The Mentak Coalition'] = newFaction('The Mentak Coalition', {
      source = 'base',
      tokenName = 'Mentak Coalition',
      frankenName = 'Mentak',
      home = 2,
      startingUnits = { Infantry = 4 ,Fighter = 3, Cruiser = 2, Carrier = 1, Space_Dock = 1, PDS = 1 },
      startingTech = { 'Sarween Tools', 'Plasma Scoring' },
      factionTech = { "Mirror Computing", "Salvage Operations" },
      flagship = 'Fourth Moon',
      flagshipDescription = "Other players’ ships in this system cannot use SUSTAIN DAMAGE.",
      abilities = { 'Ambush', 'Pillage' },
      units = { 'Moll Terminus' },
      commander = "S'ula Mentarion",
      hero = 'Ipswitch, Loose Cannon',
      commodities = 2,
      promissoryNotes = { 'Promise of Protection' },
  }),
  ['The Naalu Collective'] = newFaction('The Naalu Collective', {
      source = 'base',
      tokenName = 'Naalu Collective',
      frankenName = 'Naalu',
      home = 9,
      startingUnits = { Infantry = 4, Fighter = 3, Destroyer = 1, Cruiser = 1, Carrier = 1, Space_Dock = 1, PDS = 1 },
      startingTech = { 'Neural Motivator', 'Sarween Tools' },
      factionTech = { "Hybrid Crystal Fighter II", "Neuroglaive" },
      flagship = 'Matriarch',
      flagshipDescription = 'During an invasion in this system, you may commit fighters to planets as if they were ground forces.  When combat ends, return those units to the space area.',
      abilities = { 'Telepathic', 'Foresight' },
      units = { 'Hybrid Crystal Fighter I', 'Hybrid Crystal Fighter II', 'Iconoclast' },
      commander = "M'aban",
      hero = 'The Oracle',
      commodities = 3,
      promissoryNotes = { 'Gift of Prescience' },
  }),
  ['The Nekro Virus'] = newFaction('The Nekro Virus', {
      source = 'base',
      tokenName = 'Nekro Virus',
      frankenName = 'Nekro',
      home = 8,
      startingUnits = { Infantry = 2, Fighter = 2, Cruiser = 1, Carrier = 1, Dreadnought = 1, Space_Dock = 1 },
      startingTech = { 'Dacxive Animators', 'Valefar Assimilator X', 'Valefar Assimilator Y' },
      factionTech = { "Valefar Assimilator X", "Valefar Assimilator Y" },
      flagship = 'The Alastor',
      flagshipDescription = 'At the start of space combat, choose any number of your ground forces in this system to participate in that combat as is they were ships.  These ground forces do not count against fleet supply.',
      abilities = { 'Galactic Threat', 'Technological Singularity', 'Propagation' },
      startMessage = 'If the Vuil\'raith Cabal isn\'t in your game, purge your Dimensional Tear tokens.',
      units = { 'Mordred' },
      commander = 'Nekro Acidos',
      hero = 'Unit.dsgn.FLAYESH',
      commodities = 3,
      promissoryNotes = { 'Antivirus' },
  }),
  ["The Sardakk N'orr"] = newFaction("The Sardakk N'orr", {
      source = 'base',
      tokenName = "Sardakk N'orr",
      frankenName = 'Sardakk',
      shortName = "N'orr",
      home = 13,
      startingUnits = { Infantry = 5, Cruiser = 1, Carrier = 2, Space_Dock = 1, PDS = 1 },
      startingTech = {},
      factionTech = { "Exotrireme II", "Valkyrie Particle Weave" },
      flagship = "C'morran N'orr",
      flagshipDescription = "Apply +1 to the result of each of your other ship’s combat rolls in this system.",
      abilities = { 'Unrelenting' },
      units = { 'Exotrireme I', 'Exotrireme II', 'Valkyrie Exoskeleton' },
      commander = "G'hom Sek'kus",
      hero = "Sh'val, Harbinger",
      commodities = 3,
      promissoryNotes = { 'Tekklar Legion' },
  }),
  ['The Universities of Jol-Nar'] = newFaction('The Universities of Jol-Nar', {
      source = 'base',
      tokenName = 'Universities of Jol-Nar',
      frankenName = 'Jol-Nar',
      home = 12,
      startingUnits = { Infantry = 2, Fighter = 1, Carrier = 2, Dreadnought = 1, Space_Dock = 1, PDS = 2 },
      startingTech = { 'Antimass Deflectors', 'Neural Motivator', 'Sarween Tools', 'Plasma Scoring' },
      factionTech = { "Spacial Conduit Cylinder", "E-res Siphons" },
      flagship = 'J.N.S. Hylarim',
      flagshipDescription = 'When making a combat roll for this ship, each result of 9 or 10 (before applying modifiers) produces 2 extra hits.',
      abilities = { 'Fragile', 'Brilliant', 'Analytical' },
      units = { 'Shield Paling' },
      commander = 'Ta Zern',
      hero = "Rin, the Master's Legacy",
      commodities = 4,
      promissoryNotes = { 'Research Agreement' },
  }),
  ['The Winnu'] = newFaction('The Winnu', {
      source = 'base',
      tokenName = 'Winnu',
      frankenName = 'Winnu',
      home = 7,
      startingUnits = { Infantry = 2, Fighter = 2, Cruiser = 1, Carrier = 1, Space_Dock = 1, PDS = 1 },
      startingTech = {},
      factionTech = { "Lazax Gate Folding", "Hegemonic Trade Policy" },
      flagship = 'Salai Sai Corian',
      flagshipDescription = "When this unit makes a combat roll, it rolls a number of dice equal to the number of your opponent’s non-fighter ships in this system.",
      startMessage = 'Choose any 1 technology that has no prerequisites.',
      abilities = { 'Blood Ties', 'Reclamation' },
      units = { 'Reclaimer' },
      commander = 'Rickar Rickani',
      hero = 'Mathis Mathinus',
      commodities = 3,
      promissoryNotes = { 'Acquiescence', 'Acquiescence Ω' },
  }),
  ['The Xxcha Kingdom'] = newFaction('The Xxcha Kingdom', {
      source = 'base',
      tokenName = 'Xxcha Kingdom',
      frankenName = 'Xxcha',
      home = 14,
      startingUnits = { Infantry = 4, Fighter = 3, Cruiser = 2, Carrier = 1, Space_Dock = 1, PDS = 1 },
      startingTech = { 'Graviton Laser System' },
      factionTech = { "Instinct Training", "Nullification Field" },
      flagship = 'Loncara Ssodu',
      flagshipDescription = "You may use this unit’s SPACE CANNON against ships that are in adjacent systems.  SPACE CANNON 5 (X3)",
      abilities = { 'Peace Accords', 'Quash' },
      units = { 'Indomitus' },
      commander = 'Elder Qanoj',
      hero = 'Xxekir Grom',
      commodities = 4,
      promissoryNotes = { 'Political Favor' },
  }),
  ['The Yin Brotherhood'] = newFaction('The Yin Brotherhood', {
      source = 'base',
      tokenName = 'Yin Brotherhood',
      frankenName = 'Yin',
      home = 3,
      startingUnits = { Infantry = 4, Fighter = 4, Destroyer = 1, Carrier = 2, Space_Dock = 1 },
      startingTech = { 'Sarween Tools' },
      factionTech = { "Yin Spinner", "Impulse Core" },
      flagship = 'Van Hauge',
      flagshipDescription = 'When this ship is destroyed, destroy all ships in this system.',
      abilities = { 'Indoctrination', 'Devotion' },
      units = { "Moyin's Ashes" },
      commander = 'Brother Omar',
      hero = 'Dannel of the Tenth',
      commodities = 2,
      promissoryNotes = { 'Greyfire Mutagen', 'Greyfire Mutagen Ω' },
  }),
  ['The Yssaril Tribes'] = newFaction('The Yssaril Tribes', {
      source = 'base',
      tokenName = 'Yssaril Tribes',
      frankenName = 'Yssaril',
      home = 15,
      startingUnits = { Infantry = 5, Fighter = 2, Cruiser = 1, Carrier = 2, Space_Dock = 1, PDS = 1 },
      startingTech = { 'Neural Motivator' },
      factionTech = { "Mageon Implants", "Transparasteel Plating" },
      flagship = "Y'sia Y'ssrila",
      flagshipDescription = "This ship can move through systems that contain another players’ ships.",
      abilities = { 'Stall Tactics', 'Scheming', 'Crafty' },
      units = { 'Blackshade Infiltrator' },
      commander = 'So Ata',
      hero = 'Kyver, Blade and Key',
      commodities = 3,
      promissoryNotes = { 'Spy Net' },
  }),
  ['The Nomad'] = newFaction('The Nomad', {
      source = 'PoK',
      tokenName = 'Nomad',
      frankenName = 'Nomad',
      home = 53,
      startingUnits = { Infantry = 4, Fighter = 3, Destroyer = 1, Carrier = 1, Flagship = 1, Space_Dock = 1 },
      startingTech = { 'Sling Relay' },
      factionTech = { "Temporal Command Suite", "Memoria II" },
      flagship = "Memoria I",
      flagshipDescription = "You may treat this unit as if it were adjacent to systems that contain 1 or more of your mechs.",
      abilities = { 'The Company', 'Future Sight' },
      units = { 'Memoria II', 'Quantum Manipulator' },
      commander = 'Navarch Feng',
      hero = 'Ahk-Syl Siven',
      commodities = 4,
      promissoryNotes = { 'The Cavalry' },
  }),
  ["The Vuil'raith Cabal"] = newFaction("The Vuil'raith Cabal", {
      source = 'PoK',
      tokenName = "Vuil'raith Cabal",
      frankenName = "Vuil'raith",
      home = 54,
      startingUnits = { Infantry = 3, Fighter = 3, Cruiser = 1, Carrier = 1, Dreadnought = 1, Space_Dock = 1 },
      startingTech = { 'Self Assembly Routines' },
      factionTech =  { "Vortex", "Dimensional Tear II" },
      flagship = "The Terror Between",
      flagshipDescription = "Capture all other non-structure units that are destroyed in this system, including your own.",
      abilities = { 'Devour', 'Amalgamation', 'Riftmeld' },
      units = { 'Dimensional Tear I', 'Dimensional Tear II', 'Reanimator' },
      commander = 'That Which Molds Flesh',
      hero = 'It Feeds on Carrion',
      commodities = 2,
      promissoryNotes = { 'Crucible' },
      elimInstructions = { include = {ME = {names = {"Tear Token (Cabal)"}}}}
  }),
  ['The Argent Flight'] = newFaction('The Argent Flight', {
      source = 'PoK',
      tokenName = 'Argent Flight',
      frankenName = 'Argent',
      home = 58,
      startingUnits = { Infantry = 5, Fighter = 2, Destroyer = 2, Carrier = 1, Space_Dock = 1, PDS = 1 },
      startingTech = { 'Sarween Tools', 'Neural Motivator', 'Plasma Scoring' },
      factionTech = { "Aerie Hololattice", "Strike Wing Alpha II" },
      flagship = "Quetzecoatl",
      flagshipDescription = "Other players cannot use SPACE CANNON against your ships in this system.",
      abilities = { 'Zeal', 'Raid Formation' },
      startMessage = 'Pick 2 technologies and return the other to your deck.',
      units = { 'Strike Wing Alpha I', 'Strike Wing Alpha II', 'Aerie Sentinel' },
      commander = 'Trrakan Aun Zulok',
      hero = 'Mirik Aun Sissiri',
      commodities = 3,
      promissoryNotes = { 'Strike Wing Ambuscade' },
  }),
  ['The Titans of Ul'] = newFaction('The Titans of Ul', {
        source = 'PoK',
        tokenName = 'Titans of Ul',
        frankenName = 'Titans',
        shortName = 'Ul',
        home = 55,
        startingUnits = { Infantry = 3, Fighter = 2, Cruiser = 2, Dreadnought = 1, Space_Dock = 1 },
        startingTech = { 'Antimass Deflectors', 'Scanlink Drone Network' },
        factionTech = { "Saturn Engine II", "Hel-Titan II" },
        flagship = "Ouranos",
        flagshipDescription = "DEPLOY: After you activate a system that contains 1 or more of your PDS, you may replace 1 of those PDS with this unit.",
        abilities = { 'Terragenesis', 'Awaken', 'Coalescence' },
        units = { 'Saturn Engine I', 'Saturn Engine II', 'Hel-Titan I', 'Hel-Titan II', 'Hecatoncheires' },
        commander = 'Tungstantus',
        hero = 'Ul the Progenitor',
        commodities = 2,
        promissoryNotes = { 'Terraform' },
        elimInstructions = {
          include = {ME = {names = {"Titan Sleeper Token"}}},
          ignore = {ME = {names = {"Terraform"}}}
        }
    }),
  ['The Empyrean'] = newFaction('The Empyrean', {
      source = 'PoK',
      tokenName = 'Empyrean',
      frankenName = 'Empyrean',
      home = 56,
      startingUnits = { Infantry = 4, Fighter = 2, Destroyer = 1, Carrier = 2, Space_Dock = 1 },
      startingTech = { 'Dark Energy Tap' },
      factionTech = { "Aetherstream", "Voidwatch" },
      flagship = "Dynamo",
      flagshipDescription = "After any player's unit in this system or an adjacent system uses SUSTAIN DAMAGE, you may spend 2 influence to repair that unit.",
      abilities = { 'Voidborn', 'Aetherpassage', 'Dark Whispers' },
      units = { 'Watcher' },
      commander = 'Xuange',
      hero = 'Conservator Procyon',
      commodities = 4,
      promissoryNotes = { 'Blood Pact', 'Dark Pact' },
  }),
  ['The Mahact Gene-Sorcerers'] = newFaction('The Mahact Gene-Sorcerers', {
      source = 'PoK',
      tokenName = 'Mahact Gene-Sorcerers',
      frankenName = 'Mahact',
      home = 52,
      startingUnits = { Infantry = 3, Fighter = 2, Cruiser = 1, Carrier = 1, Dreadnought = 1, Space_Dock = 1 },
      startingTech = { 'Predictive Intelligence', 'Bio-Stims' },
      startMessage = 'Purge your Alliance promissory note.',
      factionTech = { "Crimson Legionnaire II", "Genetic Recombination" },
      flagship = "Arvicon Rex",
      flagshipDescription = "During combat against an opponent whose command token is not in your fleet pool, apply +2 to the results of this unit's combat rolls.",
      abilities = { 'Edict', 'Imperia', 'Hubris' },
      units = { 'Crimson Legionnaire I', 'Crimson Legionnaire II', 'Starlancer' },
      commander = 'Il Na Viroset',
      hero = 'Airo Shir Aur',
      commodities = 3,
      promissoryNotes = { 'Scepter of Dominion' },
      elimInstructions = {
        DO = {guid = self.getGUID(), func = "_resolveImperiaElim"},
        ignore = { OTHERS = {GET = {guid = self.getGUID(), func = "_resolveImperiaElim"}}},
      }
  }),
  ['The Naaz-Rokha Alliance'] = newFaction('The Naaz-Rokha Alliance', {
      source = 'PoK',
      tokenName = 'Naaz-Rokha Alliance',
      frankenName = 'Naaz-Rokha',
      home = 57,
      startingUnits = { Infantry = 3, Fighter = 2, Carrier = 2, Destroyer = 1, Mech = 1, Space_Dock = 1 },
      startingTech = { 'Psychoarchaeology', 'AI Development Algorithm' },
      factionTech = { "Supercharge", "Pre-Fab Arcologies" },
      flagship = "Visz El Vir",
      flagshipDescription = "Your mechs in this system roll 1 additional die during combat.",
      abilities = { 'Distant Suns', 'Fabrication' },
      units = { 'Eidolon' },
      commander = 'Dart and Tai',
      hero = 'Hesh and Prit',
      commodities = 3,
      promissoryNotes = { 'Black Market Forgery' },
  }),
  ['The Council Keleres ~ Argent'] = newFaction('The Council Keleres ~ Argent', {
      source = 'Codex3',
      tokenName = 'Keleres ~ Argent',
      frankenName = 'Keleres ~ Argent',
      home = 258,
      startingUnits = { Infantry = 2, Fighter = 2, Carrier = 2, Cruiser = 1, Space_Dock = 1 },
      startingTech = { },
      factionTech = { "Supercharge", "Pre-Fab Arcologies" },
      flagship = "Artemiris",
      flagshipDescription = "",
      abilities = { 'The Tribunii', 'Council Patronage', "Law's order" },
      units = { 'Omniopiares' },
      commander = 'Suffi An',
      hero = 'Kuuasi Aun Jalatai',
      commodities = 2,
      promissoryNotes = { 'Keleres Rider' },
  }),
  ['The Council Keleres ~ Mentak'] = newFaction('The Council Keleres ~ Mentak', {
      source = 'Codex3',
      tokenName = 'Keleres ~ Mentak',
      frankenName = 'Keleres ~ Mentak',
      home = 202,
      startingUnits = { Infantry = 2, Fighter = 2, Carrier = 2, Cruiser = 1, Space_Dock = 1 },
      startingTech = { },
      factionTech = { "Supercharge", "Pre-Fab Arcologies" },
      flagship = "Artemiris",
      flagshipDescription = "",
      abilities = { 'The Tribunii', 'Council Patronage', "Law's order" },
      units = { 'Omniopiares' },
      commander = 'Suffi An',
      hero = 'Harka Leeds',
      commodities = 2,
      promissoryNotes = { 'Keleres Rider' },
  }),
  ['The Council Keleres ~ Xxcha'] = newFaction('The Council Keleres ~ Xxcha', {
      source = 'Codex3',
      tokenName = 'Keleres ~ Xxcha',
      frankenName = 'Keleres ~ Xxcha',
      home = 214,
      startingUnits = { Infantry = 2, Fighter = 2, Carrier = 2, Cruiser = 1, Space_Dock = 1 },
      startingTech = { },
      factionTech = { "Supercharge", "Pre-Fab Arcologies" },
      flagship = "Artemiris",
      flagshipDescription = "",
      abilities = { 'The Tribunii', 'Council Patronage', "Law's order" },
      units = { 'Omniopiares' },
      commander = 'Suffi An',
      hero = 'Odlynn Myrr',
      commodities = 2,
      promissoryNotes = { 'Keleres Rider' },
  }),
}

--factions can have dynamic commodity values and commoditiess can be mutated by abilities (Dynamis Core)
local COMMODITIES = {}
local _commodityMutators = {
  ['+2 Commodities'] = {
    type = "ADJUST",
    sources = {{
      target = "OWNER",
      find = {OBJECTS = {"Dynamis Core"}}
    }},
    stackable = true,
    callData = {obj = self, func = "applyPlusTwoCommodities"}
  },
}

local _update = {
    time = false,
    periodicUpdateSeconds = 30,
}

local _state = {
    frankenEnabled = false
}

--Public Gets-------------------------------------------------------------------
function isFrankenEnabled()
    return _state.frankenEnabled
end

function allFactions(includeFactionsNotAtTable)
  if includeFactionsNotAtTable and type(includeFactionsNotAtTable) == "table" then includeFactionsNotAtTable = includeFactionsNotAtTable[1] end
    --assert(not includeFactionsNotAtTable or type(includeFactionsNotAtTable) == 'boolean')--Blocking the assert to allow other scripts to call
    if includeFactionsNotAtTable then
        return _getAllFactionData()--_factionAttributes
    else
        _maybeUpdateFactions()
        _updateCommodityValues()
        return _colorToFaction
    end
end

function fromColor(color)
    assert(type(color) == 'string')
    _maybeUpdateFactions()
    _updateCommodityValues()
    return _colorToFaction[color]
end

--- Get faction from token name (strips off any "owner token" or "command token" suffix, if present)
function fromTokenName(tokenName)
    assert(type(tokenName) == 'string')
    tokenName = string.match(tokenName, '^(.*) .* Token$') or tokenName
    if string.len(tokenName) > 0 then
        _maybeUpdateFactions()
        _updateCommodityValues()
        return _lowerTokenNameToFaction[string.lower(tokenName)]
    end
end

--Get a faction's commodity value by name or by color
--@params = "target" or {target = "target", forceUpdate = true} target = color or faction name
  --commodity values are only updated once per frame(when requested),
  --set forceUpdate to true if you know you are making changes to a mutator the same frame you are reading the value (like giving a player Dynamis Core)
function getCommodities(params)
  assert(params and type(params) == "string" or (type(params) == "table" and params.target == "string"))
  local target = type(params) == "string" and params or params.target

  COMMODITIES.update(type(params) == "table" and params.forceUpdate)
  return COMMODITIES.mutate(target)
end

--- Return map from player color to list of commander names.
function getColorToCommanders()
    local commanderNameSet = {}  -- some may still be face down!
    local colorToFactionCommander = {}
    local commandTokenNameToColor = {}
    local allianceCardNameToColor = {}
    local imperiaColorSet = false
    for color, faction in pairs(allFactions()) do
        if faction.commander then
            commanderNameSet[faction.commander] = true
            colorToFactionCommander[color] = faction.commander
        end
        commandTokenNameToColor[faction.tokenName .. ' Command Token'] = color
        allianceCardNameToColor['Alliance (' .. color .. ')'] = color
        if faction.frankenName then
            allianceCardNameToColor[faction.frankenName .. ' Alliance'] = color
        end
        if faction.shortName then
            allianceCardNameToColor[faction.shortName .. ' Alliance'] = color
        end
        for _, ability in ipairs(faction.abilities or {}) do
            if ability == 'Imperia' then
                imperiaColorSet = imperiaColorSet or {}
                imperiaColorSet[color] = true
            end
        end
    end

    -- If not using imperia do not bother finding command tokens.
    if not imperiaColorSet then
        commandTokenNameToColor = {}
    end

    -- Find alliance cards and command tokens (for imperia).
    local availableCommanderNameSet = {}
    local activeCommanderNameSet = {}  -- also track toggleActive state, when present
    local guidToAllianceColor = {}
    local guidToCommandTokenColor = {}
    local guidToPosition = {}
    local inHandGuidSet = _zoneHelper.inHand()
    for _, object in ipairs(getAllObjects()) do
        local guid = object.getGUID()
        if not inHandGuidSet[guid] then
            local name = object.getName()
            if commanderNameSet[name] and (not object.is_face_down) then
                availableCommanderNameSet[name] = true
                -- Also track if idle/active
                local isActive = true
                if _unitHelper._isToggleActiveCard(object) then
                    isActive = _unitHelper._isToggleActiveCardActive(object)
                end
                activeCommanderNameSet[name] = isActive
            end
            local color = (object.tag == 'Card') and (not object.is_face_down) and allianceCardNameToColor[name]
            if color then
                guidToAllianceColor[guid] = color
                guidToPosition[guid] = object.getPosition()
            end
            local color = commandTokenNameToColor[name]
            if color then
                guidToCommandTokenColor[guid] = color
                guidToPosition[guid] = object.getPosition()
            end
        end
    end
    local guidToZoneColor = _zoneHelper.zonesFromPositions(guidToPosition)

    local colorToCommanders = {}
    local function addCommanderIfUnlocked(color, commander, requireActive)
        assert(type(color) == 'string' and type(commander) == 'string')
        if not availableCommanderNameSet[commander] then
            return  -- locked
        end
        if requireActive and (not activeCommanderNameSet[commander]) then
            return  -- idle
        end
        local commanders = colorToCommanders[color]
        if not commanders then
            commanders = {}
            colorToCommanders[color] = commanders
        end
        for _, entry in ipairs(commanders) do
            if entry == commander then
                return -- already have this one
            end
        end
        table.insert(commanders, commander)
    end

    -- Add native.
    for color, commander in pairs(colorToFactionCommander) do
        addCommanderIfUnlocked(color, commander, true)
    end

    -- Reject any alliances if a card is toggle and idle.  There may be several
    -- ways an alliance is added (imperia, promissory, etc) so reject those too.
    local zoneColorToRejectAllianceColorSet = {}
    for guid, allianceColor in pairs(guidToAllianceColor) do
        local card = getObjectFromGUID(guid)
        local zoneColor = guidToZoneColor[guid]
        if zoneColor and _unitHelper._isToggleActiveCard(card) and not _unitHelper._isToggleActiveCardActive(card) then
            local rejectAllianceColorSet = zoneColorToRejectAllianceColorSet[zoneColor]
            if zoneColor and not rejectAllianceColorSet then
                rejectAllianceColorSet = {}
                zoneColorToRejectAllianceColorSet[zoneColor] = rejectAllianceColorSet
            end
            rejectAllianceColorSet[allianceColor] = true
        end
    end

    -- Add alliances.
    for guid, allianceColor in pairs(guidToAllianceColor) do
        -- If the alliance card has toggle active, only add it if active.
        local considerCard = true
        local requireActive = true
        local card = getObjectFromGUID(guid)
        local zoneColor = guidToZoneColor[guid]

        -- If card is active, do not require commander to be active.
        if _unitHelper._isToggleActiveCard(card) then
            if _unitHelper._isToggleActiveCardActive(card) then
                requireActive = false  -- alliance marked active
            else
                considerCard = false  -- alliace marked idle, disregard completely
            end
        end

        -- If card is idle, reject all alliances to that commander.
        local rejectAllianceColorSet = zoneColorToRejectAllianceColorSet[zoneColor]
        if rejectAllianceColorSet and rejectAllianceColorSet[allianceColor] then
            considerCard = false
        end

        if considerCard and zoneColor and (zoneColor ~= allianceColor) then
            local commander = colorToFactionCommander[allianceColor]
            if commander then
                addCommanderIfUnlocked(zoneColor, commander, requireActive)
            end
        end
    end

    -- Add Imperia.
    for guid, commandTokenColor in pairs(guidToCommandTokenColor) do
        local zoneColor = guidToZoneColor[guid]
        if zoneColor and (zoneColor ~= commandTokenColor) and imperiaColorSet[zoneColor] then
            local commander = colorToFactionCommander[commandTokenColor]
            if commander then
                addCommanderIfUnlocked(zoneColor, commander, true)
            end
        end
    end

    return colorToCommanders
end

--returns ANY players' tokens in the target color's strategy pool (Imperia exists)
function getStrategyTokens(color)
  local _faction = assert(color and type(color) == "string" and _colorToFaction[color], color.." does not have a faction, cannot get strategy tokens.")
  local _commSheet = assert(getObjectFromGUID(_faction.commandSheetGuid), "Failed to find "..color.."'s command sheet.")

  local _allTokens = {}
  for eachCol,faction in pairs(_colorToFaction) do
    _allTokens[(faction.tokenName .. " Command Token")] = true
    _allTokens[(eachCol .. " Command Token")] = true
  end

  local result = {}
  local function _isTokenInStrat(tokenObj)
    if eachObj.is_face_down then return false end
    local pos = _commSheet.positionToLocal(tokenObj.getPosition())
    if pos.x < 2 and pos.x > -4 and pos.z > -0.3 and pos.z < 3.5 then
      return true
    end
    return false
  end

  for _,eachObj in ipairs(getAllObjects()) do
    local oName = eachObj.getName()
    if _isTokenInStrat(eachObj) then
      table.insert(result, eachObj)
    end
  end

  return result
end

--Injection---------------------------------------------------------------------

--[[Inject a custom faction
  --You may make some of these fields dynamic. Compatable fields are marked with a *{GET} table
  --set that field equal to the GET table and provide the default value to make it dynamic. (makke sure your script has a funcion defined with a name matching func)
  --you may add: params = {someParams} into the GET table, those params will be provided to the func when called
local factionFormat = {
  source = '',--define this faction as part of a group (default to "unsourcedHomebrew")
  name = 'The Example Faction', --fullName
  tokenName = 'Example Faction',
  frankenName = 'Example',
  home = #,--tile number of Home system tile *{GET = true, obj = self, func = "getHS", default = #},
  startingUnits = { Infantry = 4, Fighter = 2, Carrier = 1, Space_Dock = 1},--Destroyer,Cruiser,Dreadnought,Flagship,War_Sun,PDS,Mech
  startingTech = { 'StringName', },
  factionTech = { "TechName", "Example Unit I", "Example Unit II" },
  flagship = '',--flagship's name --*{GET = true, obj = self, func = "getFlagship", default = ""},
  flagshipDescription = '',
  abilities = { "", },--list of strings --*{GET = true, obj = self, func = "getAbilities", default = {""}},
  units = { 'Example Unit I', 'Example Unit II', 'Mech Name' }, --*{GET = true, obj = self, func = "getUnits", default = {""}},
  commodities = 3, --*{GET = true, obj = self, func = "getCommodities"}, --params: {color = factionColor, faction = factionName} --return #
  promissoryNotes = { "" },--list of strings
  commander = '', --string
  hero = '',--string
  --Optionally define a function to resolve the hero's ability
  --heroAbility = {guid = self.getGUID(), func = "resolveHeroAbility", abilityName = "optionalName"},
    --params: {obj = cardObjRef, usingColor = ""color of player resolving ability}
    --return true to purge the card

  --eliminationQuotes = "String" or table of {"Strings",...}(will be randomly chosen)
  elimInstructions = {--Only resolved whan an elim is automated (not just declared)
    DO = {guid = self.getGUID(), func = "doFuncName"},--no return.--Do something BEFORE the elimination is resolved
    ignore = {
    --ME means this faction was eliminated, OTHERS means another faction was elim'd
    --All ME and OTHER tables are formatted the same
      ME = {
        names = {}, --table of {"strings"}. Objects with these names will not be returned
        guids = {}, --table of {"guids"}. Objects with these guids will not be returned
        GET = {guid = self.getGUID(), func = "getFuncName"},--params:{color}, return: {names = {}, guids = {}}
      },
      OTHERS = {}
    },
    include = { ME = {}, OTHERS = {}}
  },

  --internal fields
  -- - color (string) or nil if not in use.
  -- - commandSheetGuid (string) or nil if not in use.
  -- - factionSheetGuid (string) or nil if not in use.
  -- - printedCommodities (int or table{obj, func} *initialized to the commodity field. commodities is recalculated on each get request
}
--]]
function injectFaction(faction)
    assert(type(faction) == 'table')

    -- Unclear if the faction is shared with the caller, make a copy to be
    -- sure any later mutations to the caller's version does not change this.
    local function copyTable(t)
        if t and type(t) == 'table' then
            local copy = {}
            for k, v in pairs(t) do
                copy[k] = type(v) == 'table' and copyTable(v) or v
            end
            t = copy
        end
        return t
    end
    faction = copyTable(faction)

    local success, errorMessage = _factionIsValid(faction)
    if not success then
        error('injectFaction: ' .. errorMessage)
    end

    if _factionAttributes[faction.name] then
        print('injectFaction: WARNING, already have "' .. faction.name ..'", replacing with new attributes.')
    end

    --format/add fields
    faction.promissoryNotes = type(faction.promissoryNotes) == "table" and faction.promissoryNotes or {faction.promissoryNotes}
    faction.source = faction.source or "unsourcedHomebrew"

    _factionAttributes[faction.name] = newFaction(faction.name, faction)
    _lowerTokenNameToFaction[string.lower(faction.name)] = faction  -- index by all name flavors
    if faction.tokenName then
        _lowerTokenNameToFaction[string.lower(faction.tokenName)] = faction
    end
    if faction.frankenName then
        _lowerTokenNameToFaction[string.lower(faction.frankenName)] = faction
    end
    if faction.shortName then
        _lowerTokenNameToFaction[string.lower(faction.shortName)] = faction
    end

    -- Tell deck helper about promissory notes (for discard back to player).
    for _, cardName in ipairs(faction.promissoryNotes or {}) do
        _deckHelper.injectCard({
            cardName = cardName,
            factionName = faction.name
        })
    end

    -- Add hero to hero name set for purge menu item, apply now if card exists.
    if faction.hero then
        local cardName = faction.hero
        if _heroNameSet then
            _heroNameSet[cardName] = true
        end
        if _hasContextMenuCardNameSet then
            _hasContextMenuCardNameSet[cardName] = true
        end
        --allow injecting script to resolve the hero's ability
        if faction.heroAbility then
          assert(type(faction.heroAbility) == "table" and type(faction.heroAbility.func) == "string")
          local function customResolveAbility(owningObj, usingColor)
            if not _heroCardCanBeUsed(owningObj, usingColor) then return end

            local doPurge = tryCall(faction.heroAbility, {obj = owningObj, usingColor = usingColor})
            if owningObj.tag == 'Card' and doPurge then
                purgeCard(owningObj)
            end
          end

          _factionCardNameToAbilityFunc[cardName] = {name = faction.heroAbility.abilityName or cardName, method = customResolveAbility}
        end
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == cardName then
                _applyContextMenuItems(object)
            end
        end
    end
end

--[[Mutators such as Dynamis Core that change a faction's commodity value
local mutatorFormat = {
  id = "Unique Identifer", --Give this mutator a unique ID
  --Sources determine when this rule is in play and who it effects
  sources = { --single table or a table of source tables
    isUniversalRule = false, --should this mutator always apply?
    --if not universal, find is how we determine if this source is active/in play
    find = { --You may ommit any of these subTables
      FACTION_ABILITIES = {"abilityName_1",...},
      OBJECTS = {"stringName", objectTable}, --Look for objects that may enable this rule
       --mixed table of stings/objectTables. objectTables allow additional settings
       {--objectTable format:
        --*How to find this object(include only 1)
        *name = "",
        *guid = "",

        requireFaceup = false,
        requireActive = false, --Does the object have a toggle Active button (unit modifier cards only), this does not create a toggel button for the obj
        isDiscardable = false, --set to true to prevent this object from being found in it's discard pile (if aplicable)
      },
      GET = {obj = self, func = "isSourceActive"}, --function should return true if this source is active/in play
    },
    --If this source is active/in play, who will it effect?
    target = "OWNER", --"OWNER"|"OTHER"|"ALL"|"GET" --(OTHER == not OWNER)
    --if target is "GET", you must include getTarget
    --getTarget = {obj = self, func = "getTargetFunc"}, --function should return a color or table of colors to target

    --*internal values
    --isActive = bool,
    --_activeObjects = {objRef},--objects from refs that have been found (and are faceup/active if required)
    --_activeAbilityOwners = {[color] = true}, --color indexed list of colors whose factions have an ability found in refs.FACTION_ABILITIES
  },

  type = "MUTATE", --or "ADJUST" --MUTATE resolves first, then ADJUST effects
  stackable = false, --can this mutator be applied multiple times to the same player

  callData = {obj = self, func = "myCommodityFunctionName"}, --your function should return the new commodity value as a number
    --params:{color = targetColor, commodities = #(the current commodity value), printedCommodities = #(The faction's unaltered commodity value)}

  --*Internal fields:
  --_activeTargets = {} --table of colors: {["Blue"] = #,...} # = the number of times to apply this rule to the target (if rule is stackable)
}
--]]
function injectCommodityMutator(params)
  assert(params and type(params) == "table")
  assert(params.id and type(params.id) == "string", "You must give your commodity mutator a name/id.")
  assert(params.type and params.type == "MUTATE" or params.type == "ADJUST", "CommodityMutator.type should be 'MUTATE' or 'ADJUST'.")

  assert(params.callData and type(params.callData) == "table", "CommodityMutator must have a .callData field that is a table containing an object referance(.obj) and the string name of a function on that object's script(.func)")
  assert(params.callData.func and type(params.callData.func) == "string", "CommodityMutator must have a .callData field that is a table containing an object referance(.obj) and the string name of a function on that object's script(.func)")--Obj does not need to exist at this point

  assert(params.sources and type(params.sources) == "table")
  local newMutator = copyTable(params)
  --format sources table
  newMutator.sources = newMutator.sources[1] and newMutator.sources or {newMutator.sources}
  for _,eachSource in ipairs(newMutator.sources) do
    assert((eachSource.find == nil and eachSource.isUniversalRule) or type(eachSource.find) == "table")
    if eachSource.find then
      if eachSource.find.OBJECTS then
        local formatObjTable = (type(eachSource.find.OBJECTS) == "string" and {eachSource.find.OBJECTS}) or eachSource.find.OBJECTS[1] and eachSource.find.OBJECTS or {eachSource.find.OBJECTS}
        eachSource.find.OBJECTS = formatObjTable
        for _, objData in ipairs(eachSource.find.OBJECTS) do
          if type(objData) == "table" then
            assert((objData.name or objData.guid) and not (objData.name and objData.guid))
          end
        end
      end
      if eachSource.find.FACTION_ABILITIES then
        eachSource.find.FACTION_ABILITIES = type(eachSource.find.FACTION_ABILITIES) == "table" and eachSource.find.FACTION_ABILITIES or {eachSource.find.FACTION_ABILITIES}
      end
      if eachSource.find.GET then
        assert(type(eachSource.find.GET) == "table" and eachSource.find.GET.func and type(eachSource.find.GET.func) == "string")
      end
    end
  end

  if _commodityMutators[params.id] then
    print("INJECTION_WARNING:\nThe commodity mutator ", params.id, " already exists; previous mutator will be replaced.")
  end
  _commodityMutators[params.id] = newMutator
end

--------------------------------------------------------------------------------
function _getFactionData(faction)
  assert(faction and _factionAttributes[faction])
  local result = {}
  for k,v in pairs(_factionData[faction]) do
    result[k] = _factionAttributes[faction][k]
  end

  return result
end

function _getAllFactionData()
  local result = {}
  for fullName, data in pairs(_factionData) do
    result[fullName] = _getFactionData(fullName)
  end

  return result
end

--Commodity utilities-----------------------------------------------------------
function _reportCommodityMutators()
  return copyTable(_commodityMutators)
end

--params = {color = targetColor, commodities = #(the current commodity value), printedCommodities = #}
function applyPlusTwoCommodities(params)
  assert(params and type(params) == "table")
  assert(params.commodities)
  return params.commodities + 2
end

COMMODITIES._getActiveSources = function()
  local objectsToFind = {guid = {}, name = {}}--["objName"] = {{sourceRef},{s2},...}
  local abilitiesToFind = {}
  local function unpackedFactionsWithAbility(abilityName)
    --Returns a table of faction names that have this ability and that are also unpacked
    local result = {}
    --This func may be run while _colorToFaction is being built, so we'll have to run through _factionData to get factions with a color field
    for factionName,data in pairs(_factionData) do
      if data.color then --Faction is unpacked
        for _,eachAbility in ipairs(data.abilities) do
          if eachAbility == abilityName then table.insert(result, factionName) break end
        end
      end
    end

    return next(result) and result or false
  end

  for mutatorID,data in pairs(_commodityMutators) do
    data._activeTargets = {}

    for _,eachSource in ipairs(data.sources) do
      eachSource.isActive = eachSource.isUniversalRule or false
      eachSource._activeObjects = false
      eachSource._activeAbilityOwners = false

      --Gather a list of objects to find, later we'll search getAllObjects once
      if eachSource.find then
        if eachSource.find.GET then
          eachSource.isActive = tryCall(eachSource.find.GET) or false
        else
          local OBJECTS = eachSource.find.OBJECTS and (type(eachSource.find.OBJECTS) == "string" and {eachSource.find.OBJECTS}) or {}
          for _,objData in ipairs(eachSource.find.OBJECTS or {}) do
            local findByName = type(objData) == "string" or objData.name or false
            local key = type(objData) == "string" and objData or objData.name or objData.guid
            local isTable = type(objData) == "table"
            if findByName then
              objectsToFind.name[key] = objectsToFind.name[key] or {}
              table.insert(objectsToFind.name[key],
                {source = eachSource,
                requireFaceup = isTable and objData.requireFaceup,
                requireActive = isTable and objData.requireActive,
                isDiscardable = isTable and objData.isDiscardable,
                })
            else
              objectsToFind.guid[key] = objectsToFind.guid[key] or {}
              table.insert(objectsToFind.guid[key],
                {source = eachSource,
                requireFaceup = isTable and objData.requireFaceup,
                requireActive = isTable and objData.requireActive,
                isDiscardable = isTable and objData.isDiscardable,
                })
            end
          end
          --find faction abilities
          for _,each in ipairs(eachSource.find.FACTION_ABILITIES or {}) do
            abilitiesToFind[each] = abilitiesToFind[each] or {}
            table.insert(abilitiesToFind[each], eachSource)
          end
        end
      end
    end
  end

  --Get active faction abilities
  for color,eachFaction in pairs(_colorToFaction or {}) do
    for _,eachAbility in ipairs(eachFaction.abilities or {}) do
      for _,eachSource in ipairs(abilitiesToFind[eachAbility] or {}) do
        eachSource.isActive = true
        eachSource._activeAbilityOwners = eachSource._activeAbilityOwners or {}
        eachSource._activeAbilityOwners[color] = true
      end
    end
  end

  --Now seach all objects and find source objects that are on the table
  for _,eachObj in ipairs(getAllObjects()) do
    local name = eachObj.getName()
    local guid = eachObj.getGUID()
    if objectsToFind.name[name] or objectsToFind.guid[guid] then
      local mergedResults = objectsToFind.name[name] or {}
      local foundGUID = objectsToFind.guid[guid] or {}
      for _,each in ipairs(foundGUID) do
        table.insert(mergedResults, each)
      end
      for _,eachResult in ipairs(mergedResults) do
        if (not eachResult.requireFaceup or not eachObj.is_face_down)
            and (not eachResult.requireActive or not _unitHelper._isToggleActiveCard(eachObj) or _unitHelper._isToggleActiveCardActive(eachObj))
            and (not eachResult.isDiscardable or not _deckHelper.isDiscard(guid))
            then
          eachResult.source.isActive = true
          eachResult.source._activeObjects = eachResult.source._activeObjects or {}
          table.insert(eachResult.source._activeObjects, eachObj)
        end
      end
    end
  end
end

COMMODITIES._getActiveTargets = function()
  local function getTargetsFromGet(rule, source)
    local result = tryCall(source.getTarget) or {}
    return type(result) == "table" and result or {result}
  end

  local function getTargetsFromOwner(rule, source)
    local targets = {}
    --if an ability obj is in a player zone, add that player to targets
    for _,eachObj in ipairs(source._activeObjects or {}) do
      local zoneColor = _zoneHelper.zoneFromPosition(eachObj.getPosition())
      if zoneColor then table.insert(targets, zoneColor) end
    end
    --if a faction has the specified ability, add that player to targets
    for eachCol,bool in pairs(source._activeAbilityOwners or {}) do
      table.insert(targets, eachCol)
    end

    return targets
  end

  local function getTargetsFromOther(rule, source)
    local allCols = _zoneHelper.zones()
    local targets = {}
    local function addOthers(excludeCol)
      for _,each in ipairs(allCols) do
        if each ~= excludeCol then
          table.insert(targets, each)
        end
      end
    end

    --if an ability obj is in a player zone, add other players to targets
    for _,eachObj in ipairs(source._activeObjects or {}) do
      local zoneColor = _zoneHelper.zoneFromPosition(eachObj.getPosition())
      if zoneColor then addOthers(zoneColor) end
    end
    --if a faction has the specified ability, add other players to targets
    for eachCol,bool in pairs(source._activeAbilityOwners or {}) do
      addOthers(eachCol)
    end

    return targets
  end

  local function getTargetsFromAll(rule, source)
    return _zoneHelper.zones()
  end

  local switch = {
    ["GET"] = getTargetsFromGet,
    ["OWNER"] = getTargetsFromOwner,
    ["OTHER"] = getTargetsFromOther,
    ["ALL"] = getTargetsFromAll,
    ["catch"] = function(rule, source)
      local errMsg = { val = source.target or "nil", rule = rule.id or "nil"}
      error("Caught bad value >"..errMsg.val.."< for target type in a source for commodity mutator >"..errMsg.rule.."<")
      return
    end
  }

  --Sets ._activeTargets of each rule to a table of colors that are effected by that rule
    --._activeTargets = {["Blue"] = 2} #indicates how many times to apply this mutator (if it is stackable)
  for _,eachRule in pairs(_commodityMutators) do
    eachRule._activeTargets = {}
    for _,eachSource in ipairs(eachRule.sources) do
      if eachSource.isActive then
        local try = switch[eachSource.target] and eachSource.target or "catch"
        local result = switch[try](eachRule, eachSource) or {}
        for _,eachCol in ipairs(result) do
          eachRule._activeTargets[eachCol] = eachRule.stackable and (eachRule._activeTargets[eachCol] and eachRule._activeTargets[eachCol] + 1) or 1
        end
      end
    end
  end
end

local _commoditiesThisFrame = false
COMMODITIES.update = function(forceUpdate)
  if _commoditiesThisFrame then
    if forceUpdate then Wait.stop(_commoditiesThisFrame)
    else
      return
    end
  end
  _commoditiesThisFrame = Wait.frames(function() _commoditiesThisFrame = false end, 1)

  COMMODITIES._getActiveSources()
  COMMODITIES._getActiveTargets()
  --update the public faction table
  for eachCol,data in pairs(_colorToFaction or {}) do
    data.commodities = COMMODITIES.mutate(data.name)
  end
end

--target = "color" or "factionName"
COMMODITIES.mutate = function(target)
  local faction = _factionData[target] or _colorToFaction[target] and _colorToFaction[target].name or false
  if not faction or not _factionData[faction] then return 0 end --faction does not exist or color has not unpacked a faction

  local baseValue = _factionData[faction].printedCommodities or 0
  --For dynamic commodity values: commodities = {obj = self, func = "getCommodityFunc"}
  --func should be the name of a function on your object's script that returns the commodity value as an integer

  --is faction in play?
  local targetColor = _factionData[faction].color
  if not targetColor then
    return type(baseValue) == "number" and baseValue or 0 --Don't compute variable commodity values for factions not unpacked
  end

  --else
  --now apply any mutators to the base commodity value (if faction is unpacked)
  if type(baseValue) == "table" then baseValue = tryCall(baseValue, {color = targetColor, faction = faction}) or 0 end
  local adjustedValue = baseValue

  for mutName,data in pairs(_commodityMutators) do
    if data.type == "MUTATE" and data._activeTargets[targetColor] then
      local count = data._activeTargets[targetColor]
      for i = 1, count, 1 do
        adjustedValue = tryCall(data.callData, {color = targetColor, commodities = adjustedValue, printedCommodities = baseValue}) or adjustedValue
      end
    end
  end

  for mutName,data in pairs(_commodityMutators) do
    if data.type == "ADJUST" and data._activeTargets[targetColor] then
      local count = data._activeTargets[targetColor]
      for i = 1, count, 1 do
        adjustedValue = tryCall(data.callData, {color = targetColor, commodities = adjustedValue, printedCommodities = baseValue}) or adjustedValue
      end
    end
  end

  --print("[",targetColor,"]",faction, " ", baseValue, " --> ", adjustedValue)
  return adjustedValue
end

function tryCall(callData, params)
  local function try()
    assert(callData and type(callData) == "table")
    assert(callData.obj ~= nil and type(callData.obj) == "userdata")
    assert(callData.func and type(callData.func) == "string" and callData.obj.getVar(callData.func), 'missing ' .. callData.obj.getName() .. '.' .. callData.func)
    local passParams = params == nil and {} or type(params) == "table" and params or {params}
    local dataParams = callData.params == nil and {} or type(callData.params) == "table" and callData.params or {callData.params}
    local mergedParams = {} --params will overide callData.params values that have the same key
    for k,v in pairs(dataParams) do mergedParams[k] = v end
    for k, v in pairs(passParams) do
      if type(k) == "number" then table.insert(mergedParams, v)
      else mergedParams[k] = v
      end
    end
    return callData.obj.call(callData.func, mergedParams)
  end
  local success, result = pcall(try)
  if not success then print("Failed callback: callData incorrectly formated. ", result) return end
  return result
end

--Trade Agreement Commodity Fetcher---------------------------------------------

local _tgBags = {}--{[x1 Comm...] = {guids}, [x3...] = {guids}}
local _coRunner = false
local _runningCommFetches = {}

function contextMenu_fetchCommodities(playerColor, objPos, obj)
  local TA_Color = string.sub(obj.getName(), 18, string.len(obj.getName()) -1) or obj.getGMNotes()--For non TradeAgreement objects to use gmNotes
  if not _colorToFaction[TA_Color] then
    Player[playerColor].print("Failed to fetch commodities: No faction is using this trade agreement.", Color.Red)
    return
  end

  --Read commodities from _factionAttributes to trigger update of commodity mutators/getFunctions
  COMMODITIES.update()
  local commValue = getCommodities(TA_Color) or 0

  if commValue < 1 then return end

  local function getBag(objectName)
    local function getClosestBag(guidList)
      local result = false
      local bestDistance = false
      for _,each in ipairs(guidList) do
        local candidate = getObjectFromGUID(each)
        local p1 = objPos
        local p2 = candidate.getPosition()
        local dSq = ((p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2)
        if not bestDistance or dSq < bestDistance then
            result = candidate
            bestDistance = dSq
        end
      end
      return result
    end

    -- Do we already have the bag guids?
    local bagList = _tgBags[objectName]
    if bagList and type(bagList) == "table" and #bagList == 2 then
        return getClosestBag(bagList)
    end

    local acceptBag = { [objectName .. ' Bag'] = true }
    for _, candidate in ipairs(getAllObjects()) do
        local tag = candidate.tag
        local name = candidate.getName()
        if (tag == 'Bag' or tag == 'Infinite') and acceptBag[name] then
          if not _tgBags[objectName] then _tgBags[objectName] = {} end
          table.insert(_tgBags[objectName], candidate.getGUID())
        end
    end
    return getClosestBag(_tgBags[objectName])
  end

  local fetchCo = coroutine.create(function()
    math.randomseed(Time.time)
    local fetchingPlayer = playerColor
    local objRef = obj
    local taColor = TA_Color
    Player[playerColor].clearSelectedObjects()

    local fetchRotation = obj.getRotation()
    fetchRotation.z = TA_Color == playerColor and 0 or 180 --get as commodities or tgs
    local yMod = 0.75 --place comms on top of eachother
    local nextPos = objPos
    nextPos.y = nextPos.y + 1

    --Get as many 3xTokens as able, then get singles
    local _3x = math.floor(commValue/3)
    local _1x = commValue % 3
    local _1xBag = getBag("x1 Commodities/Tradegoods")
    local _3xBag = getBag("x3 Commodities/Tradegoods")
    --print("Tokens: 3x[", _3x, "] 1x[", _1x, "]")

    local function waitTillLoad(obj)
      while(obj.spawning) do
        coroutine.yield(0)
      end

      coroutine.yield(0)
      coroutine.yield(0)
      coroutine.yield(0)
    end

    local function fluxPosition(position)
      local pos = {x = position.x, y = position.y, z = position.z}
      local fluxX = (math.random() * 0.07) + 0.0175
      local fluxZ = math.random() * 0.03
      pos.x = pos.x + fluxX
      pos.z = pos.z + fluxZ
      return pos
    end

    for i = 1, _3x, 1 do
      local nextObj = _3xBag.takeObject({
        position = fluxPosition(nextPos),
        rotation = fetchRotation,
        smooth = true,
        index = 1,
      })
      coroutine.yield(0)
      waitTillLoad(nextObj)
      nextObj.addToPlayerSelection(fetchingPlayer)
      nextPos.y = nextPos.y + yMod
      coroutine.yield(0)
      coroutine.yield(0)
    end

    for i = 1, _1x, 1 do
      local nextObj = _1xBag.takeObject({
        position = fluxPosition(nextPos),
        rotation = fetchRotation,
        smooth = true,
        index = 1,
      })
      coroutine.yield(0)
      waitTillLoad(nextObj)
      nextObj.addToPlayerSelection(fetchingPlayer)
      nextPos.y = nextPos.y + yMod
    end

    local t = Time.time
    while(Time.time - t < 3) do
      coroutine.yield(0)
    end

    if objRef == nil or fetchingPlayer == taColor then return end
    objRef.deal(1, taColor)
  end)

  --PullCommodities
  table.insert(_runningCommFetches, fetchCo)
  if not _coRunner then _coRunner = startLuaCoroutine(self, "runCoroutines") end
end

function runCoroutines()
  while(#_runningCommFetches > 0) do
    for i = #_runningCommFetches, 1, -1 do
      local running, result = coroutine.resume(_runningCommFetches[i])
      if not running then
        _runningCommFetches[i] = nil
        --print(result) --Uncomment to see any errors raised during execution
      end
    end
    coroutine.yield(0)
  end

  _coRunner = false
  return 1
end
--------------------------------------------------------------------------------

function verifyAllFactions()
    local errors = false
    for name, faction in pairs(_factionAttributes) do
        local success, errorMessage = _factionIsValid(_factionData[name])
        if not success then
            errors = errors or {}
            table.insert(errors, name .. ': ' .. errorMessage)
        end
    end
    if errors then
        error('verifyAllFactions ' .. table.concat(errors, ', '))
    end
    print('verifyAllFactions: success')
end

function _factionIsValid(faction)
  --
  local function _isValidGet(getter)
    assert(type(getter) == "table" and getter.func and type(getter.func) == "string")
    getter.guid = assert(getter.guid or getter.obj ~= nil and getter.obj.getGUID())
    return true
  end
  local function varIsGettable(var)
    local isGet = type(var) == "table" and var.GET
    if isGet then
      assert(var.default ~= nil, "You must define a default return value for getters")
      assert(var.func and type(var.func) == "string")
      var.guid = assert(var.guid or var.obj ~= nil and var.obj.getGUID())
    end
    return isGet
  end

    local name = faction.name
    if not name or type(name) ~= 'string' or string.len(name) == 0 then
        return false, 'faction.name must be a non-empty string'
    end

    local tokenName = faction.tokenName
    if not tokenName or type(tokenName) ~= 'string' or string.len(tokenName) == 0 then
        return false, 'faction.tokenName must be a non-empty string'
    end

    local frankenName = faction.frankenName
    if not frankenName or type(frankenName) ~= 'string' or string.len(frankenName) == 0 then
        return false, 'faction.frankenName must be a non-empty string'
    end

    local home = varIsGettable(faction.home) and faction.home.default or faction.home
    if not home or type(home) ~= 'number' then
        return false, 'faction.home must be a number'
    end

    local startingUnits = faction.startingUnits
    if not startingUnits or type(startingUnits) ~= 'table' then
        return false, 'faction.startingUnits must be a table'
    end

    local startingTech = faction.startingTech
    if not startingTech or type(startingTech) ~= 'table' then
        return false, 'faction.startingTech must be a table'
    end

    local flagship = varIsGettable(faction.flagship) and faction.flagship.default or faction.flagship
    if not flagship or type(flagship) ~= 'string' or string.len(flagship) == 0 then
        return false, 'faction.flagship must be a non-empty string'
    end

    local flagshipDescription = faction.flagshipDescription
    if not flagshipDescription or type(flagshipDescription) ~= 'string' or string.len(flagshipDescription) == 0 then
        return false, 'faction.flagshipDescription must be a non-empty string'
    end

    local abilities = varIsGettable(faction.abilities) and faction.abilities.default or faction.abilities
    if not abilities or type(abilities) ~= 'table' then
        return false, 'faction.abilities must be a table'
    end

    local units = varIsGettable(faction.units) and faction.units.default or faction.units
    if not units or type(units) ~= 'table' then
        return false, 'faction.units must be a table'
    end

    if faction.heroAbility then
      local heroAbility = varIsGettable(faction.heroAbility) and faction.heroAbility.default or faction.heroAbility
    end

    if faction.elimInstructions then
      local elim = faction.elimInstructions
      if type(elim) ~= "table" then return false, 'elimination instructions must be a table.' end
      local function _validateElim(data)
        if data.names then
          data.names = type(data.names) == "table" and data.names or {data.names}
        end
        if data.guids then
          data.guids = type(data.guids) == "table" and data.guids or {data.guids}
        end
        if data.GET and not _isValidGet(data.GET) then
          return false, 'Bad table format for .GET'
        end

        return true
      end

      if elim.ignore then
        if elim.ignore.ME then
          local isValid, reason = _validateElim(elim.ignore.ME)
          if not isValid then return false, "Invalid elimInstructions.ignore.ME: "..reason end
        end
        if elim.ignore.OTHERS then
          local isValid, reason = _validateElim(elim.ignore.OTHERS)
          if not isValid then return false, "Invalid elimInstructions.ignore.OTHERS: "..reason end
        end
      end
      if elim.include then
        if elim.include.ME then
          local isValid, reason = _validateElim(elim.include.ME)
          if not isValid then return false, "Invalid elimInstructions.include.ME: "..reason end
        end
        if elim.include.OTHERS then
          local isValid, reason = _validateElim(elim.include.OTHERS)
          if not isValid then return false, "Invalid elimInstructions.include.OTHERS: "..reason end
        end
      end
      if elim.DO and not _isValidGet(elim.DO) then
        return false, 'Bad table format for elimInstructions.DO'
      end
    end

    if faction.eliminationQuotes then
      faction.eliminationQuotes = type(eliminationQuotes) == "table" and faction.eliminationQuotes or {faction.eliminationQuotes}
      for _,each in ipairs(faction.eliminationQuotes) do
        if type(each) ~= "string" then return false, 'faction elimination quotes must be strings' end
      end
    end

    return true
end

-------------------------------------------------------------------------------
function _updateCommodityValues()
  COMMODITIES.update(true)
  for color,data in pairs(_colorToFaction) do
    data.commodities = COMMODITIES.mutate(data.name)
  end
end

function _maybeUpdateFactions()
    if not _update.time or (Time.time - _update.time) > _update.periodicUpdateSeconds then
        updateFactions()
    else
      --if we're not updating everything, then update each unpacked faction's field that is a getter, these may change more frequently
      updateGetValues()
    end
end

function updateFactions()
    _update.time = Time.time

    local factionLowerToFactionName = {}
    for factionName, _ in pairs(_factionAttributes) do
        factionLowerToFactionName[string.lower(factionName)] = factionName
    end

    local frankenSet = {}
    local flagshipSet = {}
    local abilitySet = {}
    local commanderSet = {}
    local heroSet = {}
    if _state.frankenEnabled then
        for _, faction in pairs(_factionAttributes) do
            frankenSet[faction.flagship] = true
            flagshipSet[faction.flagship] = true
            for _, ability in ipairs(faction.abilities) do
                frankenSet[ability] = true
                abilitySet[ability] = true
            end
            if faction.commander then
                frankenSet[faction.commander] = true
                commanderSet[faction.commander] = true
            end
            if faction.hero then
                frankenSet[faction.hero] = true
                heroSet[faction.hero] = true
            end
        end
    end

    -- Find command sheets (indexed by color), faction sheets (indexed by
    -- faction name), and command token bags (indexed by "token faction" name,
    -- which may differ slightly from the faction sheet faction name).
    local colorToCommandSheet = {}
    local colorToLeaderSheet = {}
    local factionSheetGuidToFactionSheet = {}
    local factionSheetGuidToFactionName = {}
    local guidToName = {}
    local guidToPosition = {}
    local commanderGuidToPosition = {}
    local heroGuidToPosition = {}
    local commodityTileGuidToFactionTokenName = {}
    for _, object in ipairs(getAllObjects()) do
        local name = object.getName()
        local guid = object.getGUID()

        -- "Command Sheet (COLOR)"
        local color = string.match(name, '^Command Sheet %((%a+)%)$')
        if color then
            colorToCommandSheet[color] = object
        end

        -- "Leader Sheet (COLOR)"
        local color = string.match(name, '^Leader Sheet %((%a+)%)$')
        if color then
            colorToLeaderSheet[color] = object
        end

        -- "FACTION Sheet" (only accept if FACTION in whitelist!)
        -- Replace name with "expected" case, sometimes "of" vs "Of" depending on object.
        local factionName = string.match(name, '^(.+) Sheet$')
        factionName = factionName and factionLowerToFactionName[string.lower(factionName)]
        if factionName then
            factionSheetGuidToFactionSheet[guid] = object
            factionSheetGuidToFactionName[guid] = factionName
        end

        -- Pick up any Franken abilities.
        if _state.frankenEnabled then
            if object.tag == 'Tile' and frankenSet[name] then
                guidToName[guid] = name
                guidToPosition[guid] = object.getPosition()
            end
            if (object.tag == 'Tile' or object.tag == 'Card') and commanderSet[name] then
                commanderGuidToPosition[guid] = object.getPosition()
            end
            if (object.tag == 'Tile' or object.tag == 'Card') and heroSet[name] then
                heroGuidToPosition[guid] = object.getPosition()
            end
            local tileFactionName = string.match(name, '^(.*) Commodities$')
            if tileFactionName then
                guidToName[guid] = name
                guidToPosition[guid] = object.getPosition()
                commodityTileGuidToFactionTokenName[guid] = tileFactionName
                -- do not attempt to get faction, that table is updated later
            end
        end
    end

    -- Given a key/object-value table, return a map from command sheet color
    -- to the key whose object is closest to the command sheet AND VICE VERSA.
    -- For example, consider a table with an empty seat that has a command sheet
    -- but no faction sheet.  In that case, that orphaned command sheet does
    -- have a closest faction sheet, but that faction sheet is closer to another.
    -- Likewise consider an extra faction sheet placed on the table for some
    -- reason.  That faction sheet has a closest command sheet, but that
    -- command sheet is closer to another.
    local function distanceSq(p1, p2)
        return (p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2
    end
    local function minKV(map, f)
        local bestF = false
        local bestK = false
        for k, v in pairs(map) do
            local thisF = f(v)
            if not bestF or thisF < bestF then
                bestF = thisF
                bestK = k
            end
        end
        return bestK, map[bestK]
    end
    local function colorToClosestKey(keyToObjectTable)
        local result = {}
        -- Assign each object to its closest command sheet.
        local colorToKeys = {}
        for key, object in pairs(keyToObjectTable) do
            local objectPosition = object.getPosition()
            local function distance(commandSheet)
                local commandSheetPosition = commandSheet.getPosition()
                return distanceSq(objectPosition, commandSheetPosition)
            end
            local color, _ = minKV(colorToCommandSheet, distance)
            if color then
                local entry = colorToKeys[color]
                if not entry then
                    entry = {}
                    colorToKeys[color] = entry
                end
                table.insert(entry, key)
            end
        end
        -- For each color, get the closest candidate object.
        for color, keys in pairs(colorToKeys) do
            local colorPosition = colorToCommandSheet[color].getPosition()
            local function distance(key)
                local objectPosition = keyToObjectTable[key].getPosition()
                return distanceSq(objectPosition, colorPosition)
            end
            local _, key = minKV(keys, distance)
            result[color] = key
        end
        return result
    end

    -- Map command sheet color to nearest faction, tokenFaction, and seated player.
    local colorToFactionSheetGuid = colorToClosestKey(factionSheetGuidToFactionSheet)

    _colorToFaction = {}
    _lowerTokenNameToFaction = {}
    for color, factionSheetGuid in pairs(colorToFactionSheetGuid) do
      _colorToFaction[color] = {}
        local factionName = factionSheetGuidToFactionName[factionSheetGuid]
        local attributes = {
            color = color,
            commandSheetGuid = colorToCommandSheet[color].getGUID(),
            factionSheetGuid = colorToFactionSheetGuid[color],
        }
        _factionData[factionName].color = attributes.color
        _factionData[factionName].commandSheetGuid = attributes.commandSheetGuid
        _factionData[factionName].factionSheetGuid = attributes.factionSheetGuid

        for k, v in pairs(_factionData[factionName]) do
            attributes[k] = _factionAttributes[factionName][k]
        end

        _colorToFaction[color] = attributes
        _lowerTokenNameToFaction[string.lower(attributes.name)] = attributes
        if attributes.tokenName then
            _lowerTokenNameToFaction[string.lower(attributes.tokenName)] = attributes
        end
        if attributes.frankenName then
            _lowerTokenNameToFaction[string.lower(attributes.frankenName)] = attributes
        end
        if attributes.shortName then
            _lowerTokenNameToFaction[string.lower(attributes.shortName)] = attributes
        end
    end

    -- Add any missing factions to token name map.
    for factionName, attributes in pairs(_factionData) do
        if not _lowerTokenNameToFaction[string.lower(attributes.tokenName)] then
            _lowerTokenNameToFaction[string.lower(attributes.name)] = attributes
            if attributes.tokenName then
                _lowerTokenNameToFaction[string.lower(attributes.tokenName)] = attributes
            end
            if attributes.frankenName then
                _lowerTokenNameToFaction[string.lower(attributes.frankenName)] = attributes
            end
            if attributes.shortName then
                _lowerTokenNameToFaction[string.lower(attributes.shortName)] = attributes
            end
        end
    end

    -- If franken is enabled, reset flagship, abilities, etc based on franken tiles.
    if _state.frankenEnabled then
        local function getLeader(color, guidToPosition)
            local leaderSheet = colorToLeaderSheet[color]
            if not leaderSheet then
                return nil
            end
            local p0 = leaderSheet.getPosition()
            local best = nil
            local bestDSq = false
            for guid, p1 in ipairs(guidToPosition) do
                local p1 = object.getPosition()
                local dSq = (p0.x - p1.x) ^ 2 + (p0.z - p1.z) ^ 2
                if (not bestDSq) or dSq < bestDSq then
                    best = guid
                    bestDSq = dSq
                end
            end
            local leaderObject = getObjectFromGUID(best)
            return leaderObject and leaderObject.getName() or nil
        end
        local guidToColor = _zoneHelper.zonesFromPositions(guidToPosition)
        for color, faction in pairs(_colorToFaction) do
            faction.flagship = '?'
            faction.abilities = {}
            faction.units = {}
            faction.commodities = false
            for guid, tileColor in pairs(guidToColor) do
                local name = guidToName[guid]
                if color == tileColor then
                    if flagshipSet[name] then
                        faction.flagship = name
                    elseif abilitySet[name] then
                        table.insert(faction.abilities, name)
                    elseif commodityTileGuidToFactionTokenName[guid] then
                        local tileFactionTokenName = commodityTileGuidToFactionTokenName[guid]
                        local tileFaction = fromTokenName(tileFactionTokenName)
                        faction.commodities = _factionAttributes[tileFaction.name].commodities
                    end
                end
            end
            -- Leaders.
            faction.commander = getLeader(color, commanderGuidToPosition)
            faction.hero = getLeader(color, heroGuidToPosition)
        end
    end
end

function updateGetValues()
  for eachColor, data in pairs(_colorToFaction or {}) do
    for k,v in pairs(_factionData[data.name] or {}) do
      --_factionAttributes is a proxy table.
        --It will return the correct, updated value for v (k may be a getter)
      local val = _factionAttributes[data.name].k
      data.k = type(val) == "table" and copyTable(val) or val
    end
  end
end

-------------------------------------------------------------------------------

local DEFAULT_TINT = {
    White = '8C8C8C',
    Blue = '0C98D7',
    Purple = '7500B7',
    Yellow = 'A5A300',
    Red = 'CB0000',
    Green = '007406',
    Orange = 'F3631C',
    Brown = '703A16',
    Pink = 'F46FCD',
    --Grey = '7F7F7F',
    --Black = '050505',
}

function tintTokens(params)
    _maybeUpdateFactions()

    -- No color means do all colors.
    if not params then
        for color, _ in pairs(_colorToFaction) do
            tintTokens({ color = color })
        end
        return
    end
    assert(type(params.color) == 'string')
    assert(not params.tint or type(params.tint) == 'string')

    local tintColor = assert(params.tint or DEFAULT_TINT[params.color], 'no tint color for "' .. params.color .. '"')
    assert(string.match(tintColor, '^%x%x%x%x%x%x$'), 'bad tint color "' .. tintColor .. '"')
    tintColor = Color.fromHex('#' .. tintColor .. 'ff')  -- RGBA

    local faction = _colorToFaction[params.color]
    if not faction then
        return
    end

    local tintSet = {
        [faction.tokenName .. ' Command Token'] = true,
        [faction.tokenName .. ' Owner Token'] = true,
        [faction.tokenName .. ' Command Tokens Bag'] = true,
        [faction.tokenName .. ' Owner Tokens Bag'] = true,
    }

    local function tintCommandTokensBag(bag)
        local p = bag.getPosition()
        local function takeCallback(object)
            object.setColorTint(tintColor)
            bag.putObject(object)
        end
        for i, entry in ipairs(bag.getObjects()) do
            bag.takeObject({
                guid = entry.guid,
                position = { x = p.x, y = p.y + 5 + i, z = p.z },
                callback_function = takeCallback
            })
        end
    end

    local function tintOwnerTokensBag(bag)
        local p = bag.getPosition()
        local function takeCallback(object)
            object.setColorTint(tintColor)
            bag.reset()
            bag.putObject(object)
        end
        bag.takeObject({
            position = { x = p.x, y = p.y + 5, z = p.z },
            callback_function = takeCallback
        })
    end

    for _, object in ipairs(getAllObjects()) do
        if tintSet[object.getName()] then
            object.setColorTint(tintColor)
            if object.tag == 'Bag' then
                tintCommandTokensBag(object)
            elseif object.tag == 'Infinite' then
                tintOwnerTokensBag(object)
            end
        end
    end
end

-------------------------------------------------------------------------------

local _animatingGuids = {}
function onObjectPickUp(_, pickedUpObject)
    assert(type(pickedUpObject) == 'userdata')

    _animatingGuids[pickedUpObject.getGUID()] = nil
end

function onObjectDestroy(dyingObject)
    local guid = dyingObject.getGUID()
    if guid and _animatingGuids[guid] then
        _animatingGuids[guid] = nil
    end
end


local _purgeBagGuid = nil
function getPurgeBag()
    local purgeBagObject = getObjectFromGUID(_purgeBagGuid)
    if purgeBagObject then
        return purgeBagObject
    end

    local purgeBagName = 'Purge Bag'
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Bag' and object.getName() == purgeBagName then
            _purgeBagGuid = object.getGUID()
            return object
        end
    end

    assert(false, 'Unable to locate bag with name "' .. purgeBagName .. '"')
end

local _purgeCardQueue = {}

function purgeCard(cardObject)
    assert(cardObject.tag == 'Card')

    local inHandGuidSet = _zoneHelper.inHand()
    assert(not inHandGuidSet[cardObject.getGUID()], 'Cannot purge cards that are in a player\'s hand.')

    local purgeBagObject = assert(getPurgeBag())

    --TODO: Maybe deck related stuff? Object deletion checks? Card locked stuff?

    purgeBagObject.putObject(cardObject)
end

function _heroCardCanBeUsed(cardObject, usingColor)
    assert(type(cardObject) == 'userdata' and type(usingColor) == 'string')

    if cardObject.tag ~= 'Card' then
        printToColor('Cannot use ' .. cardObject.getName() .. '. Hero abilities can only be used from cards.', usingColor)
        return false
    end

    if cardObject.is_face_down then
        printToColor('Cannot use ' .. cardObject.getName() .. '. Card is facedown; did you unlock it?', usingColor)
        return false
    end

    local inHandGuidSet = _zoneHelper.inHand()
    if inHandGuidSet[cardObject.getGUID()] then
        printToColor('Cannot use ' .. cardObject.getName() .. '. Hero cards cannot be used while in your hand.', usingColor)
        return false
    end

    local factionColor = false
    for color, faction in pairs(allFactions(false)) do
        if faction.hero == cardObject.getName() then
            factionColor = color
            break
        end
    end
    if not factionColor then
        printToColor('Cannot use ' .. cardObject.getName() .. '. No seated faction has this Hero.', usingColor)
        return false
    end

    if factionColor ~= usingColor and usingColor ~= 'Black' then
        printToColor('Cannot use ' .. cardObject.getName() .. '. ' .. usingColor .. ' cannot use ' .. factionColor .. '\'s Hero card.', usingColor)
        return false
    end

    -- Any other technical conditions that would prevent us from purging the card or executing the ability?
    -- Any other gameplay situations that should prevent the Hero card from being used?

    return true
end

function _purgeHeroCard(owningObject, clickingColor)
    if not _heroCardCanBeUsed(owningObject, clickingColor) then
        -- Function will print why card cannot be used
        return
    end

    purgeCard(owningObject)
end

--Ability Implementations-------------------------------------------------------

-- Hero
-- Faction: Federation of Sol
-- Card Name: Jace X, 4th Air Legion
-- Ability Name: Helio Command Array
-- Ability Text:
-- ACTION: Remove each of your command tokens from the game board
-- and return them to your reinforcements. Then, purge this card.
local function _jacexHeroAbility(owningObject, clickingColor)
    if not _heroCardCanBeUsed(owningObject, clickingColor) then
        -- Function will print why card cannot be used
        return
    end

    local factionTokenName = false
    for _, faction in pairs(allFactions(false)) do
        if faction.hero == owningObject.getName() then
            factionTokenName = faction.tokenName
            break
        end
    end

    assert(factionTokenName, 'Trying to invoke Jace X Hero Ability, but no faction with "Jace X, 4th Air Legion" is at the table.')

    _strategyCardHelper.returnCommandTokensForFaction(factionTokenName)

    if owningObject.tag == 'Card' then
        purgeCard(owningObject)
    end
end

local _procynHeroAbilityOwningObjectQueue = {}
function _procynHeroAbilityCoroutine()
    local owningObject = assert(table.remove(_procynHeroAbilityOwningObjectQueue))

    -- Purge card before any wait loops
    if owningObject.tag == 'Card' then
        purgeCard(owningObject)
    end

    -- Place frontier tokens on systems that need one
    _exploreHelper.placeFrontierTokens()

    -- Wait for frontier tokens to land before exploring them.
    local waitUntil = Time.time + 3
    while Time.time < waitUntil do
        coroutine.yield(0)
    end

    --Find faction owning this hero ability (and it's color)
    local factionTokenName = false
    local factionColor = false
    for color, faction in pairs(allFactions(false)) do
        if faction.hero == owningObject.getName() then
            factionTokenName = faction.tokenName
            factionColor = color
            break
        end
    end
    assert(factionTokenName and factionColor, 'Multiverse Shift: Placed Frontier Tokens, but cannot explore them with missing owning faction.')

    --Map frontier tokens to system they're sitting on
    local frontierTokens = _exploreHelper.getAllFrontierTokens()
    local frontierTokenGuidToPosition = {}
    for _, token in ipairs(frontierTokens) do
        frontierTokenGuidToPosition[token.getGUID()] = token.getPosition()
    end
    coroutine.yield(0)

    local frontierTokenGuidToSystem = _systemHelper.systemsFromPositions(frontierTokenGuidToPosition)
    coroutine.yield(0)

    --Find all units
    local allUnits = _unitHelper.getUnits()
    coroutine.yield(0)

    --Filter down to owning faction ships
    --NOTE: Can skip units lacking faction/color; they'll be alongside other units.
    local factionShipToPosition = {}
    for _, unit in ipairs(allUnits) do
        if unit.unitType ~= 'Infantry' and unit.unitType ~= 'Mech' and unit.unitType ~= 'Space Dock' and unit.unitType ~= 'PDS' then --ships only
            if (unit.factionTokenName and unit.factionTokenName == factionTokenName) or (unit.color and unit.color == factionColor) then
                factionShipToPosition[unit.guid] = unit.position
            end
        end
    end

    --Find each system containing owning faction ship
    local shipToSystem = _systemHelper.systemsFromPositions(factionShipToPosition)
    local systemsWithFactionShipsSet = {}
    for ship, system in pairs(shipToSystem) do
        if system then
            systemsWithFactionShipsSet[system.guid] = true
        end
    end
    coroutine.yield(0)

    --For each system containing a frontier token AND owning faction ship, highlight the system tile
    local explorableTokenGuidToSystemGuid = {}
    local systemsToExplore = false
    for tokenGuid, system in pairs(frontierTokenGuidToSystem) do
        if system and systemsWithFactionShipsSet[system.guid] then
            explorableTokenGuidToSystemGuid[tokenGuid] = system.guid
            systemsToExplore = true

            -- Blinking system tiles are tied to the frontier token, NOT the system tile object.
            _animatingGuids[tokenGuid] = true
        end
    end

    -- While there are still systems to explore, blink those system tiles with the player color (2 minute timeout)
    local timeout = Time.time + 120
    while Time.time < timeout and systemsToExplore do
        systemsToExplore = false
        for tokenGuid, systemGuid in pairs(explorableTokenGuidToSystemGuid) do
            -- See if token is still on table
            local systemObject = getObjectFromGUID(systemGuid)
            if systemObject and _animatingGuids[tokenGuid] and getObjectFromGUID(tokenGuid) then
                systemObject.highlightOn(factionColor, 1)
                systemsToExplore = true
            elseif not systemObject or not getObjectFromGUID(tokenGuid) then
                _animatingGuids[tokenGuid] = nil
            end
        end

        -- Wait 2 seconds before repeating (1 sec on, 1 sec off)
        local blinkWait = Time.time + 2
        while Time.time < blinkWait do
            coroutine.yield(0)
        end
    end

    -- Ensure we're not tracking frontier tokens anymore
    for tokenGuid, _ in pairs(explorableTokenGuidToSystemGuid) do
        _animatingGuids[tokenGuid] = nil
    end

    return 1
end

-- Hero
-- Faction: The Empyrean
-- Card Name: Conservator Procyon
-- Ability Name: Multiverse Shift
-- Ability Text:
-- ACTION: Place 1 frontier token in each system that does not contain any
-- planets and does not already have a frontier token. Then, explore each
-- frontier token that is in a system that contains 1 or more of your ships.
-- Then, purge this card.
local function _procynHeroAbility(owningObject, clickingColor) --Empyrean Hero
    if not _heroCardCanBeUsed(owningObject, clickingColor) then
        -- Function will print why card cannot be used
        return
    end

    table.insert(_procynHeroAbilityOwningObjectQueue, owningObject)
    startLuaCoroutine(self, '_procynHeroAbilityCoroutine')
end

local _carrionHeroAbilityOwningObjectQueue = {}
local _diceToBeRolled = {}
function _carrionHeroAbilityCoroutine()
    local owningObject = assert(table.remove(_carrionHeroAbilityOwningObjectQueue))
    if #_diceToBeRolled > 0 then
        printToAll('Remove previously devoured ships before re-using Dimensional Anchor.')
        return 1
    end

    --Find faction owning this hero ability (and it's color)
    local factionTokenName = false
    local factionColor = false
    for color, faction in pairs(allFactions(false)) do
        if faction.hero == owningObject.getName() then
            factionTokenName = faction.tokenName
            factionColor = color
            break
        end
    end
    assert(factionTokenName and factionColor, 'Dimensional Anchor: Trying to invoke Hero Ability, but no faction with "It Feeds on Carrion" is at the table.')

    --Find each dimensional tear token (Cabal and Nekro)
    local dimTokenToPosition = {}
    local anyDimensionalTears = false
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Tile' then
            local objname = object.getName()
            if objname == 'Tear Token (Cabal)' or objname == 'Tear Token (Nekro)' then
                dimTokenToPosition[object.getGUID()] = object.getPosition()
                anyDimensionalTears = true
            end
        end
    end
    coroutine.yield(0)

    if not anyDimensionalTears then
        printToAll('Dimensional Anchor: No Dimensional Tear tokens found on the table. Won\'t use Hero Ability.')
        return 1
    end

    --Find hex those tokens are on
    local dimensionalTearToHex = _systemHelper.hexesFromPositions(dimTokenToPosition)

    --Find set of hexes adjacent to above (including wormholes)
    local hexToNeighboringHexes = {}
    for _, hex in pairs(dimensionalTearToHex) do
        local directlyAdjacentHexes = _systemHelper.hexNeighborsWithHyperlanes(hex)
        local wormholeAdjacentHexes = _systemHelper.hexAdjacentWormholes({hex = hex, playerColor = factionColor})

        local neighboringHexSet = {}
        for _, adjHex in ipairs(directlyAdjacentHexes) do
            neighboringHexSet[adjHex] = true
        end
        for _, adjHex in ipairs(wormholeAdjacentHexes) do
            neighboringHexSet[adjHex] = true
        end

        local neighboringHexes = {}
        for adjHex, _ in pairs(neighboringHexSet) do
            table.insert(neighboringHexes, adjHex)
        end

        hexToNeighboringHexes[hex] = neighboringHexes

        coroutine.yield(0)
    end

    -- Get map of hex to system tile. Used to confirm a hex is actually placed on the table.
    -- (neighboring hexes can be computed from math, regardless of the presence of a system tile)
    local allHexesAsMap = {}
    for _, hex in pairs(dimensionalTearToHex) do
        allHexesAsMap[hex] = hex
        for _, adjHex in ipairs(hexToNeighboringHexes[hex]) do
            allHexesAsMap[adjHex] = adjHex
        end
    end

    local allHexesToPosition = _systemHelper.hexesToPosition(allHexesAsMap)
    local allHexesToSystemTiles = _systemHelper.systemsFromPositions(allHexesToPosition)
    coroutine.yield(0)

    --Find all units on those hexes
    local opponentShipToHex = {}
    local unitByGuid = {}
    local allUnits = _unitHelper.getUnits()
    for _, unit in ipairs(allUnits) do
        if unit.unitType ~= 'Infantry' and unit.unitType ~= 'Mech' and unit.unitType ~= 'Fighter' and unit.unitType ~= 'Space Dock' and unit.unitType ~= 'PDS' then --non-fighter ships only
            if (unit.factionTokenName and unit.factionTokenName ~= factionTokenName) or (unit.color and unit.color ~= factionColor) then
                opponentShipToHex[unit.guid] = unit.hex
                unitByGuid[unit.guid] = unit
            end
        end
    end

    local anchoredShipsCount = 0
    local systemToAnchoredShips = {}
    for shipGuid, hex in pairs(opponentShipToHex) do
        local system = allHexesToSystemTiles[hex]
        if system then
            local systemShips = systemToAnchoredShips[system]
            if not systemShips then
                systemShips = {}
                systemToAnchoredShips[system] = systemShips
            end

            table.insert(systemShips, shipGuid)
            anchoredShipsCount = anchoredShipsCount + 1
        end
    end

    if anchoredShipsCount == 0 then
        printToAll('Dimensional Anchor: No non-fighter ships adjacent to Dimensional Tear systems. Won\'t use Hero Ability.')
        return 1
    end

    -- Safe to commit to acting at this point, so purge the Hero card.
    if owningObject.tag == 'Card' then
        purgeCard(owningObject)
    end

    -- Function spawns dice for each ship, sets a dice cleanup on a 2 minute timeout,
    -- and prints a guide for the dice color for auditability.
    local function _prepareDice(systemToAnchoredShips)
        -- Data and methods for dice handling copied from multiroller.

        local dieType = "Die_10"
        local removalDelay = 5
        local radialOffset = 1.2
        local heightOffset = 5
        local dieSize = 1

        --Finds a position, rotated around the Y axis, using distance you want + angle
        --oPos is object pos, oRot=object rotation, distance = how far, angle = angle in degrees
        local function _findGlobalPosWithLocalDirection(spawn_object, angle)
            local object, distance = spawn_object, radialOffset * self.getScale().x
            local oPos, oRot = object.getPosition(), object.getRotation()
            local posX = oPos.x + math.sin( math.rad(angle+oRot.y) ) * distance
            local posY = oPos.y + heightOffset
            local posZ = oPos.z + math.cos( math.rad(angle+oRot.y) ) * distance
            return {x=posX, y=posY, z=posZ}
        end

        --Gets a random rotation vector
        local function _randomRotation()
            --Credit for this function goes to Revinor (forums)
            --Get 3 random numbers
            local u1 = math.random();
            local u2 = math.random();
            local u3 = math.random();
            --Convert them into quats to avoid gimbal lock
            local u1sqrt = math.sqrt(u1);
            local u1m1sqrt = math.sqrt(1-u1);
            local qx = u1m1sqrt *math.sin(2*math.pi*u2);
            local qy = u1m1sqrt *math.cos(2*math.pi*u2);
            local qz = u1sqrt *math.sin(2*math.pi*u3);
            local qw = u1sqrt *math.cos(2*math.pi*u3);
            --Apply rotation
            local ysqr = qy * qy;
            local t0 = -2.0 * (ysqr + qz * qz) + 1.0;
            local t1 = 2.0 * (qx * qy - qw * qz);
            local t2 = -2.0 * (qx * qz + qw * qy);
            local t3 = 2.0 * (qy * qz - qw * qx);
            local t4 = -2.0 * (qx * qx + ysqr) + 1.0;
            --Correct
            if t2 > 1.0 then t2 = 1.0 end
            if t2 < -1.0 then ts = -1.0 end
            --Convert back to X/Y/Z
            local xr = math.asin(t2);
            local yr = math.atan2(t3, t4);
            local zr = math.atan2(t1, t0);
            --Return result
            return {math.deg(xr),math.deg(yr),math.deg(zr)}
        end

        -- Use different color dice for manual auditability; copy from Multiroller
        local unitTypeToDiceColor = {
            ["Dreadnought"] = "Purple",
            ["Flagship"] = "Black",
            ["Destroyer"] = "Red",
            ["War Sun"] = "Orange",
            ["Carrier"] = "Blue",
            ["Fighter"] = "Teal",
            ["Infantry"] = "Green",
            ["Cruiser"] = "Brown",
            ["PDS"] = "Orange",
            ["Space Dock"] = "Yellow",
            ["Mech"] = "Pink"
        }

        local diceToShip = {}
        local unitTypesUsed = {}
        _diceToBeRolled = {}

        -- Spawn a die for each ship, around the system tile the ship is on.
        for system, ships in pairs(systemToAnchoredShips) do
            local shipCount = #ships
            local angleStep = (360 / shipCount)

            local systemObject = getObjectFromGUID(system.guid)

            for i, ship in ipairs(ships) do
                local shipAttrs = unitByGuid[ship]

                local dieObject = spawnObject({
                    type=dieType,
                    position = _findGlobalPosWithLocalDirection(systemObject, angleStep*(i-1)),
                    rotation = _randomRotation(), scale={dieSize,dieSize,dieSize},
                    callback_function = function(obj) --GUID is not available right away
                        diceToShip[obj.getGUID()] = ship
                        table.insert(_diceToBeRolled, obj.getGUID())
                     end,
                })
                dieObject.setLock(true)
                dieObject.setColorTint(stringColorToRGB(unitTypeToDiceColor[shipAttrs.unitType]))

                unitTypesUsed[shipAttrs.unitType] = true
            end
        end

        -- Print guide showing the dice color for each ship.
        printToAll('DICE COLOR GUIDE')
        for unitType, color in pairs(unitTypeToDiceColor) do
            if unitTypesUsed[unitType] then
                printToAll('* ' .. unitType .. ': ' .. color)
            end
        end

        -- Remove dice from board no matter what after 2 minutes
        local function destroyDice()
            for _, die in ipairs(_diceToBeRolled) do
                local dieObject = getObjectFromGUID(die)
                if dieObject then
                    destroyObject(dieObject)
                end
            end
            _diceToBeRolled = {}
        end
        Wait.time(destroyDice, 120)

        return diceToShip
    end

    -- For each system, do rolls. Track results, print them by system+unitType.
    -- eg. 'Bereg / Lirta IV: Cruiser has 1 capture (2#, 4, 9); Dreadnought has 0 captures (6).'
    local diceToShip = _prepareDice(systemToAnchoredShips)

    -- Wait for all dice to spawn and receive a GUID
    local diceToShipCount = 0
    while diceToShipCount < anchoredShipsCount do
        coroutine.yield(0)

        diceToShipCount = 0
        for die, _ in pairs(diceToShip) do
            diceToShipCount = diceToShipCount + 1
        end
    end

    -- Start rolling dice.
    -- Separate coroutine, so 'self' can animate hexes while the dice are being rolled.
    startLuaCoroutine(self, 'dimensionalanchor_rollDiceCoroutine')

    -- Function checks if dice are all still, and if they are maps their values to the ship they rolled for.
    -- If dice are NOT still, just return an object with "waitingOnResults = true"
    local function _processRollResults(diceToShip)
        -- Wait for all dice to be settled
        local waitingOnResults = false
        for die, _ in pairs(diceToShip) do
            local dieObject = getObjectFromGUID(die)
            if dieObject and not dieObject.resting then
                waitingOnResults = true
                break
            end
        end

        -- ALWAYS report a value even if dice aren't resting, in case of timeout.
        local shipToResult = {}
        for die, ship in pairs(diceToShip) do
            local dieObject = getObjectFromGUID(die)
            shipToResult[ship] = dieObject and dieObject.getValue() or 0
        end

        return { waitingOnResults = waitingOnResults, shipToResult = shipToResult }
    end

    -- For blinking hexes.
    -- blinkMode == 0: Set a highlight on hexes containing dimensional tear tokens
    -- blinkMode == 1: Set a highlight only on hexes adjacent to dimensional tear tokens
    -- blinkMode == 2: Do nothing (let highlights fade)
    local function _setHexBlinkMode(dimTearHexToNeighboringHexes, allHexesToSystemTiles, blinkMode, blinkDuration)
        if blinkMode > 1 then
            return
        end

        if blinkMode == 0 then
            for hex, _ in pairs(dimTearHexToNeighboringHexes) do
                local system = allHexesToSystemTiles[hex]
                if system and not system.hyperlane then
                    local systemObject = getObjectFromGUID(system.guid)
                    if systemObject then
                        systemObject.highlightOn(factionColor, blinkDuration)
                    end
                end
            end
        end

        if blinkMode == 1 then
            for _, adjHexes in pairs(dimTearHexToNeighboringHexes) do
                for _, hex in ipairs(adjHexes) do
                    local system = allHexesToSystemTiles[hex]
                    if system and not system.hyperlane then
                        local systemObject = getObjectFromGUID(system.guid)
                        if systemObject then
                            systemObject.highlightOn(factionColor, blinkDuration)
                        end
                    end
                end
            end
        end
    end

    -- Check for results,
    -- and trigger system tile highlighting until results are ready
    local rollResults = { waitingOnResults = true }
    local rollTimeout = Time.time + 10
    local rollMinimumWait = Time.time + 3
    local blinkMode = 2 -- 0 = dim tear hexes; 1 = adj hexes; 2 = no hexes
    local blinkTransitionTime = 0
    while (rollResults.waitingOnResults or Time.time < rollMinimumWait) and Time.time < rollTimeout do
        -- Animation 1: Alternating dimensional tear and adjacent hex blinking
        --blinkMode = (blinkMode + 1) % 3
        --blinkTransitionTime = Time.time + 0.25 + (blinkMode == 2 and 0.25 or 0)
        --_setHexBlinkMode(hexToNeighboringHexes, allHexesToSystemTiles, blinkMode, 0.5)

        -- Animation 2: Highlight all relevant hexes, then just the dimensional tear ones.
        -- Gives the impression of ships being sucked towards the dimensional tears
        blinkTransitionTime = Time.time + 1.5
        _setHexBlinkMode(hexToNeighboringHexes, allHexesToSystemTiles, 0, 1)
        _setHexBlinkMode(hexToNeighboringHexes, allHexesToSystemTiles, 1, 0.5)

        -- Animation 3: Highlight all on, then all off. Simplest visually. Probably best from a gameplay
        -- perspective and sticking to the "soul" of the physical game. But less cool, and less obvious why a
        -- a system is adjacent when it's a random wormhole token or something across the board.
        --blinkTransitionTime = Time.time + 2
        --_setHexBlinkMode(hexToNeighboringHexes, allHexesToSystemTiles, 0, 1)
        --_setHexBlinkMode(hexToNeighboringHexes, allHexesToSystemTiles, 1, 1)

        while blinkTransitionTime > Time.time do
            coroutine.yield(0)
        end

        rollResults = _processRollResults(diceToShip)
        coroutine.yield(0)
    end

    -- Get results
    local shipToResult = rollResults.shipToResult

    -- Print results
    for system, ships in pairs(systemToAnchoredShips) do
        local unitTypeToResultRolls = {}

        for _, ship in ipairs(ships) do
            local shipAttrs = assert(unitByGuid[ship])
            local descriptiveUnitType = shipAttrs.unitType
            if shipAttrs.factionTokenName then
                descriptiveUnitType = shipAttrs.factionTokenName .. '\'s ' .. descriptiveUnitType
            elseif shipAttrs.color then
                descriptiveUnitType = shipAttrs.color .. ' ' .. descriptiveUnitType
            end

            local resultsForType = unitTypeToResultRolls[descriptiveUnitType]
            if not resultsForType then
                resultsForType = {}
                unitTypeToResultRolls[descriptiveUnitType] = resultsForType
            end

            table.insert(resultsForType, assert(shipToResult[ship]))
        end

        printToAll('Results for ' .. system.string .. ':')
        for unitType, results in pairs(unitTypeToResultRolls) do
            local resultString = ''
            local first = true
            for _, result in ipairs(results) do
                if not first then
                    resultString  = resultString .. ', '
                end

                resultString = resultString .. result
                if result < 4 then
                    resultString = resultString .. '#'
                end

                first = false
            end

            printToAll('* ' .. unitType .. ': ' .. resultString)
        end
    end

    -- Create list of dying ships.
    -- Only includes ships whose roll was 1-3 (failing)
    local dyingShips = {}
    for ship, result in pairs(shipToResult) do
        if result < 4 then
            local shipObject = getObjectFromGUID(ship)
            if shipObject then
                table.insert(dyingShips, ship)
                _animatingGuids[ship] = true
            end
        end
    end

    -- Loop and highlight dead ships until they're removed from their hex.
    local anchoredUnitsUnmoved = true
    local anchoredUnitsTimeout = Time.time + 120
    while Time.time < anchoredUnitsTimeout and anchoredUnitsUnmoved do
        anchoredUnitsUnmoved = false

        local currentTileToDeathTile = {}
        local shipStateToPosition = {}

        for _, ship in ipairs(dyingShips) do
            if _animatingGuids[ship] then
                local shipObject = getObjectFromGUID(ship)
                if shipObject then
                    anchoredUnitsUnmoved = true
                    shipObject.highlightOn(factionColor, 0.75)
                else
                    _animatingGuids[ship] = nil
                end
            end
        end

        -- Wait 2 seconds before repeating (1 sec on, 1 sec off)
        local blinkWait = Time.time + 1.5
        while Time.time < blinkWait do
            coroutine.yield(0)
        end
    end

    -- Stop tracking all GUIDs from this animation
    for _, ship in ipairs(dyingShips) do
        _animatingGuids[ship] = nil
    end

    -- At this point, all dying ships have been handled. Destroy dice.
    for _, die in ipairs(_diceToBeRolled) do
        local dieObject = getObjectFromGUID(die)
        if dieObject then
            destroyObject(dieObject)
        end
    end
    _diceToBeRolled = {}

    return 1
end

function dimensionalanchor_rollDiceCoroutine()
    assert(_diceToBeRolled and type(_diceToBeRolled) == 'table')

    local waitToStart = Time.time + 1.5
    while Time.time < waitToStart do
        coroutine.yield(0)
    end

    for _, die in ipairs(_diceToBeRolled) do
        local dieObject = getObjectFromGUID(die)
        if dieObject then
            dieObject.setLock(false)
            dieObject.randomize()
            local rollDelay = Time.time + 0.25
            while Time.time < rollDelay do
                coroutine.yield(0)
            end
        end
    end

    return 1
end

-- Hero
-- Faction: The Vuil'raith Cabal
-- Card Name: It Feeds on Carrion
-- Ability Name: Dimensional Anchor
-- Ability Text:
-- ACTION: Each other player rolls a die for each of their non-fighter ships
-- that are in or adjacent to a system that contains a dimensional tear; on
-- a 1-3, capture that unit. If this causes a player's ground forces or fighters
-- to be removed, also capture those units. Then, purge this card.
local function _carrionHeroAbility(owningObject, clickingColor) --Vuil'raith Hero
    if not _heroCardCanBeUsed(owningObject, clickingColor) then
        -- Function will print why card cannot be used
        return
    end

    table.insert(_carrionHeroAbilityOwningObjectQueue, owningObject)
    startLuaCoroutine(self, '_carrionHeroAbilityCoroutine')
end

local function _replaceTitanSleeperToken(sleeperTokenObject, clickingColor, replacements)
    assert(type(sleeperTokenObject) == 'userdata' and type(clickingColor) == 'string' and type(replacements) == 'table')

    -- Can the clicking player replace the token?
    local canReplace = false
    local faction = fromColor(clickingColor) or {}
    for _, ability in ipairs(faction.abilities or {}) do
        if ability == 'Awaken' then
            canReplace = true
        end
    end
    if not canReplace then
        printToColor(clickingColor .. ' does not have the "Awaken" ability, ignoring replace', clickingColor, 'Red')
        return
    end

    printToAll('Replacing ' .. sleeperTokenObject.getName() .. ' with ' .. table.concat(replacements, ', '), 'Yellow')

    -- Find bags (set true to search for them, search replaces with the bag).
    local replacementNameToBagName = {}
    local bagNameToBag = {
        ['Titan Sleeper Tokens Bag'] = true,
        ['x1 Infantry Tokens Bag'] = true
    }
    for _, replacement in ipairs(replacements) do
        local bagName = clickingColor .. ' ' .. replacement
        replacementNameToBagName[replacement] = bagName
        bagNameToBag[bagName] = true
    end
    for _, object in ipairs(getAllObjects()) do
        local tag = object.tag
        local name = object.getName()
        if (tag == 'Bag' or tag == 'Infinite') and (bagNameToBag[name] == true) then
            bagNameToBag[name] = object
        end
    end

    -- Use infantry tokens if infanty bag is empty.
    if replacementNameToBagName['Infantry'] then
        local bagName = replacementNameToBagName['Infantry']
        local bag = bagNameToBag[bagName]
        if (not bag) or (bag == true) or (bag.getQuantity() == 0) then
            replacementNameToBagName['Infantry'] = 'x1 Infantry Tokens Bag'
        end
    end

    -- Verify unit availability.
    local takeFromBags = {}
    for i, replacement in ipairs(replacements) do
        local bagName = assert(replacementNameToBagName[replacement])
        local bag = bagNameToBag[bagName]
        if (not bag) or (bag == true) then
            printToAll('Warning: missing ' .. bagName .. ', aborting', 'Yellow')
            return
        elseif bag.tag == 'Bag' and bag.getQuantity() == 0 then
            printToAll('Warning: no ' .. replacement .. ' available, aborting', 'Yellow')
            return
        else
            table.insert(takeFromBags, bag)
        end
    end

    -- All units are available, proceed with replacment(s).
    for i, bag in ipairs(takeFromBags) do
        local p = sleeperTokenObject.getPosition()
        p.x = p.x + (i - 1) * 1.1
        p.y = p.y + 3
        bag.takeObject({
            position          = p,
            smooth            = true
        })
    end
    local sleeperTokensBag = assert(bagNameToBag['Titan Sleeper Tokens Bag'])
    sleeperTokensBag.putObject(sleeperTokenObject)
end

function _resolveImperiaElim(elimParams)
  assert(elimParams and type(elimParams) == "table" and elimParams.color)
  local function _getImperiaPlayer()
    for eachCol, faction in ipairs(_colorToFation) do
      for _,eachAbility in ipairs(faction.abilities or {}) do
        if eachAbility == "Imperia" then return eachCol end
      end
    end
    return false
  end
  local _imperiaPlayer = assert(_getImperiaPlayer(), "No unpacked faction has Imperia")
  local tokens = getStrategyTokens(_imperiaPlayer) or {}
  local _myToken = (_colorToFaction[_imperiaPlayer].tokenName .. " Command Token")

  if elimParams.color == _imperiaPlayer then
    printToAll("|~Returning Imperia command tokens...", "Yellow")
    --return other players' tokens to their reinforcements (assuming any Alliance or cammander cards are coppies; Players can handle them if need be)
    local _neededTokenBags = {}
    local _tokensToReturn = {}
    --get other players' tokens
    for _,eachToken in ipairs(tokens) do
      local oName = eachToken.getName()
      if oName ~= _myToken then
        local _bagName = (oName.."s Bag")
        _neededTokenBags[_bagName] = true
        _tokensToReturn[eachToken.guid] = {bag = _bagName, obj = eachToken, name = oName}
      end
    end
    if not next(_tokensToReturn) then printToAll("|   No tokens found", "Yellow") return end
    --find bags
    for _,eachObj in ipairs(getAllObjects()) do
      if eachObj.type == "Bag" then
        local oName = eachObj.getName()
        if _neededTokenBags[oName] then _neededTokenBags[oName] = eachObj end
      end
    end
    local _failedBags = {"|"}
    local _success = {"|"}
    --return objs
    for guid,eachToken in pairs(_tokensToReturn) do
      local bag = _neededTokenBags[eachToken.bag]
      if bag ~= nil then
        bag.putObject(eachToken.obj)
        table.insert(_success, eachToken.name)
      else
        table.insert(_failedBags, eachToken.bag)
      end
    end

    --log results
    _success[1] = "|    Found and returned "..#_success.." command tokens:\n"
    printToAll(table.concat(_success, " - "), "Yellow")
    if #_failedBags > 1 then
      _failedBags[1] = "!ERROR! Could not find bags:\n"
      printToAll(table.concat(_failedBags, " - "), "Red")
    end
    return
  else --tell the elimAutomator to ignore any of the elim'd player's command tokens and alliance notes in my play area
    local _imperiaComponents = {guids = {}, names = {}}--table of guids. Guid for each other players' token and the guid of that player's Alliance and commander card
    for _,eachToken in ipairs(tokens) do
      local oName = eachToken.getName()
      if oName ~= _myToken then
        local _faction = fromTokenName(oName)
        if _faction then
          table.insert(_imperiaComponents.guids, eachToken.getGUID())
          local _allianceName = (_faction.shortName or _faction.frankenName or "Nil").. " Alliance"
          table.insert(_imperiaComponents.names, _allianceName)
          table.insert(_imperiaComponents.names, _faction.commander or "NIL COMMANDER")
        end
      end
    end
    --find only named objects that are in MY play area (convert names to guids)
    for _,eachObj in ipairs(getAllObjects()) do
      local oName =  eachObj.getName()
      if _imperiaComponents.names[oName] and _zoneHelper.zoneFromPosition(eachObj.getPosition()) == _imperiaPlayer then
        table.insert(_imperiaComponents.guids, eachObj.getGUID())
      end
    end
    _imperiaComponents.names = nil --names converted to specific guids

    return _imperiaComponents
  end
end

--------------------------------------------------------------------------------

_heroNameSet = false
_hasContextMenuCardNameSet = false
function _hasContextMenuItems(object)
    if not _hasContextMenuCardNameSet then
        _heroNameSet = {}
        _hasContextMenuCardNameSet = {}
        for name, _ in pairs(_factionCardNameToAbilityFunc) do
            _hasContextMenuCardNameSet[name] = true
        end
        for _, faction in pairs(allFactions(true)) do
            if faction.hero then
                _heroNameSet[faction.hero] = true
                _hasContextMenuCardNameSet[faction.hero] = true
            end
        end
        for _,color in ipairs(Player.getColors()) do
          _hasContextMenuCardNameSet["Trade Agreement (" .. color .. ")"] = true
        end
    end

    local name = object.getName()
    if object.tag == 'Card' and _hasContextMenuCardNameSet[name] then
        return true
    elseif object.tag == 'Tile' and name == 'Titan Sleeper Token' then
        return true
    end
end

function _applyContextMenuItems(object)
    local name = object.getName()

    local factionCardAbilityFunc = _factionCardNameToAbilityFunc and _factionCardNameToAbilityFunc[name] or false
    if factionCardAbilityFunc then
        object.addContextMenuItem(factionCardAbilityFunc.name, function(clickingColor) factionCardAbilityFunc.method(object, clickingColor) end, false)
    end

    if name == 'Titan Sleeper Token' then
        object.addContextMenuItem('Replace PDS', function(clickingColor) _replaceTitanSleeperToken(object, clickingColor, {'PDS'}) end, false)
        object.addContextMenuItem('Replace Mech/Inf', function(clickingColor) _replaceTitanSleeperToken(object, clickingColor, {'Mech', 'Infantry'}) end, false)
    end

    if string.find(name, "Trade Agreement") then
      object.addContextMenuItem("Fetch Commodities", contextMenu_fetchCommodities)
    end

    -- Most heroes are manually handled, and even the automated ones could be manually handled.
    -- Offer a simple Purge option on all faction hero cards.
    if not _heroNameSet then
        _hasContextMenuItems(self) -- force build
    end
    if _heroNameSet[name] then
        object.addContextMenuItem("Purge", function(clickingColor) _purgeHeroCard(object, clickingColor) end, false)
    end
end

function onObjectSpawn(object)
    if object and _hasContextMenuItems(object) then
        _applyContextMenuItems(object)
    end
end

function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_FACTION_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    self.addContextMenuItem('Verify Factions', verifyAllFactions)
    self.addContextMenuItem('Report Factions', reportFactions)

    local function export()
        local input = allFactions(true)
        --local input = {_factionAttributes['The Arborec']}
        local result = {}
        for _, faction in pairs(input) do
            table.insert(result, _exportFaction(faction))
        end
        error('\n' .. JSON.encode(result))
    end
    self.addContextMenuItem('export', export)

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    _state = saveState and string.len(saveState) > 0 and JSON.decode(saveState) or _state

    --[[ Add faction names to attributes.
    for factionName, attributes in pairs(_factionAttributes) do
        attributes.name = factionName
    end--]]

    _factionCardNameToAbilityFunc = {}
    _factionCardNameToAbilityFunc['Jace X, 4th Air Legion'] = { name = 'Helio Cmd. Array', method = _jacexHeroAbility }
    _factionCardNameToAbilityFunc['Conservator Procyon'] = { name = 'Multiverse Shift', method = _procynHeroAbility }
    _factionCardNameToAbilityFunc['It Feeds on Carrion'] = { name = 'Dimensional Anchor', method = _carrionHeroAbility }

    local function delayedApplyContextMenuItems()
        for _, object in ipairs(getAllObjects()) do
            if _hasContextMenuItems(object) then
                _applyContextMenuItems(object)
            end
        end
    end
    Wait.frames(delayedApplyContextMenuItems, 7)
end

function onSave()
    return JSON.encode(_state)
end

function onFrankenEnabled(value)
    _state.frankenEnabled = value or false
    updateFactions()
end

function reportFactions()
    _maybeUpdateFactions()
    local message = { 'FactionHelper.reportFactions: Franken=' .. tostring(_state.frankenEnabled)}
    for _, color in ipairs(_zoneHelper.zones()) do
        local faction = _colorToFaction[color]
        if faction then
            local hex = Color.fromString(color):toHex()
            table.insert(message, table.concat({
                '[' .. hex .. ']' .. color,
                'name={' .. (faction.name or '-') .. '}',
                'flagship={' .. (faction.flagship or '-') .. '}',
                'abilities={' .. table.concat(faction.abilities or {}, ', ') .. '}',
                'units={' .. table.concat(faction.units or {}, ', ') .. '}',
                'commander={' .. (faction.commander or '-') .. '}',
                'hero={' .. (faction.hero or '-') .. '}',
                'commodities={' .. (faction.commodities or '-') .. '}',
                'promissoryNotes={' .. table.concat(faction.promissoryNotes or {}, ', ') .. '}',
            }, ' '))
        end
    end
    printToAll(table.concat(message, '\n'))
end

function printTable(table)
  if not table or type(table) ~= 'table' then print("Error: printTable() requires a table param.") return end

  local function typeToPrintable(input)
   if type(input) == 'boolean' then return input and "true" or "false" end
   if type(input) == 'userdata' then return "userData" end
   return input
  end

  for k,v in pairs(table) do
    local kString = typeToPrintable(k)
    if type(v) == 'table' then
      print("--" .. kString .. " table:")
      printTable(v)
    else
      print(kString .. ": " .. typeToPrintable(v))
    end
  end
end

function copyTable(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and copyTable(v) or v
        end
        t = copy
    end
    return t
end

-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)