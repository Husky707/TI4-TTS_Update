function getHelperClient(helperObjectName)
    local helperObject = Global.call('getHelper', helperObjectName)
    local function getCallWrapper(functionName)
        helperObject = helperObject == nil and Global.call('getHelper', helperObjectName) or helperObject
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _deckHelper = getHelperClient('TI4_DECK_HELPER')
local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _stratHelper = getHelperClient('TI4_STRATEGY_CARD_HELPER')
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')
local Events = getHelperClient('TI4_EVENT_HELPER')
local SecretMat = getHelperClient('Secrets Mat')
local AgendaMat = getHelperClient('Agendas/Laws Mat')

local Coru = {
 _coroutines = {},
 _coRunner = false,
 _coQueue = {},
 _coKillQueue = {},
 step = {
   ["running"] = function() end,
   ["normal"] = function() end,
   ["suspended"] = function(eachCo, callbackData)
     local status, result = coroutine.resume(eachCo)
     if not status then
       print("Coroutine error: ", result)
       if callbackData and callbackData.callback then callbackData.callback(result) end
       return -1
     else
       if callbackData and callbackData.yieldback then callbackData.yieldback(result) end
     end
   end,
   ["dead"] = function(eachCo, callbackData)
     if callbackData and callbackData.callback then callbackData.callback(1) end
     return -1
   end,
   ["catch"] = function(eachCo, callbackData, badState)
     print("Caught a bad coru state: ", badState)
     if callbackData and callbackData.callback then callbackData.callback(-1) end
     return -1
    end
 },
}

local _elimInProgress = false
local _eliminated = {}--indexed by color [keys] = true or "Resolved" if also cleaned up
local Tokens = {
  identifier = "ElimToken", -- searched from obj.getGMNotes() not by obj.getName()
  scale = {x= 2.20, y = 2.20, z = 2.20},
  activeScale = {x = 4, y = 2.2, z = 4},
  assignments = {},--[tokenGUID] = color
  catchNextSpawn = false,
  existingSet = {},--[tokenGUID] = objRef

  --find the original obj in bag
  sourceContainer = "Tools and Helpers",
  rootGUID = "eb196e",--Temp
}

local Elim = {
  warningMsg = {"WARNING: You are about to drastically alter the board state; the ",
                " player's components will be returned in accordance with the player elimination rules. Proceed?"},
  --[[
  target = elimPlayer,
  colors = zoneColors,
  factions = unpackedFactions,
--]]}

--Public getters----------------------------------------------------------------
--!querying these functions during game load from a save will likely yeild no results, wait a frame for this script to update

function isPlayerEliminated(playerColor)
  return _eliminated[playerColor]
end

--returns: {table} of eliminated player colors indexed by [color] keys = true
function getEliminatedPlayers()
  return copyTable(_eliminated)
end

------------------------------
function declarePlayerEliminated(playerColor, tokenObj)
  if _eliminated[playerColor] then return end
  _eliminated[playerColor] = true

  local faction = assert(_factionHelper.fromColor(playerColor))
  Tokens.markElimination(playerColor, faction, tokenObj)

  broadcastToAll('The '..playerColor..' player has been eliminated!', "Red")
  if faction.eliminationQuotes then
    local quotes = type(faction.eliminationQuotes) == "table" and faction.eliminationQuotes or {faction.eliminationQuotes}
    local quote = quotes[math.random(1, #quotes)]
    safePrint("ALL", quote, playerColor)
  end
  Events.invoke({event = "playerEliminated", params = {color = playerColor, factionName = faction.name}})
end

function resolvePlayerElimination(color, tokenObj)
  if _elimInProgress then printToAll("Cannot resolve more than one elimination at a time, please wait.", color, "Red") return end
  if not _eliminated[color] then
    declarePlayerEliminated(color, tokenObj)
  end
  if _eliminated[color] == "Resolved" then return end
  _eliminated[color] = "Resolved"

  local faction = assert(_factionHelper.fromColor(color))
  Tokens.markElimination(color, faction, tokenObj)
  Elim.Resolve(color)
end

-------------------------------------------------------------------------------
function _searchForEliminations()
  _eliminated = {}
  Tokens.assignments = {}
  Tokens.existingSet = {}
  for _,eachObj in ipairs(getAllObjects()) do
    if eachObj.getGMNotes() == Tokens.identifier then
      local guid = eachObj.getGUID()
      Tokens.existingSet[guid] = true
      local target = _zoneHelper.zoneFromPosition(eachObj.getPosition())
      if target then
        _eliminated[target] = "Resolved"
        --flagging as resolved for now. This will prevent automation of cleanup, but should be fine as this only fires on load
        --Could fix by detecting if faction components have been packed, but not implementing now
        Tokens.assignments[guid] = target
        Tokens.assignments[target] = guid
      end
    end
  end
end

Tokens.markElimination = function(color, faction, token)
  if Tokens.assignments[color] then return end
  faction = assert(faction or _factionHelper.fromColor(color))

  local function tryGetPosition()
    local sheet = getObjectFromGUID(faction.factionSheetGuid)
    local _rotation = sheet.getRotation()
    local _pos = sheet.getPosition()
    _pos.y = _pos.y + 0.01
    _rotation.y = _rotation.y + 15
    return _pos, _rotation
  end
  local success, position, rotation = pcall(tryGetPosition)

  local _isInPosition = false
  local function findAToken()
    local copyAssigned = false
    --find an unassigned token
    for eachGUID,eachObj in pairs(Tokens.existingSet or {}) do
      copyAssigned = eachGUID
      if not Tokens.assignments[eachGUID] then
        return eachObj
      end
    end

    local function onSpawn(clone)
      local newGuid = clone.getGUID()
      ignoreDeletedItem(newGuid)
      clone.setLock(true)
      clone.setScale(Tokens.activeScale)
    end

    --else find and copy an assigned token
    if copyAssigned then
      local obj = getObjectFromGUID(copyAssigned)
      local spawnData = {
        data = obj.getData(),
        position = position,
        rotation = rotation,
        scale = Tokens.activeScale,
        callback_function = onSpawn
      }
      Tokens.catchNextSpawn = true
      local clone = spawnObjectData(spawnData)
      _isInPosition = true
      return clone
    end
    --else find from toolbag
    for _,eachObj in ipairs(getAllObjects()) do
      if eachObj.getName() == Tokens.sourceContainer then
        Tokens.catchNextSpawn = true
        _isInPosition = true
        local foundToken = eachObj.takeObject({
          position          = position,
          rotation          = rotation,
          callback_function = onSpawn,
          smooth            = false,
          guid              = Tokens.rootGUID,
          top               = false,
        })
        return foundToken
      end
    end
    return false
  end
  token = token or findAToken
  if not token then return end

  local guid = token.getGUID()
  Tokens.assignments[guid] = color
  Tokens.assignments[color] = guid
  token.clearContextMenu()
  if _eliminated[color] ~= "Resolved" then Tokens.setContextMenu("Assigned", token) end
  token.setLock(true)
  if not _isInPosition and position and rotation then
    token.setScale(Tokens.activeScale)
    token.setPositionSmooth(position, false, true)
    token.setRotationSmooth(rotation)
  end
end

Tokens.setContextMenu = function(contextMode, obj)
  local function setAssigned()
    obj.addContextMenuItem("Resolve Elimination", _contextResolveElimination)
  end

  local function setInZone()
    obj.addContextMenuItem("Declare Elimination", _contextDeclarationElimination)
    obj.addContextMenuItem("Resolve Elimination", _contextDeclareAndResolve)
  end

  local switch = {
    ["Assigned"] = setAssigned,
    ["InZone"] = setInZone,
    ["catch"] = function() error("Caught typo in Tokens.setContextMenu >"..contextMode.."<") end
  }
  local try = switch[contextMode] and contextMode or "catch"
  switch[try]()
end

--Token manipulation events-----------------------------------------------------

--Inform players of how the token works
local _infoCooldown = false
function onObjectDrop(player_color, obj)
  if obj.getGMNotes() ~= Tokens.identifier then return end

  local guid = obj.getGUID()
  if Tokens.assignments[guid] then return end
  if not obj.is_face_down then obj.flip() end

  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if not zone then
    obj.clearContextMenu()
    if not _infoCooldown or Time.time - _infoCooldown > 4 then
      _infoCooldown = Time.time
      printToAll("To declare an elimination, place the elimination token in a player's play area and flip it.\nThen to automate that elimination, right-click the token and select [Resolve].", "White")
    end
  elseif not Tokens.assignments[zone] then
    printToAll("Flip the token to declare the "..zone.." player eliminated.", "Orange")
    Tokens.setContextMenu("InZone", obj)
  end
end

--Manage pick-up of assigned tokens
function onObjectPickUp(player_color, obj)
  local guid = obj.getGUID()
  if not Tokens.assignments[guid] then return end

  local spawnData = {
    data = obj.getData(),
    position = obj.getPosition(),
    rotation = obj.getRotation(),
    scale = Tokens.activeScale,
  }
  Tokens.catchNextSpawn = true
  local clone = spawnObjectData(spawnData)
  local assignedColor = Tokens.assignments[guid]
  local newGuid = clone.getGUID()
  clone.setLock(true)
  ignoreDeletedItem(newGuid)
  Tokens.assignments[newGuid] = assignedColor
  Tokens.assignments[assignedColor] = newGuid
  Tokens.assignments[guid] = nil
  obj.setScale(Tokens.scale)
  obj.clearContextMenu()
  Tokens.setContextMenu("Assigned", clone)
end

--Flip new tokens to show Flip instructions
function onObjectSpawn(obj)
  if obj.getGMNotes() ~= Tokens.identifier then return end
  Tokens.existingSet[obj.getGUID()] = obj
  if Tokens.catchNextSpawn then Tokens.catchNextSpawn = false return end

  if not obj.is_face_down then obj.flip() end
end

--Resolve elimination flip
function onObjectRotate(obj, spin, flip, player_color, old_spin, old_flip)
  if flip == old_flip or flip ~= 0 then return end --only interested in flips and flips to face-up
  if obj.getGMNotes() ~= Tokens.identifier then return end

  local guid = obj.getGUID()
  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if zone and not Tokens.assignments[zone] then
    declarePlayerEliminated(zone, obj)
    --local msg = {"Would you also like the automator to resolve this elimination?\n\n", Elim.warningMsg[1], zone, Elim.warningMsg[2]}
    Player[player_color].showConfirmDialog("Would you also like the automator to resolve this elimination?", function() resolvePlayerElimination(zone, obj) end)
  end
end

--prevent the flipping of engaged elim tokens
function onPlayerAction(player, action, targets)
  if action ~= Player.Action.FlipOver then return end
  for _,each in ipairs(targets or {}) do
    --Dont flip engaged tokens
    if Tokens.assignments[each.getGUID()] then return false end

    if Tokens.identifier == each.getGMNotes() then
      local zone = _zoneHelper.zoneFromPosition(each.getPosition())

      --Dont flip tokens that are not in a play area
      if not zone then return false end
      if _elimInProgress then printToColor("Please wait, an elimination is being resolved.", player.color, "Red") return end

      --Dont flip tokens in an eliminated player's play area
      if Tokens.assignments[zone] then
        printToAll("The "..zone.." player is already eliminated.", "Yellow")
        return false
      end
    end
  end
end

function onObjectDestroy(dying_object)
  Tokens.existingSet[dying_object.getGUID()] = nil
end

--Context Menu Funcs------------------------------------------------------------
function _contextResolveElimination(color, position, obj)
  if _elimInProgress then printToColor("Please wait, an elimination is being resolved.", color, "Red") return end
  assert(obj.getGMNotes() == Tokens.identifier)
  Player[color].clearSelectedObjects()
  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if not zone then
    printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
    return
  end

  local function onConfirmed()
    --re-fetch zone in case another player moved it while menu is open
    local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
    if not zone then
      printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
      return
    end

    obj.clearContextMenu()
    resolvePlayerElimination(zone, obj)
  end
  Player[color].showConfirmDialog(Elim.warningMsg[1]..zone..Elim.warningMsg[2], onConfirmed)
end

function _contextDeclarationElimination(color, position, obj)
  if _elimInProgress then printToColor("Please wait, an elimination is being resolved.", color, "Red") return end
  assert(obj.getGMNotes() == Tokens.identifier)
  Player[color].clearSelectedObjects()
  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if not zone then
    printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
    return
  end

  declarePlayerEliminated(zone, obj)
end

function _contextDeclareAndResolve(color, position, obj)
  if _elimInProgress then printToColor("Please wait, an elimination is being resolved.", color, "Red") return end
  assert(obj.getGMNotes() == Tokens.identifier)
  Player[color].clearSelectedObjects()
  local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
  if not zone then
    printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
    return
  end

  local function onConfirmed()
    --re-fetch zone in case another player moved it while menu is open
    local zone = _zoneHelper.zoneFromPosition(obj.getPosition())
    if not zone then
      printToColor("The Elimination Token must be in a player's zone.", color, "Yellow")
      return
    end

    obj.clearContextMenu()
    declarePlayerEliminated(zone, obj)
    resolvePlayerElimination(zone, obj)
  end
  Player[color].showConfirmDialog(Elim.warningMsg[1]..zone..Elim.warningMsg[2], onConfirmed)
end

--Elimination Automation--------------------------------------------------------
Elim.getHands = function()
  local result = {}
  for _, player in ipairs(Player.getPlayers()) do
      local handCount = player.getHandCount()
      for i = 1, handCount do
          for _, object in ipairs(player.getHandObjects(i)) do
              result[object.guid] = player.color
          end
      end
  end
  return result
end

Elim.Resolve = function(elimPlayer)
  if _elimInProgress then return end
  assert(elimPlayer and type(elimPlayer) == "string", (elimPlayer or "nil").. " is not a valid player that can be eliminated.")

  safePrint("ALL","=-_________________________-=", "Yellow")
  safeBroadcast("ALL","|        Resolving Elimination...       |", elimPlayer)

  Elim.target = assert(elimPlayer)
  --Elim.targetZone = _zoneHelper.zoneAttributes(elimPlayer) --assert(Elim.targetZone, "The "..elimPlayer.." does not have a zone.")
  Elim.targetZone = assert(copyTable(_zoneHelper.zoneAttributes(elimPlayer)), "The "..elimPlayer.." does not have a zone.")
  Elim.colors = _zoneHelper.zones()
  Elim.factions = _factionHelper.allFactions() or {}
  Elim.commandTokens = {}
  Elim.controlTokens = {}--{{guid, obj},...}--elim player's only
  Elim.units = {}
  Elim.proms = {}
  Elim.strats = {}
  Elim.misc = {}
  Elim.containers = {}
  Elim.speakerToken = {}
  Elim.secrets = {}
  Elim.secretsMat = {}
  Elim.agendas = {}

  _elimInProgress = Elim.target

  --Step 1. Gather the names of *all objects that we will need to find
    --Names are stored as [keys] in their respective tables

  --[[faction.elimInstructions = {
    DO = {guid = self.getGUID(), func = "doFuncName"},--params: {color = eliminatedColor} --no return, just do what u need to do
    ignore = {
      ME = {
        names = {}, --"string" or table of {"strings"}. Objects with these names will not be returned
        guids = {}, --"guid" or table of {"guids"}. Objects with these guids will not be returned
        GET = {guid = self.getGUID(), func = "getFuncName"},--params:{color}, return: {names = {}, guids = {}}
      },
      OTHERS = {}
    },
    include = {
      ME = {},
      OTHERS = {}
    }
  }--]]
  local _factionInstructions = {names = {}, guids = {}}--name and guid tables have [key] = bool where true == include, false == exclude
  --gather faction specific elim instructions
  for fCol,eachFaction in pairs(Elim.factions) do
    local data = eachFaction.elimInstructions or false
    if data then
      if data.ignore then --get ignores
        if Elim.target == fCol then --Get .ME vals
          if data.ignore.ME then
            for _,each in ipairs(data.ignore.ME.names or {}) do
              _factionInstructions.names[each] = false
            end
            for _,each in ipairs(data.ignore.ME.guids or {}) do
              _factionInstructions.guids[each] = false
            end
            local gets = data.ignore.ME.GET and tryCall(data.ignore.ME.GET, {color = Elim.target}) or {}
            if type(gets) == "table" then
              for _,each in ipairs(gets.names or {}) do
                _factionInstructions.names[each] = false
              end
              for _,each in ipairs(gets.guids or {}) do
                _factionInstructions.guids[each] = false
              end
            end
          end
        elseif data.ignore.OTHERS then --get .OTHERS vals
          for _,each in ipairs(data.ignore.OTHERS.names or {}) do
            _factionInstructions.names[each] = false
          end
          for _,each in ipairs(data.ignore.OTHERS.guids or {}) do
            _factionInstructions.guids[each] = false
          end
          local gets = data.ignore.OTHERS.GET and tryCall(data.ignore.OTHERS.GET, {color = Elim.target}) or {}
          if type(gets) == "table" then
            for _,each in ipairs(gets.names or {}) do
              _factionInstructions.names[each] = false
            end
            for _,each in ipairs(gets.guids or {}) do
              _factionInstructions.guids[each] = false
            end
          end
        end
      end
      --get includes (will override matching ignore [keys])
      if data.include then
        if Elim.target == fCol then --Get .ME vals
          if data.include.ME then
            for _,each in ipairs(data.include.ME.names or {}) do
              _factionInstructions.names[each] = true
            end
            for _,each in ipairs(data.include.ME.guids or {}) do
              _factionInstructions.guids[each] = true
            end
            local gets = data.include.ME.GET and tryCall(data.include.ME.GET) or {}
            if type(gets) == "table" then
              for _,each in ipairs(gets.names or {}) do
                _factionInstructions.names[each] = true
              end
              for _,each in ipairs(gets.guids or {}) do
                _factionInstructions.guids[each] = true
              end
            end
          end
        elseif data.include.OTHERS then --get .OTHERS vals
          for _,each in ipairs(data.include.OTHERS.names or {}) do
            _factionInstructions.names[each] = true
          end
          for _,each in ipairs(data.include.OTHERS.guids or {}) do
            _factionInstructions.guids[each] = true
          end
          local gets = data.include.OTHERS.GET and tryCall(data.include.OTHERS.GET) or {}
          if type(gets) == "table" then
            for _,each in ipairs(gets.names or {}) do
              _factionInstructions.names[each] = true
            end
            for _,each in ipairs(gets.guids or {}) do
              _factionInstructions.guids[each] = true
            end
          end
        end
      end
    end
  end

  local containers = {["x3 Fighter Tokens Bag"] = "x3Fighters", ["x1 Fighter Tokens Bag"] = "x1Fighters", [("Directionaliser ("..Elim.target..")")] = "Directionaliser"}
  local units = {}
  local proms = {}
  --build objectName sets that include a player color: [name] = color
  for _,color in ipairs(Elim.colors) do
    proms["Support for the Throne ("..color..")"] = color
    proms["Trade Agreement ("..color..")"] = color
    proms["Political Secret ("..color..")"] = color
    proms["Ceasefire ("..color..")"] = color
    proms["Alliance ("..color..")"] = color
    units[color .. ' Infantry'] = color
    units[color .. ' Fighter'] = color
    units[color .. ' Destroyer'] = color
    units[color .. ' Carrier'] = color
    units[color .. ' Cruiser'] = color
    units[color .. ' Dreadnought'] = color
    units[color .. ' War Sun'] = color
    units[color .. ' Space Dock'] = color
    units[color .. ' PDS'] = color
    units[color .. ' Mech'] = color
    if Elim.factions[color] then
      units[Elim.factions[color].flagship] = color
      local allyName = Elim.factions[color].shortName or Elim.factions[color].frankenName
      proms[(allyName .. " Alliance")] = color
      for _,eachNote in ipairs(Elim.factions[color].promissoryNotes or {}) do
        proms[eachNote] = color
      end
    end
  end

  --local controlTokens = false --was going to find agendas on the mat that only have elim player's controlTokens, but decided against it
  local commandTokens = {[Elim.target.." Command Token"] = true}
  containers[Elim.target.." Command Tokens Bag"] = "commandTokens"
  if Elim.factions[Elim.target] then
    commandTokens[Elim.factions[Elim.target].tokenName .. " Command Token"] = true
    containers[Elim.factions[Elim.target].tokenName .. " Command Tokens Bag"] = "commandTokens"
    --controlTokens[Elim.factions[Elim.target].tokenName .. " Owner Token"] = true
    --containers[Elim.factions[Elim.target].tokenName .. " Owner Tokens Bag"] = "controlTokens"
  end
  local strats = _stratHelper.getStrategyCards()
  for _,each in pairs(strats or {}) do each = true end --cast to boolean

  local _sList = _deckHelper.getCardsWithSource({deckName = "Secret Objectives"}) or {}
  local secrets = {}
  for k,v in ipairs(_sList) do
    secrets[v] = true
  end
  local _aList = _deckHelper.getCardsWithSource({deckName = "Agenda"}) or {}
  local agendas = {}
  for k,v in ipairs(_aList) do
    agendas[v] = true
  end

  --Step 2. Search the table for objects of interest and save the objReference
    --Generally saved in a list as,{name = "", guid = "", obj = objRef, color = colorOwner}

  local function categorizeObj(name, guid, obj)
    if _factionInstructions.names[name] == false or _factionInstructions.guids[guid] == false then return end --explicitly compare to false, these are excluded objs
    --Handle objects by expected names
    if proms[name] then
      table.insert(Elim.proms, {name = name, guid = guid, obj = obj, color = proms[name]})
      return
    elseif containers[name] then
      Elim.containers[containers[name]] = obj
      return
    elseif units[name] then --Elim.units[guid] = {name = name, obj = obj}
      table.insert(Elim.units, {name = name, guid = guid, obj = obj, color = units[name]})
      return
    elseif commandTokens[name] then --Elim.commandTokens[guid] = obj return
      table.insert(Elim.commandTokens, {name = name, guid = guid, obj = obj})
      return
    --[[elseif controlTokens == name then --decided not to track agenda ownership bassed soley on if it has a control token on it.
      table.insert(Elim.controlTokens, {name = name, guid = guid, obj = obj})
      return--]]
    elseif strats[name] then
      local isInZone = _zoneHelper.zoneFromPosition(obj.getPosition())
      if isInZone == Elim.target then table.insert(Elim.strats, {name = name, guid = guid, obj = obj}) end--Elim.strats[guid] = obj end
      return
    elseif agendas[name] then
      table.insert(Elim.agendas, {name = name, guid = guid, obj = obj})
      return
    elseif secrets[name] then
      table.insert(Elim.secrets, {name = name, guid = guid, obj = obj})
      return
    elseif name == "Speaker Token" and _boundingBoxContains(Elim.targetZone.boundingBox, obj.getPosition())then
      Elim.speakerToken = {guid = guid, obj = obj}
      return
    elseif _factionInstructions.names[name] or _factionInstructions.guids[guid] then --uncategorized include
      table.insert(Elim.misc, {name = name, guid = guid, obj = obj})
      return
    end
    --handle unknown object bassed on location
    --hand set
    --zone set
    local oPos = obj.getPosition()
    if not _boundingBoxContains(Elim.targetZone.boundingBox, oPos) then return end
    --handle in target player's zone
  end
  for _,eachObj in ipairs(getAllObjects()) do
    local oName = eachObj.getName()
    local oGuid = eachObj.getGUID()
    categorizeObj(oName, oGuid, eachObj)
  end

  --Step 3. In a coroutine, resolve the return of found objects

  local coru = coroutine.create(function()
    --run faction specific DO actions
    for fCol,eachFaction in pairs(Elim.factions or {}) do
      local instructs = eachFaction.elimInstructions or false
      if instructs and instructs.DO then
        tryCall(instructs.DO, {color = Elim.target})
        coroutine.yield(0)
        coroutine.yield(0)
      end
    end

    local success, err = pcall(Elim.returnUnits)
    if not success then print(err) end
    coroutine.yield(0)

    success, err = pcall(Elim.returnCommandTokens)
    if not success then print(err) end
    coroutine.yield(0)

    --Move Speaker token left
    success, err = pcall(Elim.shiftSpeaker)
    if not success then print(err) end
    coroutine.yield(0)

    success, err = pcall(Elim.returnProms)
    if not success then print(err) end
    coroutine.yield(0)

    --Others reclaim their own proms from elim'd player
    success, err = pcall(Elim.reclaimProms)
    if not success then print(err) end
    coroutine.yield(0)

    success, err = pcall(Elim.returnStrats)
    if not success then print(err) end
    coroutine.yield(0)

    --Return secrets (even scored ones)
    success, err = pcall(Elim.discardSecrets)
    if not success then print(err) end
    coroutine.yield(0)

    --Discard agendas
    success, err = pcall(Elim.discardAgendas)
    if not success then print(err) end
    coroutine.yield(0)

    --Discard action cards
    success, err = pcall(Elim.discardActions)
    if not success then print(err) end
    coroutine.yield(0)

    --Handle faction specific MISC items
    success, err = pcall(Elim.returnMisc)
    if not success then print(err) end
    coroutine.yield(0)

    Events.invokeAsync({event = "resolvePlayerEliminated", params = {color = Elim.target}})
    coroutine.yield(0)

    safePrint("ALL", "|        Elimination Resolved         |", "Teal")
    _elimInProgress = false
    return 1
  end)
  Coru.run(coru)
end

--returns elim player's proms
Elim.returnProms = function()
  safePrint("ALL", "|\n|~Returning Promissory Notes...", "Yellow")
  coroutine.yield(0)
  local _printNotes = {["Grey"] = {"| "}} for _,eachColor in ipairs(Elim.colors) do _printNotes[eachColor] = {"| "} end
  local _notesToReturn = {}
  local handObjs = Elim.getHands()--[guid] = handColor
  local _supportParnter = false --in case the note was copy pasted: 1 on secret mat, 1 in the play area. Prevents double logging
  local function _handleSFT(noteData)
    local function _broadcastSupport(supportColor)
      if _supportParnter == supportColor then return end --dont double log if the card was coppied to secrets mat
        _supportParnter = supportColor
        table.insert(_printNotes[supportColor], "Support For The Throne")
        safeBroadcast("ALL", "! The "..supportColor.." has lost the "..Elim.target.." player's Support For The Throne !\nMove their score back on the score track", supportColor)
    end

    local function _returnNote()
      table.insert(_notesToReturn, noteData.obj)
    end

    --is it in a player's play area?
    local _inZone = _boundingBoxContains(Elim.targetZone.boundingBox, noteData.obj.getPosition())
    if _inZone then
      if _inZone == Elim.target then _returnNote() return end
      _broadcastSupport(_inZone)
    end

    --In another player's hand?
    local _inHand = handObjs[noteData.guid] or false
    if _inHand then
      if _inHand == Elim.target then _returnNote() return end
      _broadcastSupport(_inHand)
    end

    --on the secrets mat?
    local _matColor = SecretMat.contains(noteData.guid)
    if _matColor then
      if _matColor == "Grey" or _matColor == Elim.target then _returnNote() return end
      _broadcastSupport(_matColor)
    end

    _returnNote()
  end

  local function _logNote(noteData)
    local _inHand = handObjs[noteData.guid] or false
    if _inHand then
      if _inHand == Elim.target then return end

      table.insert(_printNotes[_inHand], noteData.name)
      table.insert(_notesToReturn, noteData.obj)
      return
    end

    local objPos = noteData.obj.getPosition()
    if _boundingBoxContains(Elim.targetZone.boundingBox, objPos) then return end--note already returned

    local _inZone = _zoneHelper.zoneFromPosition(objPos)
    if _inZone then
      table.insert(_printNotes[_inZone], noteData.name)
      table.insert(_notesToReturn, noteData.obj)
      return
    end

    --else its in an unknown location
    table.insert(_printNotes["Grey"], noteData.name)
    table.insert(_notesToReturn, noteData.obj)
  end

  --find target's notes
  for _,eachNote in ipairs(Elim.proms) do
    if eachNote.color == Elim.target then
      --make sure the objRef is still live
      eachNote.obj = eachNote.obj ~= nil and eachNote.obj or getObjectFromGUID(eachNote.obj)
      if eachNote.obj ~= nil then
        if eachNote.name == "Support for the Throne ("..Elim.target..")" then
          _handleSFT(eachNote)
        else
          _logNote(eachNote)
        end
      end
    end
  end
  --move to play area
  for _,eachNote in ipairs(_notesToReturn) do
    eachNote.deal(1, Elim.target)
    Coru.yieldFor(8)
  end

  --printResult
  if #_notesToReturn < 1 then
    safePrint("ALL", "|   No notes found", "Yellow")
  else
    safePrint("ALL", "|   Found and returned "..#_notesToReturn.." notes:", "Yellow")
    for eachCol,found in pairs(_printNotes) do
      if #found > 1 then
        safePrint("ALL", table.concat(found, " - "), eachCol)
      end
    end
  end
end

--other players get their proms back
Elim.reclaimProms = function()
  safePrint("ALL", "|\n|~Returning other players\' Promissory Notes...", "Yellow")
  coroutine.yield(0)
  local _printNotes = {} for _,eachColor in ipairs(Elim.colors) do _printNotes[eachColor] = {"| "} end
  local _notesToReturn = {}--[color] = {obj}

  local handObjs = Elim.getHands()--[guid] = handColor
  for _,eachColor in ipairs(Elim.colors) do _notesToReturn[eachColor] = {} end
  local function _doReturnThisProm(noteData)
    local _inHand = handObjs[noteData.guid] or false
    if _inHand then
      if _inHand ~= Elim.target then return false end
      return true
    end

    if _boundingBoxContains(Elim.targetZone.boundingBox, noteData.obj.getPosition()) then
      return true
    end

    if SecretMat.columnContains({guid = noteData.guid, color = Elim.target}) then
      return true
    end

    return false
  end

  --get objects that need to be returned
  for _,eachNote in ipairs(Elim.proms) do
    if eachNote.color ~= Elim.target then
      --make sure the objRef is still live
      eachNote.obj = eachNote.obj ~= nil and eachNote.obj or getObjectFromGUID(eachNote.obj)
      if eachNote.obj ~= nil and _doReturnThisProm(eachNote) then
        table.insert(_printNotes[eachNote.color], eachNote.name)
        table.insert(_notesToReturn, {eachNote.obj, eachNote.color})
      end
    end
  end

  --return objects
  for _,eachNote in ipairs(_notesToReturn) do
    eachNote[1].deal(1, eachNote[2])
    coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  end

  --printResult
  if #_notesToReturn < 1 then
    safePrint("ALL", "|   No notes found", "Yellow")
  else
    safePrint("ALL", "|   Found and returned "..#_notesToReturn.." notes", "Yellow")
    for eachCol,noteNames in pairs(_printNotes) do
      if #noteNames > 1 then --all colors have a prefix at i == i, ignore this
        safePrint("ALL", table.concat(noteNames, " - "), eachCol)
      end
    end
  end
end

Elim.shiftSpeaker = function()
  if not next(Elim.speakerToken) then return end

  safePrint("ALL", "|\n|~Moving the speaker token left...", "Yellow")
  coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  local speakerToken = Elim.speakerToken.obj ~= nil and Elim.speakerToken.obj or getObjectFromGUID(Elim.speakerToken.guid) or false
  local function leftNeighborFrom(color, _abortCase)
    for i,eachCol in ipairs(Elim.colors or {}) do
      if eachCol == color then
        local left = i == #Elim.colors and 1 or i + 1
        if _eliminated[Elim.colors[left]] then
          if _abortCase == color then--we looped through all players, no one is worthy
            --Case wont be reached in a legit game scenario
            return false
          else return leftNeighborFrom(Elim.colors[left], Elim.target)
          end
        else --left player is not eliminated, exalt them
          return Elim.colors[left]
        end
      end
    end
  end
  local newSpeaker = leftNeighborFrom(Elim.target) or false
  local zoneAttrs = newSpeaker and _zoneHelper.zoneAttributes(newSpeaker)
  if not newSpeaker then
    safePrint("ALL","!Failed! Could not identify the next speaker", "Red")
    coroutine.yield(0)
    return
  elseif not zoneAttrs then
    safePrint("ALL","!Failed! Could not find the "..newSpeaker.." player's zone.", "Red")
    coroutine.yield(0)
    return
  elseif not speakerToken then
    safePrint("ALL","!Failed! Bad reference to the Speaker Token.", "Red")
    coroutine.yield(0)
    return
  end

  local pos = {
      x = zoneAttrs.center.x,
      y = zoneAttrs.center.y + 5,
      z = zoneAttrs.center.z + 6 * (zoneAttrs.center.z < 0 and 1 or -1)
  }
  local rot = {
      x = 0,
      y = zoneAttrs.rotation.y,
      z = 0
  }
  local collide = false
  local fast = false
  speakerToken.setPositionSmooth(pos, collide, fast)
  speakerToken.setRotationSmooth(rot, collide, fast)
  coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  safePrint("ALL","|    The "..newSpeaker.." is now the speaker", newSpeaker)
end

Elim.returnCommandTokens = function()
  safePrint("ALL", "|\n|~Returning command tokens...", "Yellow")
  if Elim.containers["commandTokens"] == nil then
    safePrint("ALL", "|!FAILED! Could not find "..Elim.target.."\'s Command Tokens Bag", "RED")
    return
  end
  --else
    local _count = 0
    for _,eachToken in ipairs(Elim.commandTokens) do
      local activeObj = eachToken.obj ~= nil and eachToken.obj or getObjectFromGUID(eachToken.guid)
      if activeObj then Elim.containers["commandTokens"].putObject(activeObj) _count = _count + 1 end
      coroutine.yield(0)
      coroutine.yield(0)
    end

    if _count < 1 then
      safePrint("ALL", "|   No tokens found", "Yellow")
    else
      safePrint("ALL", "|   Found and returned ".._count.." tokens.","Yellow")
    end
end

Elim.returnUnits = function()
  if not Elim.units or not next(Elim.units) then
    safePrint("ALL", "|!FAILED! Did not locate any units.", "RED")
    return
  end

  --return elim player's units and any units they have captured
  safePrint("ALL", "|\n|~Returning units...", "Yellow")
  local targetUnits = {}--{{name,obj,col,guid},}
  local othersUnits = {}--{{name,obj,col,guid},}
  local unitBags = {}--[color][unitType] = objRef
  local _missingBags = {}
  for _,each in ipairs(Elim.colors) do unitBags[each] = {} _missingBags[each] = {} end--init
  --separate unitObjs by owner. separate unit bags from unit pieces
  --other players' units are returned if they are captured in the elim player's zone
  for _,eachUnit in ipairs(Elim.units) do
    eachUnit.obj = eachUnit.obj ~= nil and eachUnit.obj or getObjectFromGUID(eachUnit.guid)
    local liveRef = eachUnit.obj
    if liveRef then
      if liveRef.tag == "Bag" then
        unitBags[eachUnit.color][eachUnit.name] = liveRef
      else
        local targetSet = eachUnit.color == Elim.target and targetUnits or othersUnits
        table.insert(targetSet, eachUnit)
      end
    end
  end

  --get fighter tokens
  local _fighterData = {
    name = (Elim.target.." Fighter"),
    size = false,--objBounds set by first fighter found, used for sphereCast size
    x3s = {},--found tokens {[guid] = obj,...}
    x1s = {}
  }
  if Elim.containers["x3Fighters"] ~= nil or Elim.containers["x1Fighters"] ~= nil then
    for _,eachUnit in ipairs(targetUnits) do
      if eachUnit.name == _fighterData.name then
        if not _fighterData.size then
          _fighterData.size = eachUnit.obj.getBounds().size
        end
        --build circleCast
        local _oPos = eachUnit.obj.getPosition()
        local _castStart = _oPos.y +(1.501 * _fighterData.size.y)--starting above the fighter, then moving down
        local _cast = Physics.cast({
            type = 2,
            origin = {x = _oPos.x, y = _castStart, z = _oPos.z},
            direction = {0, -1, 0},
            max_distance = _castStart - 1.13,--till systemTile hit
            size = {x = _fighterData.size.z, y = _fighterData.size.z, z = _fighterData.size.z},
            --debug = true
        })
        --find tokens in result:
        for _,eachHit in ipairs(_cast or {}) do
          local _oName = eachHit.hit_object.getName()
          if _oName == "x3 Fighter Token" then
            local oG = eachHit.hit_object.getGUID()
            _fighterData.x3s[oG] = eachHit.hit_object
          elseif _oName == "x1 Fighter Token" then
            local oG = eachHit.hit_object.getGUID()
            _fighterData.x1s[oG] = eachHit.hit_object
          end
        end
        Coru.yieldFor(4)
      end
    end
  end

  --return elim player's units
  for _,eachUnit in ipairs(targetUnits) do
    if unitBags[Elim.target][eachUnit.name] then
      unitBags[Elim.target][eachUnit.name].putObject(eachUnit.obj)
      Coru.yieldFor(4)
    else
      _missingBags[Elim.target][eachUnit.name] = true
    end
  end
  coroutine.yield(0)

  --return any of their fighter tokens
  if Elim.containers["x3Fighters"] ~= nil then
    for tokenGuid,eachToken in pairs(_fighterData.x3s) do
      eachToken = eachToken ~= nil and eachToken or getObjectFromGUID(tokenGuid) --is ref still good?
      if eachToken ~= nil then
        Elim.containers["x3Fighters"].putObject(eachToken)
        coroutine.yield(0) coroutine.yield(0)
      end
    end
  else
    safePrint("!ERROR! Could not find 'x3 Fighter Tokens Bag'", "Red")
  end
  if Elim.containers["x1Fighters"] ~= nil then
    for tokenGuid,eachToken in pairs(_fighterData.x1s) do
      eachToken = eachToken ~= nil and eachToken or getObjectFromGUID(tokenGuid) --is ref still good?
      if eachToken ~= nil then
        Elim.containers["x1Fighters"].putObject(eachToken)
        coroutine.yield(0) coroutine.yield(0)
      end
    end
  else
    safePrint("!ERROR! Could not find 'x1 Fighter Tokens Bag'", "Red")
  end

  --report failures
  if next(_missingBags[Elim.target] or {}) then
    local pTable = {"! Failed to find unit bags for:"}
    for each,_ in pairs(_missingBags[Elim.target]) do
      table.inset(pTable,each)
    end
    safePrint("ALL", table.concat(pTable, ", "), "Red")
  end
  coroutine.yield(0)

  --find captued units
  _missingBags[Elim.target] = nil
  local _isMissingBags = false
  local captureCount = 0
  local function _maybeReturnUnit(unitData)
    unitData.obj = unitData.obj ~= nil and unitData.obj or getObjectFromGUID(unitData.guid)
    local liveRef = unitData.obj
    if not liveRef then return end

    local oPos = liveRef.getPosition()
    if not _boundingBoxContains(Elim.targetZone.boundingBox, oPos) then return end
    --Also need to make sure units are not on a system tile. Some map layouts (and Creuss Tile) may be inside the bounding box
    local _onTile = _systemHelper.systemFromPosition(oPos)
    if _onTile then return end

    local bag = not _missingBags[unitData.color][unitData.name] and unitBags[unitData.color] and unitBags[unitData.color][unitData.name]
    if not bag then
      _isMissingBags = true
      _missingBags[unitData.color][unitData.name] = true
      return
    end

    --return unit
    captureCount = captureCount + 1
    bag.putObject(liveRef)
    coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  end
  for _,eachUnit in ipairs(othersUnits) do
    _maybeReturnUnit(eachUnit)
  end
  --report captures
  if captureCount > 0 then
    safePrint("ALL","|  Returned "..captureCount.." captured units", "Green")
    --report failures
    if _isMissingBags then
      local pTable = {"! Failed to find unit bags for:"}
      for eachCol,missing in pairs(_missingBags) do
        for eachU,_ in pairs(missing or {}) do
          table.insert(pTable,eachU)
        end
      end
      safePrint("ALL", table.concat(pTable, ", "), "Red")
    end
  end
  coroutine.yield(0)
end

Elim.returnStrats = function()
  if not next(Elim.strats) then return end

  safePrint("ALL", "|\n|~Returning Strategy Card(s)...", "Yellow")
  coroutine.yield(0)
  local _printStrats = {"|    Returned"}
  for _,eachStrat in ipairs(Elim.strats) do
    table.insert(_printStrats, eachStrat.name)
    _stratHelper.returnStrategyCard(eachStrat.guid)
    coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)
  end
  --print result
  if #_printStrats > 1 then safePrint("ALL", table.concat(_printStrats, " - "), "Yellow")
  else safePrint("ALL", "|    None found", "Yellow") end
  coroutine.yield(0)
end

Elim.discardActions = function()
  safePrint("ALL", "|\n|~Discarding action cards...", "Yellow")
  coroutine.yield(0)
  local _logCards = {"| "}
  local _errCards = {"| "}
  local handObjs = Elim.getHands()--[guid] = handColor
  local _count = 0
  for each,color in pairs(handObjs or {}) do
    if color == Elim.target then
      local obj = getObjectFromGUID(each)
      local oName = obj ~= nil and obj.getName()
      if obj ~= nil and _deckHelper.getDeckName(oName) == "Actions" then
        _count = _count + 1
        if safeDiscardFromHand({name = oName, guid = each, obj = obj, order = _count}) == false then
          table.insert(_errCards, oName) else table.insert(_logCards, oName)
        end
        Coru.yieldFor(6)
      end
    end
  end

  if #_logCards - 1 < 1 then
    safePrint("ALL", "|   No action cards found", "Yellow")
  else
    safePrint("ALL", "|   Found and discarded "..(#_logCards -1).." cards:", "Yellow")
    safePrint("ALL", table.concat(_logCards, " - "), "Yellow")
  end
  if #_errCards > 1 then
    safePrint("ALL", "!ERROR! "..(#_errCards).." failed to discard:", "Red")
    safePrint("ALL", table.concat(_errCards, " - "), "Red")
  end
end

Elim.discardSecrets = function()
  safePrint("ALL", "|\n|~Discarding scored and unscored secret objectives...", "Yellow")
  coroutine.yield(0)
  local _publicLog = {"|   Face up secrets "}
  local _errCards = {"| "}
  local _cardsToReturn = {}
  local _privateCount = 0

  local handObjs = Elim.getHands()--[guid] = handColor
  local function processSecret(cardData)
    local _inHand = handObjs[cardData.guid]
    if _inHand then
      if _inHand ~= Elim.target then return end

      _privateCount = _privateCount + 1
      cardData.fromHand = true
      table.insert(_cardsToReturn, cardData)
      return
    end
    --in play area
    local oPos = cardData.obj.getPosition()
    if _boundingBoxContains(Elim.targetZone.boundingBox, oPos) then
      table.insert(_cardsToReturn, cardData)
      if cardData.obj.is_face_down then
        _privateCount = _privateCount + 1
      else
        table.insert(_publicLog, cardData.name)
      end
      return
    end
    --on mat
    if SecretMat.columnContains({guid = cardData.guid, color = Elim.target}) then
      table.insert(_publicLog, cardData.name)
      table.insert(_cardsToReturn, cardData)
      return
    end
  end

  --find secrets
  for _,each in ipairs(Elim.secrets) do
    each.obj = each.obj ~= nil and each.obj or getObjectFromGUID(each.guid) --make sure obj ref is still good
    if each.obj ~= nil then
      processSecret(each)
    end
  end

  --discard
  for i,each in ipairs(_cardsToReturn) do
    each.shuffle = true
    each.order = i
    if safeDiscard(each) == false then table.insert(_errCards, each.guid) end
    Coru.yieldFor(8)
  end

  if #_cardsToReturn < 1 then
    safePrint("ALL", "|   No secrets found", "Yellow")
  else
    safePrint("ALL", "|   Discarded ".._privateCount.." unscored and "..(#_cardsToReturn - _privateCount).." scored/face-up secrets", "Yellow")
    if #_publicLog > 1 then safePrint("ALL", table.concat(_publicLog, " - "), "Yellow") end
  end
  if #_errCards > 1 then
    safePrint("ALL", "!ERROR! "..(#_errCards).." failed to discard! Card GUIDS:", "Red")
    safePrint("ALL", table.concat(_errCards, " - "), "Red")
  end
end

Elim.discardAgendas = function()
  safePrint("ALL", "|\n|~Discarding agendas from play area...", "Yellow")
  coroutine.yield(0)

  if not next(Elim.agendas) then
    safePrint("ALL", "|   Found no laws in play", "Yellow") return
  end
  local _log = {"|\n|   Discarded"}

  --get laws from mat
  local _getMatLaws = copyTable(AgendaMat.getLaws() or {})
  local _matLaws = {}
  for name,eachGuid in pairs(_getMatLaws) do
    _matLaws[name] = {guid = eachGuid, obj = getObjectFromGUID(eachGuid), name = name}
  end

  --expect laws to be copy/pasted
  --get laws in play area, find any copies of it on the mat
  local _ownedAgendas = {}
  for _,eachAgenda in ipairs(Elim.agendas) do
    eachAgenda.obj = eachAgenda.obj ~= nil and eachAgenda.obj or getObjectFromGUID(eachAgenda.guid)
    if eachAgenda.obj ~= nil then
      local oPos = eachAgenda.obj.getPosition()
      if _boundingBoxContains(Elim.targetZone.boundingBox, oPos) then
        table.insert(_ownedAgendas, eachAgenda)
        table.insert(_log, eachAgenda.name)
      end
    end
  end

  --find any coppies on mat
  for _,eachOwned in ipairs(_ownedAgendas) do
    if _matLaws[eachOwned.name] then
      table.insert(_ownedAgendas, _matLaws[eachOwned.name])
      _matLaws[eachOwned.name] = nil --trim the table
    end
  end

  --return cards
  local _errs = {"!ERROR! Failed to discard"}
  for i,eachOwned in ipairs(_ownedAgendas) do
    eachOwned.order = i
    if safeDiscard(eachOwned) == false then table.insert(_errs, eachOwned.name) end
    Coru.yieldFor(8)
  end

  if #_log > 1 then
    _log[1] = ("|\n|   Discarded "..#_ownedAgendas.." agendas\n|  ")
    safePrint("ALL", table.concat(_log, " - "), "Yellow")
  else
    safePrint("ALL", "|   No agendas in play area - players should check the Agenda Mat", "Yellow")
  end
  if #_errs > 1 then
    safePrint("ALL", table.concat(_errs, " - "), "Red")
  end
end

Elim.returnMisc = function()
  if not next(Elim.misc) then return end
  safePrint("ALL", "|\n|~Returning faction specific items...", "Yellow")
  coroutine.yield(0)

  if Elim.containers["Directionaliser"] == nil then return end
  local _refPos = Elim.containers["Directionaliser"].getPosition()
  if not _refPos then return end
  local _tableSide = _refPos.z > 0 and -1 or 1

  local _returnTo = {x = _refPos.x - 10, y = _refPos.y, z = _refPos.z + (3* _tableSide)}
  local _objsToReturn = {}
  local _log = {"|"}
  for i,each in ipairs(Elim.misc) do
    each.obj = each.obj ~= nil and each.obj or getObjectFromGUID(each.guid)
    if each.obj ~= nil and not _boundingBoxContains(Elim.targetZone.boundingBox, each.obj.getPosition()) then
      table.insert(_log, each.name)
      table.insert(_objsToReturn, each.obj)
    end
  end

  for i,eachObj in ipairs(_objsToReturn) do
    eachObj.setPositionSmooth({x = _returnTo.x + (i*0.5), y = _returnTo.y, z = _returnTo.z}, false, true)
    Coru.yieldFor(6)
  end

  if #_log > 1 then
    _log[1] = ("|    Found and returned "..#_log.." items:\n")
    safePrint("ALL", table.concat(_log, " - "), "Yellow")
  else
    safePrint("ALL", "|   No unique items found", "Yellow")
  end
end

--------------------------------------------------------------------------------
--printToAll and broadcastToAll sometimes throw erros if a player is not seated
--players = "ALL" or "color" or table of Cols
--txtCol = "color" or "MATCH" to match the color of recipient
function safePrint(players, msg, txtCol)
  local function getTargets()
    local t = {}
    if players == "ALL" then
      local P = Player.getPlayers()
      for _,each in ipairs(P or {}) do
        if each.seated then table.insert(t, each.color) end
      end
      return t
    end
    --else
    players = type(players) == "table" and players or {players}
    for _,each in ipairs(players) do
      if Player[each].seated then table.insert(t, each) end
    end
    return t
  end
  local targets = getTargets() or {}
  for _,each in ipairs(targets) do
    printToColor(msg, each, txtCol == "MATCH" and each or txtCol)
  end
end

function safeBroadcast(players, msg, txtCol)
  local function getTargets()
    local t = {}
    if players == "ALL" then
      local P = Player.getPlayers()
      for _,each in ipairs(P or {}) do
        if each.seated then table.insert(t, each.color) end
      end
      return t
    end
    players = type(players) == "table" and players or {players}
    for _,each in ipairs(players) do
      if Player[each].seated then table.insert(t, each) end
    end
    return t
  end
  local targets = getTargets() or {}
  for _,each in ipairs(targets) do
    broadcastToColor(msg, each, txtCol == "MATCH" and each or txtCol)
  end
end

--params = "cardGUID" or {name, guid, obj, order, shuffle, fromHand}
function safeDiscard(params)
  if type(params) == "string" then
    local obj = getObjectFromGUID(params)
    if not obj then return false end
    params = {obj = obj, name = obj.getName(), guid = params}
  end
  local function _discard()
    _deckHelper.discardCard({name = params.name, guid = params.guid, index = params.order, shuffleOnDiscard = params.shuffle})
  end
  if params.fromHand then return safeDiscardFromHand(params) end
  local success, result = pcall(_discard)
  return success
end

--params = "cardGUID" or {name, guid, obj, order, shuffle, fromHand}
function safeDiscardFromHand(params)
  if type(params) == "string" then
    local obj = getObjectFromGUID(params)
    if not obj then return false end
    params = {obj = obj, name = obj.getName(), guid = params}
  end

  params.obj.use_hands = false
  local function _discard()
    _deckHelper.discardCard({name = params.name, guid = params.guid, index = params.order, shuffleOnDiscard = params.shuffle})
  end

  local _disCo = coroutine.create(function()
    params.obj.use_hands = false
    coroutine.yield(0)

    local success, result = pcall(_discard)
    if not success then params.obj.use_hands = true return false end

    Coru.yieldFor(8)
    if params.obj ~= nil then params.obj.use_hands = true end
  end)
  Coru.run(_disCo)
end

-------------------------------------------------------------------------------
function CoroutineRunner()
  while next(Coru._coroutines) do
    local deadList = {}
    --Progress each coroutine
    for eachCo,callbackData in pairs(Coru._coroutines) do
      local status = coroutine.status(eachCo)
      status = Coru.step[status] and status or "catch"
      local isDead = Coru.step[status](eachCo, callbackData) == -1 or status == "dead"
      if isDead then table.insert(deadList, eachCo) end
    end

    --Empty killQueue
    for _,each in ipairs(Coru._coKillQueue) do
      table.insert(deadList, each)
    end
    Coru._coKillQueue = {}

    --Remove dead coroutines
    for _,each in ipairs(deadList) do
      Coru._coroutines[each] = nil
    end

    coroutine.yield(0)
    --Add any waiting coroutines here
    for _,each in ipairs(Coru._coQueue) do
      Coru._coroutines[each.co] = {callback = each.callback, yieldback = each.yieldback}
    end
    Coru._coQueue = {}
  end

  Coru._coRunner = false
  return 1
end

--callbackData = { yieldback = func (called each time co yeilds), callback = func (called when co ends)}
Coru.run = function(newCo, callbackData)
  if Coru._coRunner then
    table.insert(Coru._coQueue, {co = newCo, callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback})
  else
    Coru._coroutines[newCo] = {callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback}
    Coru._coRunner = startLuaCoroutine(self, "CoroutineRunner")
  end
end

Coru.stop = function(co)
  for _,each in ipairs(Coru._coQueue) do
    if each.co == co then
      if each.callback then each.callback(-1) end
      each = nil
      break
    end
  end
  if not Coru._coroutines[co] then return end

  if Coru._coRunner then
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    table.insert(Coru._coKillQueue, co)
  else
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    Coru._coroutines[co] = nil
  end
end

Coru.wait = function(t, callback)
  local newWait = coroutine.create(function()
    local t1 = Time.time
    while Time.time - t1 < t do
      coroutine.yield(0)
    end
    return 1
  end)

  Coru.run(newWait, {callback = callback})
  return newWait
end

Coru.yieldFor = function(frames)
  local _frames = 0
  while _frames < frames do _frames = _frames + 1 coroutine.yield(0) end
end
-------------------------------------------------------------------------------
function copyTable(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and copyTable(v) or v
        end
        t = copy
    end
    return t
end

local _deletedItemsGuid = false
function ignoreDeletedItem(guid)
    local deletedItems = _deletedItemsGuid and getObjectFromGUID(_deletedItemsGuid)
    if not deletedItems then
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == 'TI4 Deleted Items' then
                _deletedItemsGuid = object.getGUID()
                deletedItems = object
                break
            end
        end
    end
    if deletedItems then
        deletedItems.call('ignoreGuid', guid)
    end
end

function _boundingBoxContains(boxXZ, position)
    assert(type(boxXZ) == 'table' and boxXZ.min and type(position) == 'table' and position.x)
    local gteMin = position.x >= boxXZ.min.x and position.z >= boxXZ.min.z
    local lteMax = position.x <= boxXZ.max.x and position.z <= boxXZ.max.z
    return gteMin and lteMax
end

function tryCall(callData, params)
  local function try()
    --validate
    assert(callData and type(callData) == "table")
    callData.obj = assert(callData.obj ~= nil and callData.obj or getObjectFromGUID(callData.guid))
    assert(callData.obj ~= nil and type(callData.obj) == "userdata", "callback obj could not be found")
    assert(callData.func and type(callData.func) == "string" and callData.obj.getVar(callData.func), 'missing ' .. callData.obj.getName() .. '.' .. callData.func)
    --build params
    local passParams = params == nil and {} or type(params) == "table" and params or {params}
    local dataParams = callData.params == nil and {} or type(callData.params) == "table" and callData.params or {callData.params}
    local mergedParams = {} --params will overide callData.params values that have the same key
    for k,v in pairs(dataParams) do mergedParams[k] = v end
    for k, v in pairs(passParams) do
      if type(k) == "number" then table.insert(mergedParams, v)
      else mergedParams[k] = v
      end
    end
    --call
    return callData.obj.call(callData.func, mergedParams)
  end
  local success, result = pcall(try)
  if not success then print("Failed callback: callData incorrectly formated: ", result) return end
  return result
end
-------------------------------------------------------------------------------
function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_ELIMINATION_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    _searchForEliminations()
end
-------------------------------------------------------------------------------
-- @author Darrell

local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)