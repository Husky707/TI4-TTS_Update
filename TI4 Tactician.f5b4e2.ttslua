--_WARNING!! [ctrl] + [k] + [1] to collapse tables or suffer scrolling through xml tables! (atom editor)

function getHelperClient(helperObjectName)
    local helperObject = Global.call('getHelper', helperObjectName)
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

local Events = getHelperClient('TI4_EVENT_HELPER')
local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _unitHelper = getHelperClient('TI4_UNIT_HELPER')

--Data containers-----------------------------
local _cmdToken = { --handels the floating command token object/animations
  --*obj = nil, --runtime only
  guid = false,
  diffuse = "http://cloud-3.steamusercontent.com/ugc/2013722609377867963/0E05B3E0F2109C3779C15989F135C7D55AD0E490/",
  data = {
    Nickname = "Auto-roller Command Token",
    Description = "Drag & Drop me to activate a system, flip me to change who is activating",
    Tooltip = true,
    Grid = false,
    Snap = false,
    DragSelectable = false,
    Sticky = false,
    Hands = false,
    AttachedDecals = {},
  },
  posOffset = {x = 1.117, y = 0.3, z = -1.875},
  scaleRatio = 1.4/3.45, --Command Token scale to Tactician scale --Maintain ratio when tactician is scaled

  canAnimate = false,
  animator = false,
  tracking = false,
  use_gravity = false,
  dropTokens = {},
}
local Coru = {
 _coroutines = {},
 _coRunner = false,
 _coQueue = {},
 _coKillQueue = {},
 step = {
   ["running"] = function() end,
   ["normal"] = function() end,
   ["suspended"] = function(eachCo, callbackData)
     local status, result = coroutine.resume(eachCo)
     if not status then
       print("Coroutine error: ", result)
       if callbackData and callbackData.callback then callbackData.callback(result) end
       return -1
     else
       if callbackData and callbackData.yieldback then callbackData.yieldback(result) end
     end
   end,
   ["dead"] = function(eachCo, callbackData)
     if callbackData and callbackData.callback then callbackData.callback(1) end
     return -1
   end,
   ["catch"] = function(eachCo, callbackData, badState)
     print("Caught a bad coru state: ", badState)
     if callbackData and callbackData.callback then callbackData.callback(-1) end
     return -1
    end
 },
}
local Animate = {} --Group and run animation clips
local AnimClip = {} --individual OBJECT anamations
local uiClips = {} --ui animations
local Tween = {} --Tween lib for animation clips
local XML = {}--converts lua values to/from xml values; see: getColor(),rgbaFromName(),rgbaFromTable()
local ToggleButton = {} --old custom button wrapper for fancier toggleButton sprites; here be dragons
local MultiRoller = {} --logic responible for handling roll requests
local Invasion = {} --Handles the more complex invasion UI
local Plasma = { enabled = false, visible = false, target = false, offset = "-143 -6.2", focusOffset = ""..-382/2.3.." "..334/2.3, focusScale = "0.6 0.6 1"}
local PShield = {enabled = false, visible = false, status = {}}
local Planets = { --Handles the planet UI, closely connected to Invasion
  layouts = { --planet count to transforms
    [0] = {},
    [1] = {{x = 0, y = 85, scale = 1.4}},
    [2] = {{x = -116, y = 235, scale = 1}, {x = 206, y = -184, scale = 1}},
    [3] = {{x = -282, y = -31, scale = 1}, {x = 132.4, y = 293, scale = 0.9375}, {x = 242, y = -210, scale = 0.9375}},
    [4] = {{x = -149, y = 290, scale = 0.875}, {x = 271, y = 106, scale = 0.775}, {x = 204, y = -300, scale = 0.85}, {x = -294, y = -148, scale = 0.9375}},
    [5] = {{x = -141, y = 344, scale = 0.775}, {x = 244, y = 210, scale = 0.675}, {x = 343, y = -143, scale = 0.775}, {x = 0, y = -53, scale = 0.85}, {x = -302, y = -53, scale = 0.975}}, --Max of 5 planets supported (Xulltron + Ivan in 3p system)
  },
  focusLayouts = {
    [1] = {{x = 0, y = -470, scale = 2.3}},--Transform of FOCUS planet
    [2] = {{x = 0, y = 326, scale = 0.975}},
    [3] = {{x = -187, y = 230, scale = 0.775}, {x = 206, y = 347, scale = 0.7}},
    [4] = {{x = -228, y = 224, scale = 0.54}, {x = 0, y = 443, scale = 0.5875}, {x = 228, y = 224, scale = 0.5875}},
    [5] = {{x = 276, y = 323, scale = 0.5875}, {x = 0, y = 476, scale = 0.5875}, {x = -276, y = 323, scale = 0.5875}, {x = 0, y = 186, scale = 0.54}}, --Max of 5 planets supported (Xulltron + Ivan in 3p system)
  },
  traits = {
    data = { offset = 16, focusOffset = 82},
    ["industrial"] = "Icon_Industrial",
    ["cultural"] = "Icon_Cultural",
    ["hazardous"] = "Icon_Hazardous"
  },
  focusBanner = {--where should a planet's buttons be located while the planet is in/out of focus
    inFocus = {
      quickBomb = { --bomb/pds positions
        width = (228.0 * 0.85)/2.3,
        height = 199.0 * 0.85/2.3,
        offset = ""..(-280)/2.3.." "..(359.5 + 45)/2.3 --"-280 359.5",
      },
      quickPDS = {
        width = 170.0 * 0.85/2.3,
        height = 148.0 * 0.85/2.3,
        offset = ""..(185+10)/2.3.." "..(409 + 30)/2.3--"185 409",
      }
    },
    outOfFocus = {
      quickRoll = { --bomb/pds positions
        width = 128.0 * 0.85,
        height = 106.0 * 0.85,
        offsetLeft = "-221 -49.6",
        offsetRight = "221 -49.6",
      },
    }

  },
  animationData = {},

  defaults = {
    traitOffset = {x = 0, y = 0},
    scale = 1,
  },

  --
  plasmaTarget = false,
  _displayedSystem = false
}

--The core logic and state machine for the Tactician
local Tac = {
  disableAnimations = false,
  rollForMe = {["White"] = true, ["Pink"] = true, ["Red"] = true, ["Blue"] = true, ["Green"] = true, ["Yellow"] = true, ["Orange"] = true, ["Purple"] = true, ["Grey"] = false, ["Black"] = false, ["Teal"] = false, ["Brown"] = true},
  highlightAdjSystems = {}, --[color] = true

  isActionPhase = false,
  color = "Black",
  previousState = "Uninitialized",
  State = "Initializing",
  inStateTransition = false, --or State
  _onStateOpen = false,
  eStates = {
    Initializing = function() return "Initializing" end,
    Main = function() return "Main" end,
    Turns = function() return "Turns" end,
    Movement = function() return "Movement" end,
    SpaceCombat = function() return "SpaceCombat" end,
    Invasion = function() return "Invasion" end,
  },
  eGameEvents = {
    ["NewActivePlayer"] = function() return "NewActivePlayer" end,
    ["StartActionPhase"] = function() return "StartActionPhase" end,
    ["EndActionPhase"] = function() return "EndActionPhase" end,
    ["EndOfTacticalAction"] = function() return "EndOfTacticalAction" end,
    ["PlayerTurnStart"] = function() return "PlayerTurnStart" end,
    ["SystemActivated"] = function() return "SystemActivated" end,
    ["PlayerPassed"] = function() return "PlayerPassed" end,
    ["TacStepBtnClicked"] = function() return "TacStepBtnClicked" end,
    ["UnitMapUpdated"] = function() return "UnitMapUpdated" end
  },
}

--Data table passed to unit modifiers
local TacData = {--[[
  activeColor = ""
  activeSystem = {hex = "hex", system = systemTable, guid = system.guid},
  adjacentSystems = {} [perColor] = {["systemGuid1"] = {hex = "hexPosition", system = systemTableRef}, ["g2"] =...}
  adjacentSystems
  unitMap = {}--see MultiRoller.buildUnitMap for details
  hexToUnits
  initialized = bool--]]
}

--FINAL_WARNING!! [ctrl] + [k] + [1] to collapse tables or suffer scrolling through xml tables!
local ui = {
  assets = {
    --FONT
    {
      type = 1,
      name = "TI4_Fonts",
      url = "http://cloud-3.steamusercontent.com/ugc/1838056330496306579/02322986579B5ECCC96723A6031D1B71826CBE3B/"
    },
    {
      name = "Background_Empty",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445386/2E9974D51FDB94CD00B88FE30D1949473738B86C/"
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998417342035/B6D2EFB52B0786D073D0D7D799E5364DDE3427F3/"--Token/HEX
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445459/B53F7180834F5681609A2F779E1C09B965839566/"--Buttons
    },
    {
      name = "Background_Fill",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602992656627046/EC5F8D1F7170F1EDF29D6FAED0E004A5A05E3E9C/"
    },
    { name = "ZoneCover_Red",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345779668056/61B18C31220576699999E0C0030FE398A2B6310B/"
    },
    { name = "ZoneCover_Blue",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345779667947/FAD1134751CAD72CF084DFFC7CD1F9ADF439F83B/"
    },
    { name = "ZoneCover_Green",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345779667998/0B0315CC68384A022766465BC8BA3C7EDE9EB725/"
    },
    { name = "ZoneBackground_Blue",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602709725365811/01C6300A371762CEE3A9600D09A14FB8B55D582F/"
    },
    { name = "ZoneBackground_Red",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602709725336517/EAEA384C41355CA6A0409CFC94B708098AFDBBCD/"
    },
    { name = "HeaderCover",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602709725551602/FD2E0EC4B30F11718F29277A6370E805D94D3081/"
    },

    --Turn Display-----------------------
    { name = "StrategyCard_Icon",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407446044/EA93AE12446EA9074EBE5F9603D9FC8E616491DC/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407446006/8E3543C4396F8E83543E4F866E9745E7C3E57120/" --FontRef
    },
    { name = "Turns_PassedPlayer",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445964/EBA6A07722D0CD5BD6A19EC8E215ED213DC6402E/",
    },
    { name = "Turns_ActiveStrategy",
      url = "http://cloud-3.steamusercontent.com/ugc/2107180688382984408/8830EFD680A9B9A999643DF9EFF768D00C32F7B6/",
    },
    { name = "Turns_ActivePlayer",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445859/C525E6AB804963810B0D7E0A8AE49EAFFD423410/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445550/760850887ED0D58C41D4CCAC0D8CE11078CF1A3A/"--FontRef
    },
    { name = "Turns_NonactivePlayer",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445686/47A3DE7EA5599A1906153075D463688539AF1E7A/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445616/3A0B9D4056651D2AE9E85144BD9EB2D8672849FC/",--FontRef
    },
    { name = "Turns_NonactivePlayer_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445754/1EEE870F6C29E8792B8E0226C9CCFD42C402C814/",
    },
    { name = "Turns_NonactivePlayer_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445805/F49E98F97DBA11A988C273C3158F41F5AD18016B/",
    },

    --Header--------------------
    { name = "Header",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444484/52E7AD8C2AE13786DD83150A485EF47FFAD3D57F/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107180546436243120/1039060BF1C2EF60E401270D0A41CFDFB868B957/"
    },
    { name = "Header_ActiveColor",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444543/F85F20095F15FA4B7F4AE834ECDF0DCFD1CF6544/",
    },
    { name = "Header_Subheader",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444591/CFE8FB5AF0C49DA2E9145DA3F639367C0F78ECFE/",
    },
    { name = "Header_Deco",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444443/AB60D9A36C0D90290EAD0974B2CAB564272D1D41/",
    },
    { name = "Header_Gradient",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444395/339D3632C67C7A77C91E88D98A391AE65A95420D/",
    },

    --Main buttons-------
    {--Generic button
      name = "Btn_Standard",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345765746441/DE13898426CB6D24AD4A8CD3EA3509854E3A28B1/",
    },
    { name = "Btn_NoTactical",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442759/46BA666A29229E7ECCFDC1E4F0B0504BC01EB0EC/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443349/AB97E1A6E7DE3FD15766AB88D8E383585CFF127C/"--fontRef
    },
    { name = "Btn_Blue",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442565/490A263AD69E9EF5663E470C8FDA9FAB17DDBF18/",
    },
    { name = "Btn_Blue_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442616/B0CCFE6C556E68AE24C41E4A78395AC8F38BD09A/",
    },
    { name = "Btn_Blue_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442713/A2048F8CCC963A04D8090EB593DAD08BA4203955/",
    },
    { name = "Btn_Blue_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442664/85D7526A5CC4A4FB28BDF3FCAA89454A64FF5C61/",
    },
    { name = "Btn_Red",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443162/838B972073CB88972185033E3E58BFBB570B383D/",
    },
    { name = "Btn_Red_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443205/9588A96897ABD7E8D165F143660063555734AED8/",
    },
    { name = "Btn_Red_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443302/185020F274E7D7424294FF25A6C67271557F6155/",
    },
    { name = "Btn_Red_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443253/DECCCE0960E47CA7491830531849F4E7C3B6B090/",
    },
    { name = "Btn_Green",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442336/C3669AAD7213231555A14002FCC866CBE14CF635/",
    },
    { name = "Btn_Green_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442398/07B9BB3952B4816A8E33E7F0E02FF0B18558A1CB/",
    },
    { name = "Btn_Green_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442506/66EB1B076752D18CF4CF58202A87F030710C4749/",
    },
    { name = "Btn_Green_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442451/4157ED0BB167AFC805726FC45173630DFBB99682/",
    },

    --Icons
    { name = "Icon_CombatCounter",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445273/7970410DE8CD5062B8DAC5B02D2C47EBF33D48FF/",
    },
    { name = "Icon_CombatCounter_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445209/1C90414895551D70E5A9EAF721D74FBFC4D8FE5B/",
    },
    { name = "Icon_CombatCounter_On",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445327/D28BB86998627363C90996F29FDCE32B10CC3880/",
    },
    { name = "Icon_Agenda",
      url = "http://cloud-3.steamusercontent.com/ugc/2107180688382556638/5E08E51D538D3D774B53FAA68DBED4BADD6D6313/",
    },
    { name = "Icon_Attacker",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345774821831/0C9E3EF33129BA157619141A06E021FC21CB9762/"
    },
    { name = "Icon_Defender",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345774803100/6D44217F542F677D422011941D0399B16C032882/"
    },
    { name = "Icon_Cultural",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767516136796/AC1E9F3C948AC16DE55D87200EFB8537BBD9F949/"
    },
    { name = "Icon_Hazardous",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767516136837/4D1423652D72FB4BB4F92076C29E291353CAF51D/"
    },
    { name = "Icon_Industrial",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767516136878/91446D03D61201B3A91F73F22C7181D7EB4E3591/"
    },

    --SmartButtons
    { name = "BtnOutline_SmartAttack",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051813841/BC88343D2BB29FF450510DD659DC372527554C37/"
    },
    { name = "BtnOutline_SmartDefend",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051813897/1321698E66376C56F5B1D92BBCDDF2481163E798/"
    },
    { name = "Btn_SmartAttack",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442851/FFBB05A62AFA84598CE35C3F6BEAB7E0EDBE9E70/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442807/2CE4041F599F4FCF96899AA524A0E49875DFC135/" --iconRef
    },
    { name = "Btn_SmartAttack_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442899/80C4359F00CEA5E0C1E1C053FEA131471ABC1F48/",
    },
    { name = "Btn_SmartAttack_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442950/F4D14EF01E66018AA6588F9A93B6571C3F894C1C/",
    },
    { name = "Btn_SmartDefend",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443040/2FFDC64B5D692E3F5891F6996C568BB8F7D598B8/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443000/6A1227928B1F06ABE5BB7BBEE4298E85900E07C2/", --iconRef
    },
    { name = "Btn_SmartDefend_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443083/DCC1098EFDE2D3A4C37412D80DC4DA86ABDC921C/",
    },
    { name = "Btn_SmartDefend_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443122/41DFD2B125DB5EA84B7F53E790F8B28E43DBD5B8/",
    },
    { name = "Btn_SmartSubstep",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443827/54154DEF81F6F7F16402FDF722C18D6BC2CAA2B4/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443780/29E06F6953A017119AB41B15ACD21D0784DEFFA5/" --IconRef
    },
    { name = "Btn_SmartSubstep_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443883/5EE80A311DBEB16174901286AF25EB415262E0DA/",
    },
    { name = "Btn_SmartSubstep_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443931/059CB527DDAD822B8E5B7300E3DAFC21A7F85858/",
    },

    --Invasion Substeps
    { name = "Btn_SpaceCannonDefMode",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444224/0C8EF6525F82B5D15A728B3AE4BF6F7830880A97/",
    },
    { name = "Btn_SpaceCannonDefMode_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444172/0FCC9269773E493286E88BA2C638914D6EAEDD6E/",
    },
    { name = "Btn_SpaceCannonDefMode_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444272/22F8CF16751593430914B0EC95BEB1EE33C388CC/",
    },
    { name = "Btn_SpaceCannonDefMode_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444105/4A18DA5209BEAE16B68D3E32E2994260F4F29FB1/",
    },
    { name = "Btn_SpaceCannonDefMode_Label",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444047/3C691C10A6D146C27EFB6B39CC43BE1F019A32B9/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443986/C8FAB11E9666DF99CA101AB034CDA7C62D1E5ED6/" --fontRef
    },
    { name = "Btn_InvasionSubstepHex",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443729/566E91457C01400A1654A351E2317AAC460D5114/",
    },
    { name = "Btn_InvasionSubstepHex_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443681/BED39A89DC708E8F1D96F02744FB0B160A3608E5/",
    },
    { name = "Btn_BombardMode",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443584/159FB5657CF17A68C09465232ABEF1D6BC793DD2/",
    },
    { name = "Btn_BombardMode_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443536/763BA9FA4C736FFED604E6181E504A0E495C12E6/",
    },
    { name = "Btn_BombardMode_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443631/D7C6FBEF48CD7BBE8289C4E951846E471F1DD0A6/",
    },
    { name = "Btn_BombardMode_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443488/C508E6D312272D09429B4039148A157C4C4B5078/",
    },
    { name = "Btn_BombardMode_Label",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443444/06437021BC6B063E0032678254B745EE0C960A82/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443394/71F074C2FB57D38CA77CBADC3F982574532F6281/" --fontRef
    },

    --Invasion Hex
    { name = "FooterFade",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444323/3976267E81E457794AABFDC4CDFA74F3A09A7D29/",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602709737570717/22E9A1CDDD4E046710D84488F5D40C57C48F3F22/"
    },
    { name = "InvHex_Background",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444901/9C0E7E37FF40024D695D76A64E021230C6838462/",
    },
    { name = "InvHex_Space",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444819/20F4103438FFD825EFCEC7487B5D7FBB733FB4F3/",
    },
    { name = "InvHex_Outline",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444727/1AD85D7A7A0730926E3065DEDD329399B1660DCF/",
    },
    { name = "InvHex_ActiveColor",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444641/3BE066E2BC953A14CD6008478B4CF044862B3027/",
    },
    { name = "InvHex_Anomaly",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444680/28F9B7105B0DEE0618E4220869D0786CFB5A28BF/",
    },
    { name = "FocusPlanet_Nameplate",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445105/DEAD25627320C035D774F33A51BA85E94F04FE74/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444982/F8769B192F10D96104BA9F11C7F87872EBBF59F3/", --fontRef
    },
    { name = "FocusPlanet_Banner",
      url = "http://cloud-3.steamusercontent.com/ugc/2334622478624967535/D3D73F4DB45C7FD455A01C7B7195CF4C9B928650/"
      --url = "http://cloud-3.steamusercontent.com/ugc/2270441745051765453/B68CB40584F23C63BDB4EA4223A0BE55AE9DC0EC/"
    },

    --Wire Planets
    { name = "Wired_Planet",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292047/9AE485B9548DA25BCD3196AE130A6A40CB969334/"
    },
    { name = "Wired_Highlight",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292587/A553A67AEF56BB75A19E820F14893D40F901A988/"
    },
    { name = "Wired_cultural",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292386/7AF97E0E108E4EDCC8C4B9A8F8CFD74F3D796D94/"
    },
    { name = "Wired_hazardous",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292482/8F03B4A8850B5023E0B85CF3223AABD8624BD431/"
    },
    { name = "Wired_industrial",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292662/FB2DE8A3054288FAAD8A452DD78C1943939FD3B8/"
    },
    { name = "Wired_legendary",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292738/47866FB42F14CFA2C664FF9D544A075316F723FE/"
    },
    { name = "Wired_Rex",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292808/27890D8936C0A986C0D7AD3C458BABE98006DA8F/"
    },
    { name = "Wired_Nameplate",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767516136920/6DBA8BDAEB29C113FE41C565A09CC33860158F0E/"
    },
    { name = "Wired_Color",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508088929/75DAEBB23D442A074D47C814655E43EE06CBB635/"
    },
    { name = "Wired_Color_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292879/A0C524DA8A4490F1D415B2923CE67649BF626E2D/"
    },
    { name = "Wired_Color_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292994/CF29784C4136D424458467A42DF21C6C930690BB/"
    },

    --Planetary Shield
    { name = "Btn_PShield_NoOverride",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767873/B5454A5FD01B954A8370BA530292A7AEA18F3E9A/"
    },
    { name = "Btn_PShield_Disable",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767513/C8F1E989002BED717D5256B70D1AA6B37BB05AEA/"
    },
    { name = "Btn_PShield_Disable_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767630/50C3B5DE3AA3A595146BCFE8BEA48C1A3923D8C5/"
    },
    { name = "Btn_PShield_Disable_Dark",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767570/D7D0C6A0683BDA003F630DCD0EAE3B08E54CB8A5/"
    },
    { name = "Btn_PShield_Enable",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767695/8A6967351DF27C0709483DD8365F9BAB2B997B62/"
    },
    { name = "Btn_PShield_Enable_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767817/1836CABC5FA6FB57F51A5C99653681D2E5EE8148/"
    },
    { name = "Btn_PShield_Enable_Dark",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767754/97E1B8571740E9968B08E4259760DD55F282F9B6/"
    },
    { name = "PlanetaryShield_Enabled",
      url = "http://cloud-3.steamusercontent.com/ugc/2334622478624881007/148454EC9C436C4FA1FBD8EDA8EE14564472DC54/"
    },
    { name = "PlanetaryShield_Disabled",
      url = "http://cloud-3.steamusercontent.com/ugc/2334622478624880902/DECA6DE77A683D2D1413FD53C4740FB16D813265/"
    },

    --Quick buttons
    { name = "QuickBtn_Bombardment",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508088791/836A63FC747C2BBC5EBEB09E9CD047C5B9341ABD/"
    },
    { name = "QuickBtn_Bombardment_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508088837/A6700136D94BFB28D630D78BC7E253D351397D12/"
    },
    { name = "QuickBtn_Bombardment_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508088876/44CB5E8CAD591DE7D241215972B14219A2C4FA55/"
    },
    { name = "QuickBtn_PDS",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089164/08210B91770A906F59EC6EF99ECFF1C41F24E43F/"
    },
    { name = "QuickBtn_PDS_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089209/F1169DEE62E059EC852318AD450318AE80BF6686/"
    },
    { name = "QuickBtn_PDS_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089252/482A150732C5B0984A9D424F59076CAD2340D925/"
    },
    { name = "Icon_PlasmaScoring",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089347/8A0DEEA71C6F9A73CBA3AB952CA09B34B4BE5DA3/"
    },
    { name = "Icon_PlasmaScoring_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089390/5910B49EF23DF049D2711AA99F088A1BB0F7A829/"
    },
    { name = "Icon_PlasmaScoring_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089297/3893F50610D697248A6170D854B8B9B5F7277264/"
    },
  },

  xmlTable = {
   { tag = "Panel",
    attributes = {
      id = "Root",
      width = 2048,
      height = 3200,
      rotation = "0 0 180",
      position = "0 0 -5.1",
      scale ="0.146 0.146 1"
    },
    children = {
      -------------------------------------------------------------
      { --Background [1]
        tag = "Image",
        attributes = {
          id = "Blackground",
          image = "Background_Empty",
        },
        children = {
          {--Cover gradiant
            tag = "Image",
            attributes = {
              id = "BackFill_Main",
              image = "Background_Fill",
              height = "50%",
              rectAlignment = "LowerCenter"
            }
          }
        }
      },
      {--Header [2]
        tag = "Panel",
        attributes = {
          id = "Pnl_Header",
          height = 660,
          rectAlignment = "UpperCenter",
        },
        children = {
          {--ProgressBar
            tag = "Image",
            attributes = {
              id = "Header_ColorProgress",
              image = "Header_ActiveColor",
              color = "Grey",--dynamic
              position = "0 0 -0.01",
            }
          },
          {--ProgressMask
            tag = "Image",
            attributes = {
              id = "Header_ProgressMask",
              color = "Pink",
              width = 6, --animates 6 -> 2030
              height = 380,
              offsetXY = "4 36",
              rectAlignment = "LowerLeft",
              active = false,
            }
          },
          {--Subheader
            tag = "Image",
            attributes = {
              id = "Header_Subheader",
              image = "Header_Subheader",
              position = "0 0 -0.03",
            }
          },
          {--Main Image
            tag = "Image",
            attributes = {
              id = "Header",
              image = "Header",
            }
          },
          {--Gradient
            tag = "Image",
            attributes = {
              id = "Header_Gradient",
              image = "Header_Gradient",
              color = "Grey",
              position = "0 0 -0.05",
            }
          },
          {--Gradient ColorTransition
            tag = "Image",
            attributes = {
              id = "Header_GradientTransition",
              image = "Header_Gradient",
              color = "Grey",
              position = "0 0 -0.05"
            }
          },
          {--Deco Lines
            tag = "Image",
            attributes = {
              id = "Header_Deco",
              image = "Header_Deco",
              color = "Grey",
              position = "0 0 -0.06",
            }
          },
          {--Deco Lines Transition
            tag = "Image",
            attributes = {
              id = "Header_DecoTransition",
              image = "Header_Deco",
              color = "Grey",
              position = "0 0 -0.06",
            }
          },
          { --HeaderTxt
            tag = "Panel",
            attributes = {
              id = "TxtPnl_Header",
            },
            children = {
              {--Title Txt
                tag = "Text",
                attributes = {
                  id = "Txt_HeaderTitle",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  text = "TI4 TACTICIAN",
                  color = "White",
                  fontStyle = "Bold",
                  fontSize = 164,
                  alignment = "UpperCenter",
                  offsetXY = "200 -60"--"108 -36"
                }
              },
              {--Subheader Txt
                tag = "Text",
                attributes = {
                  id = "Txt_Subheader",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  text = "Loading...",
                  color = "White",
                  fontStyle = "Bold",
                  fontSize = 82,
                  alignment = "upperLeft",
                  offsetXY = "620 -340"--"364 -206",
                }
              }
            }
          },
        }
      },
      {--Movement [3]
        tag = "Panel",
        attributes = {
          id = "Pnl_MovementStep",
          height = "40%",
          rectAlignment = "UpperCenter",
          --color = "rgba(0.8,0.1,0.1,0.2)",
          offsetXY = "0 -646",
        },
        children = {
          { --Active step transform
            tag = "Panel",
            attributes = {
              id = "Pnl_MovementStep_Active",
              --active = false
            },
            children = {
              {--Background
                tag = "Image",
                attributes = {
                  id = "Img_MovementBackground",
                  image = "ZoneBackground_Blue",
                  preserveAspect = true,
                },
                children = {}
              },
              {--BackgroundCover
                tag = "Image",
                attributes = {
                  id = "Img_MovementCover",
                  image = "ZoneCover_Blue",
                  preserveAspect = true,
                  offsetXY = "0 20",
                  rectAlignment = "UpperCenter",
                  --active = false
                },
                children = {
                  {--FooterMask
                    tag = "Image",
                    attributes = {
                      id = "Img_MovementFooterCover",
                      image = "Background_Fill",
                      height = "280",
                      rectAlignment = "LowerCenter",
                      offsetXY = "0 -10"
                    }
                  }
                }
              },
              {--HeaderCover
                tag = "Image",
                attributes = {
                  id = "Img_MovementHeaderCover",
                  image = "HeaderCover",
                  preserveAspect = true,
                  rectAlignment = "UpperCenter",
                  offsetXY = "0 150",
                  --active = false
                }
              },
            }
          },
          {--Main Button transform
            tag = "Image",
            attributes = {
              id = "BtnBounds_MovementState",
              preserveAspect = true,
              image = "Btn_NoTactical",
              width = "1164",--"56.8%",
              height = "218",--"17%"
              rectAlignment = "UpperCenter",
            },
            children = {
              {--Btn Label
                tag = "Text",
                attributes = {
                  id = "Txt_MoveState",
                  text = "MOVEMENT",
                  color = "White",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  fontStyle = "Bold",
                  fontSize = 124,
                }
              }
            }
          },
        }
      },
      {--Space Combat [4]
        tag = "Panel",
        attributes = {
          id = "Pnl_SpaceCombatStep",
          height = "40%",
          rectAlignment = "UpperCenter",
          --color = "rgba(0.8,0.1,0.1,0.2)",
          offsetXY = "0 -938",--282 lower than PrevStep
        },
        children = {
          {--Active step transform
            tag = "Panel",
            attributes = {
              id = "Pnl_SpaceCombatStep_Active",
              --active = false
            },
            children = {
              {--Background
                tag = "Image",
                attributes = {
                  id = "Img_SpaceCombatBackground",
                  image = "ZoneBackground_Red",
                  preserveAspect = true,
                  --active = false
                },
                children = {}
              },
              {--BackgroundCover
                tag = "Image",
                attributes = {
                  id = "Img_SpaceCombatCover",
                  image = "ZoneCover_Red",
                  preserveAspect = true,
                  offsetXY = "0 20",
                  rectAlignment = "UpperCenter",
                  --active = false
                },
                children = {
                  {--FooterCover
                    tag = "Image",
                    attributes = {
                      id = "Img_SpaceCombatFooterCover",
                      image = "Background_Fill",
                      height = "280.0",
                      rectAlignment = "LowerCenter",
                      offsetXY = "0 -10"
                    }
                  },
                }
              },
              {--HeaderCover
                tag = "Image",
                attributes = {
                  id = "Img_SpaceCombatHeaderCover",
                  image = "HeaderCover",
                  preserveAspect = true,
                  rectAlignment = "UpperCenter",
                  offsetXY = "0 150",
                  --active = false
                }
              },
            }
          },
          {--Main Button transform
            tag = "Image",
            attributes = {
              id = "BtnBounds_SpaceCombatState",
              preserveAspect = true,
              image = "Btn_NoTactical",
              width = "1164",--"56.8%",
              height = "218",--"17%"
              rectAlignment = "UpperCenter",
            },
            children = {
              {--Btn Label
                tag = "Text",
                attributes = {
                  id = "Txt_SpaceCombatState",
                  text = "SPACE COMBAT",
                  color = "White",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  fontStyle = "Bold",
                  fontSize = 124,
                }
              }
            }
          },
        }
      },
      {--Invasion [5]
        tag = "Panel",
        attributes = {
          id = "Pnl_InvasionStep",
          height = 1980,
          width = 2048,
          rectAlignment = "LowerCenter",
        },
        children = {
          {--Active step transform
            tag = "Panel",
            attributes = {
              id = "Pnl_InvasionStep_Active",
              rectAlignment = "LowerCenter",
              --color = "rgba(0.1,0.1,0.8,0.2)",
            },
            children = {
              {--Hex Transform_Lower
                tag = "Panel",
                attributes = {
                  id = "Pnl_InvasionHex_Lower",
                  height = 1945,
                  rectAlignment = "LowerCenter",
                },
                children = {
                  {--Blue space
                    tag = "Image",
                    attributes = {
                      id = "Hex_SpaceBase",
                      image = "InvHex_Space",
                      width = 1500,
                      height = 1300,
                    }
                  },
                  {--Orbital Rings
                    tag = "Panel",
                    attributes = {
                      id = "Pnl_Orbitals",
                      width = 1100,
                      height = 1100,
                    },
                    children = {}
                  },
                  {--Focus banner
                    tag = "Panel",
                    attributes = {
                      id = "Pnl_FocusBannerTransform",
                      width = 452 * 2.6,
                      height = 1945,
                      raycastTarget = false,
                      offsetXY = "0 -477",
                    },
                    children = {--Img_FocusBanner
                      tag = "Image",
                      attributes = {
                        id = "Img_FocusBanner",
                        image = "FocusPlanet_Banner",
                        preserveAspect = true,
                        width = 452 * 2.6,
                        --height = 400,
                        active = false
                      }
                    },
                }
                  --Planets injected here
                }
              },
              {--Background
                tag = "Image",
                attributes = {
                  id = "Img_InvasionBackground",
                  image = "InvHex_Background",
                  preserveAspect = true,
                  height = 1945,
                  rectAlignment = "LowerCenter",
                  --active = false
                },
              },
              {--Hex transform Upper
                tag = "Panel",
                attributes = {
                  id = "Pnl_InvasionHex",
                  height = 1945,
                  rectAlignment = "LowerCenter",
                },
                children = {
                  {--Active Player Hex
                    tag = "Image",
                    attributes = {
                      id = "Hex_ActivePlayer",
                      image = "InvHex_ActiveColor",
                      color = "Grey",--dynamic
                      width = 1719,
                      height = 1489,
                    }
                  },
                  {--Hex outline
                    tag = "Image",
                    attributes = {
                      id = "Hex_Boarder",
                      image = "InvHex_Outline",
                      width = 1595,
                      height = 1488
                    }
                  },
                  {--Active Planet Nameplate
                    tag = "Image",
                    attributes = {
                      id = "Hex_FocusNameplate",
                      image = "FocusPlanet_Nameplate",
                      width = 626,
                      height = 96,
                      rectAlignment = "LowerCenter",
                      offsetXY = "0 188",
                      active = false
                    },
                    children = {
                      {
                        tag = "Text",
                        attributes = {
                          id = "Txt_HexFocusLabel",
                          text = "Mecatol Rex",
                          color = "White",
                          font = "TI4_Fonts/Handel_Gothic_D_Medium",
                          fontStyle = "Bold",
                          fontSize = 64,
                        }
                      }
                    }
                  },
                  {--Interactables root [6]
                    tag = "Panel",
                    attributes = {
                      id = "Pnl_InvasionHex_Interactables",
                    },
                    children = {
                      {--Bombardment Mode
                        tag = "Panel",
                        attributes = {
                          id = "Pnl_BombardmentMode",
                          width = 432,
                          height = 374,
                          offsetXY = "-644 378",
                          --color = "rgba(0.1 0.8 0.1 0.2)"
                        },
                        children = {
                          {--Hex Outline
                            tag = "Image",
                            attributes = {
                              id = "Img_BombModeOutline",
                              image = "Btn_InvasionSubstepHex",
                              --OnHover change sprite?
                            }
                          },
                          {--Label
                            tag = "Image",
                            attributes = {
                              id = "Img_BombMode_Label",
                              image = "Btn_BombardMode_Label"
                            }
                          },
                          {--Label Txt
                            tag = "Text",
                            attributes = {
                              text = "BOMBARDMENT",
                              color = "White",
                              font = "TI4_Fonts/Handel_Gothic_D_Medium",
                              fontStyle = "Bold",
                              fontSize = 42,
                              offsetXY = "0 -46",
                              horizontalOverflow = "Overflow",
                              verticalOverflow = "Overflow"
                            }
                          },
                        }
                      },
                      {--SpcDeff Mode
                        tag = "Panel",
                        attributes = {
                          id = "Pnl_SpaceCannonDefMode",
                          width = 432,
                          height = 374,
                          offsetXY = "644 378",
                          --color = "rgba(0.1 0.8 0.1 0.2)"
                        },
                        children = {
                          {--Hex Outline
                            tag = "Image",
                            attributes = {
                              id = "Img_SpcDefModeOutline",
                              image = "Btn_InvasionSubstepHex",
                              --OnHover change sprite?
                            }
                          },
                          {--Label
                            tag = "Image",
                            attributes = {
                              id = "Img_SpcDefMode_Label",
                              image = "Btn_SpaceCannonDefMode_Label"
                            }
                          },
                          {--Label Txt
                            tag = "Text",
                            attributes = {
                              text = "SPACE CANNON",
                              color = "White",
                              font = "TI4_Fonts/Handel_Gothic_D_Medium",
                              fontStyle = "Bold",
                              fontSize = 42,
                              offsetXY = "0 -46",
                              horizontalOverflow = "Overflow",
                              verticalOverflow = "Overflow"
                            }
                          }
                        }
                      },
                    }
                  },
                  {--Anomaly
                    tag = "Image",
                    attributes = {
                      id = "Hex_Anamoly",
                      image = "InvHex_Anomaly",
                      width = 1717,
                      height = 1489,
                      active = false
                    }
                  },
                }
              },
              {--Cover Rect
                tag = "Image",
                attributes = {
                  id = "Img_InvasionCoverRect",
                  image = "Background_Fill",
                  rectAlignment = "LowerCenter",
                  height = 1945,
                  width = 2048
                }
              },
              {--BackgroundCover_Header
                tag = "Image",
                attributes = {
                  id = "Img_InvasionCover",
                  image = "ZoneCover_Green",
                  preserveAspect = true,
                  offsetXY = "0 20",
                  rectAlignment = "UpperCenter",
                  --active = false
                },
                children = {
                  {--GhostMask
                    tag = "Image",
                    attributes = {
                      image = "Background_Fill",
                      height = 30,
                      offsetXY = "0 -120",-- -128 + 20 + 10
                      rectAlignment = "UpperCenter"
                    }
                  }
                }
              },
              {--HeaderCover
                tag = "Image",
                attributes = {
                  id = "Img_InvasionHeaderCover",
                  image = "HeaderCover",
                  preserveAspect = true,
                  rectAlignment = "UpperCenter",
                  offsetXY = "0 145",
                }
              },
            }
          },
        }
      },
      {--Footer Fade [6]
        tag = "Image",
        attributes = {
          id = "Img_FooterFade",
          image = "FooterFade",
          preserveAspect = true,
          rectAlignment = "LowerCenter",
        },
        children = {
          {--GhostMask
            tag = "Image",
            attributes = {
              id = "GhostMask_Footer",
              image = "Background_Fill",
              width = 2048,
              height = 16,
              offsetXY = "0 1020",
              rectAlignment = "LowerCenter",
            }
          }
        }
      },
      {--Invasion Label [7]
        tag = "Panel",
        attributes = {
          id = "Pnl_InvasionStep",
          height = 1980,
          width = 2048,
          rectAlignment = "LowerCenter",
        },
        children = {
          {--Main Button transform
            tag = "Image",
            attributes = {
              id = "BtnBounds_InvasionState",
              preserveAspect = true,
              image = "Btn_NoTactical",
              width = "1164",--"56.8%",
              height = "218",--"17%"
              rectAlignment = "UpperCenter",
            },
            children = {
              {--Btn Label
                tag = "Text",
                attributes = {
                  id = "Txt_InvasionState",
                  text = "INVASION",
                  color = "White",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  fontStyle = "Bold",
                  fontSize = 124,
                }
              }
            }
          },
        }
      },
      { --Turn display [8]
        tag = "Panel",
        attributes = {
          id = "Pnl_Turns",
          height = "55%",
          rectAlignment = "LowerCenter",
          active = false
        },
        children = {
          {--Turn alignment panel
            tag = "Panel",
            attributes = {
              id = "Pnl_TurnsTransform",
            },
            children = {
              {--Turn Color Panel
                tag = "Panel",
                attributes = {
                  id = "Pnl_TurnButtons",
                  width = "36.5%",--746.0/3
                  offsetXY = "106 0",--"10.0 0"
                  --color = "Pink",
                },
                children = {
                  {--ActivePlayer Label
                    tag = "Panel",
                    attributes = {
                      id = "Pnl_ActivePlayer",
                      rectAlignment = "LowerLeft",
                      height = 140,
                      width = 910,
                      active = false,
                    },
                    children = {
                      {--Active Bar
                        tag = "image",
                        attributes = {
                          id = "Turns_activePlayer",
                          image = "Turns_ActivePlayer",
                          rectAlignment = "MiddleCenter",
                          --preserveAspect = true,
                          color = "Grey",
                        }
                      },
                      {--Text
                        tag = "Text",
                        attributes = {
                          id = "Turns_activePlayerName",
                          text = " Active Player",
                          font = "TI4_Fonts/Handel_Gothic_D_Medium",
                          color = "White",
                          fontStyle = "Bold",
                          fontSize = 82,
                          resizeTextMaxSize = 102,
                          alignment = "MiddleLeft",
                          verticalOverflow = "Overflow",
                          horizontalOverflow = "Overflow"
                        }
                      }
                    }
                  },
                },
              },
              {--StratPanel
                tag = "Panel",
                attributes = {
                  id = "Pnl_StratIcons",
                  width = "32%",--106.0,
                  rectAlignment = "LowerLeft",
                  offsetXY = "80 0",--x: 106px dim - padding
                  --color = "Blue",
                },
                children = {}
              },
            }
          },
        }
      },
      {--Agenda Icon
        tag= "Image",
        attributes = {
          id = "icon_agenda",
          image = "Icon_Agenda",
          offsetXY = "0 -310",
          preserveAspect = true,
        }
      },
    }
   },
  },

  settings = {
    turns = {
      playerCount = 0,--runntime
      yOff = 25*7, yPadding = 25*7, yPadding_Passed = 10*7, pCountOff = 10*7, stratStackOff = -20*7,
      fontSize = 82,--48,
    },
  },

  --Used to work around TTS's anoying ui.show/hide and ui.active interation
  _showData = {},--{[btnID] = {}}

  stratAssignments = {},
  _batchChanges = {},
  _batchCo = false,

  eSubTxt = {
    ["FactionName"] = function() return "FactionName" end,
    ["NonActive"] = function() return "NonActive" end,--Not action phase
    ["Activate"] = function() return "Activate" end,
  }
}

--Active player != Turns.turn_color. The Tactician allows players to be "active" outside of their game turn
local ActivePlayer = {
  color = "Black",
  previous = "Black",
  faction = false,
  tokenName = false,
  system = false,
  prevSystem = false
}
ActivePlayer.update = function(color)
  if not color then color = Turns.enable and Turns.turn_color or "Grey" end

  local faction = _factionHelper.fromColor(color) or false
  ActivePlayer.faction = faction and faction.name or false
  ActivePlayer.tokenName = faction and faction.tokenName or false

  if ActivePlayer.color == color then return end
  ActivePlayer.previous = ActivePlayer.color
  ActivePlayer.color = color
  --ActivePlayer.system is not changed here
end

local data = { --misc data container
  --Runtime data
  activePassedTokens = {},
  stratObjs = false,
  stratCards = {
    ['Leadership'] = {i = 1, color = "Red", holder = "Grey"},
    ['Diplomacy'] = {i = 2, color = "Orange", holder = "Grey"},
    ['Politics'] = {i = 3, color = "Yellow", holder = "Grey"},
    ['Construction'] = {i = 4, color = "Green", holder = "Grey"},
    ['Trade'] = {i = 5, color = "Teal", holder = "Grey"},
    ['Warfare'] = {i = 6, color = "Blue", holder = "Grey"},
    ['Technology'] = {i = 7, color = "#1c477a", holder = "Grey"},
    ['Imperial'] = {i = 8, color = "Purple", holder = "Grey"},
    --Alternatives
    ['Diplomacy (Revised)'] = {i = 2, color = "Orange", holder = "Grey"},
    ['Industry'] = {i = 5, color = "Teal", holder = "Grey"},
    ['Trade (6)'] = {i = 6, color = "Blue", holder = "Grey"},
    ['Warfare (7)'] = {i = 7, color = "#1c477a", holder = "Grey"},
    ['Logistics'] = {i = 8, color = "Purple", holder = "Grey"},
    ['Technology (9)'] = {i = 9, color = "#9116c5", holder = "Grey"},
    ['Imperial (10)'] = {i = 10, color = "Pink", holder = "Grey"},
  },
  playableColors = {"White", "Red", "Orange", "Yellow","Green", "Blue", "Purple", "Pink", "Brown"},
}

data.isPlayerPassed = function(color)
  local function _getTokensObjs(returnCol)
    local objs = {}
    for _,eachObj in ipairs(getAllObjects()) do
      local name = eachObj.getName()
      local iStart, iEnd = string.find(name, "Active/Passed (", 1, true)
      if iStart then
        local color = string.sub(name, iEnd + 1, #name - 1)
        data.activePassedTokens[color] = eachObj
        data.activePassedTokens[eachObj] = color
      end
    end
    if returnCol then return data.activePassedTokens[returnCol] end
  end

  local token = data.activePassedTokens[color] or _getTokensObjs(color)
  return token and token.is_face_down or false
end

--Returns table of strat card names or nil
data.getPlayerStrats = function(color)
  if not _zoneHelper.zoneAttributes(color) then return end

  local result = {}
  for name,each in pairs(data.stratCards) do
    if each.holder() == color then table.insert(result, name) end
  end

  return next(result) and result or nil
end

data.initStratCards = function()
  local function getStrats()
    data.stratObjs = {}
    for _,eachObj in ipairs(getAllObjects()) do
      local name = eachObj.getName()
      if data.stratCards[name] then
        data.stratObjs[name] = eachObj
      end
    end
  end
  getStrats()

  for name, each in pairs(data.stratCards) do
    local function getHolder()
      if not data.stratObjs[name] then
        getStrats()
        if not data.stratObjs[name] then return "Grey" end --couldnt find object
      end
      return _zoneHelper.zoneFromPosition(data.stratObjs[name].getPosition()) or "Grey"
    end

    each.holder = getHolder
  end
end

--Public funcs------------------------------------------------------------------

--system highlighter highlights adjacent systems during the Movement step. Set enabled/disabled per player color
--params: {color = "", enabled = t/f, toggle = t/f} --use toggle OR enable (not both)
function setSystemHighlighter(params)
  assert(params.color and type(params.color) == "string")
  local toState = params.enabled or false
  if params.toggle then toState = not Tac.highlightAdjSystems[params.color] end
  Tac.highlightAdjSystems[params.color] = toState

  --update UI now?
  if Tac.State == Tac.eStates.Movement() and params.color == ActivePlayer.color then
    print("TODO: Set system highlighter btn in >setSystemHighlighter()<")
    if toState then
      _systemHelper.getAdjacentSystems({color = ActivePlayer.color, highlight = true})
    else
      _systemHelper.removeSystemHighlights()
    end
  end
end

--Moves the player's camera over to the Tactician
function lookAtMe(playerColor, _myPos)
  local player = playerColor and Player[playerColor]
  if not player or not player.seated then return end

  player.lookAt({
    position = _myPos or self.getPosition(),
    pitch    = 85,
    yaw      = self.getRotation().y - 180,
    distance = 20,
  })
end

--Moves the lookingPlayer's camera over to the lookTarget's play area
--params = {lookingPlayer = color, lookTarget = color}
function lookAtPlayer(params)
  assert(params and type(params) == "table")
  local lookingColor = assert(params.lookingPlayer or type(params[1]) == "string" and params[1], "Failed to assign a looking player")
  local lookingPlayer = Player[lookingColor]
  if not lookingPlayer or not lookingPlayer.seated then return end

  local targetColor = assert(params.lookTarget or type(params[2]) == "string" and params[2], "Failed to give a target to look at.")
  local function _getLookAt(color)
    local zones = _zoneHelper.zonesAttributes() or {}
    for _,each in ipairs(zones) do
      if each.color == color then
        local rotation = each.center.z >= 0 and 180 or 0
        return {each.center, rotation}
      end
    end
  end

  local lookData = assert(_getLookAt(targetColor), "The "..targetColor.." player does not have a zone.")

  lookingPlayer.lookAt({
    position = lookData[1],
    yaw = lookData[2],
    pitch = 80,
    distance = 35
  })
end

--UI----------------------------------------------------------------------------
ui.setSubheaderTxt = function(state)
  local switch = {
    ["FactionName"] = function() local txt = ActivePlayer.faction or ActivePlayer.color .. "\'S TURN" return string.upper(txt) end,
    ["NonActive"] = function() return "Set turns or activate a system" end,
    ["Activate"] = function() return "Activate a system to begin..." end
  }
  ui.batchSet("Txt_Subheader" ,{text = switch[state]()})
end
--{[btn_ID] = {smart = "attacker"/"defender"|nil, rollTarget = engagementType}}
ui.btnLookup = {}
local xmlIndex = {turns = 8, move = 3, SpC = 4, Inv = 5, InvLabel = 7, planets = 5}
ui.generateXML = function(callback)
  ui.onXmlInjected = callback

  --register show/hide animations
  ui.newShow("icon_agenda", {
    show = {
      params = {duration = 1.25},
      clip = uiClips.fadeIn,
      onStop = uiClips.revertFade
    },
    hide = {
      params = {duration = 1.25},
      clip = uiClips.fadeOut,
      onStop = uiClips.revertFade
    }
  })
  ui.newShow("Header_Gradient", {hide = {params = {duration = 2}, clip = uiClips.fadeOut, onStop = uiClips.revertFade}})
  ui.newShow("Header_Deco", {hide = {clip = uiClips.fadeOut, params = {duration = 2}, onStop = uiClips.revertFade}})
  ui.newShow("Header_GradientTransition", {show = {clip = uiClips.fadeIn, delay = 1.5, params = {duration = 1.45}, onStop = uiClips.revertFade}})
  ui.newShow("Header_DecoTransition", {show = {clip = uiClips.fadeIn, delay = 1.5, params = {duration = 1.45}, onStop = uiClips.revertFade}})
  ui.newShow("Header_ProgressMask", {active = false, hide = {uiClips.fadeOut, params = {duration = 0.25}, onStop = uiClips.revertFade}})
  ui.newShow("Img_FooterFade", {
    show = {
      clip = uiClips.fadeIn,
      delay = 0.2,
      params = {duration = 0.4},
      onStop = uiClips.revertFade
    },
    hide = {
      clip = uiClips.fadeOut,
      params = {duration = 0.4},
      onStop = function(id, params) uiClips.revertFade(id, params) ui.batchSet("GhostMask_Footer", {active = true}) end,
      onStart = function() ui.batchSet("GhostMask_Footer", {active = false}) end,
      onEnd = function() ui.batchSet("GhostMask_Footer", {active = true}) end
    },
  })
  ui.newShow("Img_FocusBanner", {
    active = false,
    show = {
      clip = uiClips.slideIn_Up,
      onStop = uiClips.revertSlide,
      params = {duration = 0.7, magnitude = {x = 0, y = -260}, padding = 1},
      delay = 0.1
    },
    hide = {
      clip = uiClips.slideOut_Down,
      onStop = uiClips.revertSlide,
      params = {duration = 0.15, magnitude = {x = 0, y = -100}, padding = 1, lerp = Tween.linear},
    }
  })

  local function turnUI()
    --Turn buttons
    local colIndex = data.playableColors
    for i = 1, 9, 1 do
      local xmlButton = {
        tag = "Button",
        attributes = {
          id = "Turns_" .. colIndex[i] .. "_inactive",
          transition = "SpriteSwap",
          image = "Turns_NonactivePlayer_Hover",--"Turns_NonactivePlayer",
          --sprite = "Turns_NonactivePlayer",
          highlightedSprite = "Turns_NonactivePlayer",--"Turns_NonactivePlayer_Hover",
          pressedSprite = "Turns_NonactivePlayer_Pressed",
          offsetXY = "0 " .. (i* ui.settings.turns.yPadding),
          height = "8%",
          rectAlignment = "LowerCenter",
          color = colIndex[i],
          preserveAspect = true,
          active = false,
          onClick = self.getGUID().."/onButtonClicked_LookAtPlayer"
        },
        children = {}
      }

      local btnTxt = {
        tag = "Text",
        attributes = {
          id = "Turns_" .. colIndex[i] .. "_Name",
          font = "TI4_Fonts/Handel_Gothic_D_Medium",
          text = "INACTIVE PLAYER",
          color = "White",
          fontStyle = "Bold",
          fontSize = ui.settings.turns.fontSize,
          resizeTextMaxSize = 102,
          alignment = "MiddleLeft",
          verticalOverflow = "Overflow",
          horizontalOverflow = "Overflow"
        }
      }
      table.insert(xmlButton.children, btnTxt)
      local passBar = {
        tag = "Image",
        attributes = {
          id = "Turns_PassedPlayer_" .. colIndex[i],
          image = "Turns_PassedPlayer",
          color = colIndex[i],
          rectAlignment = "LowerCenter",
          offsetXY = "0 " .. (i* ui.settings.turns.yPadding_Passed) + (8* ui.settings.turns.yPadding),
          preserveAspect = true,
          active = false
        }
      }

      ui.insertXml(xmlButton, "Pnl_TurnButtons")
      ui.insertXml(passBar, "Pnl_TurnButtons")
    end

    --Strategy cards
    for name,each in pairs(data.stratCards) do
        local stratCard = {
          tag = "Image",
          attributes = {
            id = "Icon_StratCard_" .. name,
            image = "StrategyCard_Icon",
            color = each.color,
            height = "8%",
            rectAlignment = "LowerRight",
            preserveAspect = true,
            active = false,
          },
          children = {}
        }
        local stratTxt = {
          tag = "Text",
          attributes = {
            id = "StratCard_Txt_" .. name,
            font = "TI4_Fonts/Handel_Gothic_D_Medium",
            text = each.i,
            color = "White",
            fontStyle = "Bold",
            fontSize = ui.settings.turns.fontSize,
            offsetXY = "-24 32",
            alignment = "LowerRight",
            resizeTextMaxSize = 128,
          }
        }
        if each.i == 1 then stratTxt.attributes.text = "1 " stratTxt.attributes.offsetXY = "-20 32" end
        table.insert(stratCard.children, stratTxt)
        ui.insertXml(stratCard, "Pnl_StratIcons")
    end
    local stratDeco = {
      tag = "Image",
      attributes = {
        id = "Icon_StratCardActive",
        image = "Turns_ActiveStrategy",
        preserveAspect = true,
        --offsetXY = "0 " .. (9*25) - (1*25),
        height = "8%",
        rectAlignment = "LowerRight",
      }
    }
    ui.insertXml(stratDeco, "Pnl_StratIcons")
  end
  turnUI()

  local function stepBtns()
    --Menu buttons
    local movementXML =
    {
      id = "Btn_MovementState",
      onIcon = "Btn_Blue_Active",
      onIcon_Hover = "Btn_Blue_Pressed",
      onIcon_Pressed = "Btn_Blue_Hover",
      onIcon_Disabled = "Btn_NoTactical",
      offIcon = "Btn_Blue",
      offIcon_Hover = "Btn_Blue_Hover",
      offIcon_Pressed = "Btn_Blue_Pressed",
      offIcon_Disabled = "Btn_NoTactical",
      attributes = { interactable = false},

      onClick = onButtonClicked_TacState,
    }
    local spaceCombatXML = {
      id = "Btn_SpaceCombatState",
      onIcon = "Btn_Red_Active",
      onIcon_Hover = "Btn_Red_Pressed",
      onIcon_Pressed = "Btn_Red_Hover",
      onIcon_Disabled = "Btn_NoTactical",
      offIcon = "Btn_Red",
      offIcon_Hover = "Btn_Red_Hover",
      offIcon_Pressed = "Btn_Red_Pressed",
      offIcon_Disabled = "Btn_NoTactical",
      attributes = { interactable = false},

      onClick = onButtonClicked_TacState,
    }
    local invasionXML = {
      id = "Btn_InvasionState",
      onIcon = "Btn_Green_Active",
      onIcon_Hover = "Btn_Green_Pressed",
      onIcon_Pressed = "Btn_Green_Hover",
      onIcon_Disabled = "Btn_NoTactical",
      offIcon = "Btn_Green",
      offIcon_Hover = "Btn_Green_Hover",
      offIcon_Pressed = "Btn_Green_Pressed",
      offIcon_Disabled = "Btn_NoTactical",
      attributes = { interactable = false},

      onClick = onButtonClicked_TacState,
    }
    local movementToggle = ToggleButton.newAsXmlTable(movementXML)
    local spaceCombatToggle = ToggleButton.newAsXmlTable(spaceCombatXML)
    local invasionToggle = ToggleButton.newAsXmlTable(invasionXML)
    ui.insertXml(movementToggle, "BtnBounds_MovementState", 1)
    ui.insertXml(spaceCombatToggle, "BtnBounds_SpaceCombatState", 1)
    ui.insertXml(invasionToggle, "BtnBounds_InvasionState", 1)
    ToggleButton.newGroup({name = "TacStep", members = {movementXML.id, spaceCombatXML.id, invasionXML.id}, activeLimit = 1})
  end
  stepBtns()

  local function rollBtns()
    --normalColor|highlightedColor|pressedColor|disabledColor
    local elements = {
      {id = "Btn_ConfirmMovement", width = "978", txt = "CONFIRM MOVEMENT", yOff = 170, parent = "Img_MovementBackground", target = "confirmMovement"},
      {id = "Btn_Roll_SpaceCannonOff", width = "705", txt = "SPACE CANNON", yOff = -160, parent = "Img_MovementBackground", target = "spaceCannonOff", smart = true},
      {id = "Btn_Roll_AFB", width = "288", txt = "AFB", yOff = 170, parent = "Img_SpaceCombatBackground", target = "antifighterBarrage", smart = true},
      {id = "Btn_Roll_SpaceCombat", width = "705", txt = "SPACE COMBAT", yOff = -160, parent = "Img_SpaceCombatBackground", target = "spaceCombat", smart = true},
      {id = "Btn_Roll_InvasionContext", width = "800", txt = "CONTEXT", yOff = -578, parent = "Pnl_InvasionHex_Interactables", target = "invasionContext", smart = true},
    }
    local smartSett = {
      width = 116, offset = 116 + 10,
      icon = {
        ["attacker"] = {icon = "Icon_Attacker", offsetXY = "0 0", width = 128.0, height = 64.0},
        ["defender"] = {icon = "Icon_Defender", offsetXY = "0 0", width = 64.0, height = 77.0}
      },
      image = {
        ["attacker"] = {main = "Btn_SmartAttack", hover = "Btn_SmartAttack_Hover", press = "Btn_SmartAttack_Pressed"},
        ["defender"] = {main = "Btn_SmartDefend", hover = "Btn_SmartDefend_Hover", press = "Btn_SmartDefend_Pressed"}
      },
    }

    local smartBtns = {
      {id = "SmartBtn_SpaceCombat_Att", parent = "Btn_Roll_SpaceCombat", target = "spaceCombat", attacker = true},
      {id = "SmartBtn_SpaceCombat_Def", parent = "Btn_Roll_SpaceCombat", target = "spaceCombat"},
      {id = "SmartBtn_AFB_Att",parent = "Btn_Roll_AFB", target = "antifighterBarrage", attacker = true},
      {id = "SmartBtn_AFB_Def", parent = "Btn_Roll_AFB", target = "antifighterBarrage"},
      {id = "SmartBtn_SpaceCannonOff_Att", parent = "Btn_Roll_SpaceCannonOff", target = "spaceCannonOff", attacker = true},
      {id = "SmartBtn_SpaceCannonOff_Def", parent = "Btn_Roll_SpaceCannonOff", target = "spaceCannonOff"},
      {id = "SmartBtn_InvasionContext_Att", parent = "Btn_Roll_InvasionContext", target = "invasionContext", attacker = true},
      {id = "SmartBtn_InvasionContext_Def", parent = "Btn_Roll_InvasionContext", target = "invasionContext"}
    }
    local sBtns = {}
    for _,each in ipairs(smartBtns) do
      local role = each.attacker and "attacker" or "defender"
      local  smarty = {
        tag = "Button",
        attributes = {
          id = each.id,
          active = false,
          transition = "SpriteSwap",
          image = smartSett.image[role].main,
          highlightedSprite = smartSett.image[role].hover,
          pressedSprite = smartSett.image[role].press,

          rectAlignment = each.attacker and "MiddleLeft" or "MiddleRight",
          width = smartSett.width,
          offsetXY = ""..(smartSett.offset * (each.attacker and -1 or 1)) .. " 0",
          color = each.attacker and "White" or "Grey",

          onClick = self.getGUID() .."/onSmartButtonClicked"
        },
        children = { --Token/shield icon
          {
            tag = "Image",
            attributes = {
              image = smartSett.icon[role].icon,
              width = smartSett.icon[role].width,
              height = smartSett.icon[role].height,
              offsetXY = smartSett.icon[role].offsetXY,
              raycastTarget = false
              --preserveAspect = true,
            }
          }
        }
      }
      ui.newShow(each.id, {
        active = false,
        isButton = true,
        show = {
          clip = each.attacker and uiClips.slideIn_Right or uiClips.slideIn_Left,
          delay = 0.65,
          params = {duration = 0.55, from = {x = smartSett.offset * (each.attacker and -1 or 1), y = 0}},
          onStop = uiClips.revertSlide --original position is not 0,0 so must include .from in params to reset image to the correct position
        },
        hide = {
          clip = each.attacker and uiClips.slideOut_Right or uiClips.slideOut_Left,
          params = {duration = 0.15, from = {x = smartSett.offset * (each.attacker and -1 or 1), y = 0}},
          onStop = uiClips.revertSlide
        }
      })
      sBtns[each.parent] = sBtns[each.parent] or {}
      table.insert(sBtns[each.parent], smarty)
      ui.btnLookup[each.id] = {smart = each.attacker and "attacker" or "defender", rollTarget = each.target}
    end

    for _,each in ipairs(elements) do
      local new = {--ButtonOutline
        tag = "Button",
        attributes = {
          id = each.id .. "_Outline",
          width = each.width + 24,
          height = 242,--"218" + 24(outline),
          colors = "#b0b0b0|#d1d0d0|White|White",
          active = false
        },
        children = {
          {--Button
            tag = "Button",
            attributes = {
              id = each.id,
              width = each.width,
              height = 218,
              colors = "#24242a|#26262a|#323235|#17171a",
              onClick = self.getGUID() .. "/onButtonClicked_MulitRoller()",
              active = false
            },
          },
          {--Label Txt
            tag = "Text",
            attributes = {
              id = each.id .. "_Txt",
              font = "TI4_Fonts/Handel_Gothic_D_Medium",
              text = each.txt,
              color = "White",
              fontStyle = "Bold",
              fontSize = 86,
              resizeTextMaxSize = 102,
              alignment = "MiddleCenter",
            }
          }
        }--
      }
      local root = {
        tag = "Panel",
        attributes = {
          id = each.id .. "_Root",
          width = each.width + 24,
          height = 242,--"218" + 24(outline),
          offsetXY = "0 " .. each.yOff,
          interactable = false,
        },
        children = {new},
      }
      if sBtns[each.id] then --Attach smart buttons
        for _, eachSmarty in ipairs(sBtns[each.id]) do
          table.insert(root.children,1, eachSmarty)
        end
      end

      ui.btnLookup[each.id] = {rollTarget = each.target}
      ui.insertXml(root, each.parent)
    end
  end
  rollBtns()

  local function invBtns()
    local smartBombard = {
      tag = "Button",
      attributes = {
        id = "SmartBtn_Bombardment",
        image = "Btn_SmartSubstep",
        highlightedSprite = "Btn_SmartSubstep_Hover",
        pressedSprite = "Btn_SmartSubstep_Pressed",
        transition = "SpriteSwap",
        color = "Grey", --dynamic
        rectAlignment = "LowerCenter",
        width = 331,
        height = 102,
        active = false,
        interactable = false,

        onClick = self.getGUID() .. "/onSmartButtonClicked_AutoResolve"
      },
      children = {
        {--Icon
          tag = "Image",
          attributes = {
            width = 128.0,
            height = 64.0,
            image = "Icon_Attacker"
          }
        }
      }
    }
    local smartPDS = {
      tag = "Button",
      attributes = {
        id = "SmartBtn_SpaceCannonDef",
        image = "Btn_SmartSubstep",
        highlightedSprite = "Btn_SmartSubstep_Hover",
        pressedSprite = "Btn_SmartSubstep_Pressed",
        transition = "SpriteSwap",
        color = "Grey", --dynamic
        rectAlignment = "LowerCenter",
        width = 331,
        height = 102,
        active = false,
        interactable = false,

        onClick = self.getGUID() .. "/onSmartButtonClicked_AutoResolve"
      },
      children = {
        {--Icon
          tag = "Image",
          attributes = {
            width = 64.0 *0.9,
            height = 77.0 *0.9,
            image = "Icon_Defender"
          }
        }
      }
    }
    ui.btnLookup["SmartBtn_Bombardment"] = {smart = "attacker", rollTarget = "bombardment"}
    ui.btnLookup["SmartBtn_SpaceCannonDef"] = {smart = "defender", rollTarget = "spaceCannonDef"}
    ui.insertXml(smartBombard, "Pnl_BombardmentMode", 1)
    ui.insertXml(smartPDS, "Pnl_SpaceCannonDefMode", 1)

    local bombMode_Toggle = {
      id = "Btn_BombardmentMode",
      onIcon = "Btn_BombardMode_Active",
      onIcon_Hover = "Btn_BombardMode_Pressed",
      onIcon_Pressed = "Btn_BombardMode_Hover",
      onIcon_Disabled = "Btn_BombardMode",
      offIcon = "Btn_BombardMode",
      offIcon_Hover = "Btn_BombardMode_Hover",
      offIcon_Pressed = "Btn_BombardMode_Pressed",
      offIcon_Disabled = "Btn_BombardMode",
      attributes = { active = false, interactable = false, rectAlignment = "UpperCenter", width = 420, height = 194},

      onClick = onButtonClicked_InvasionStep,
    }
    local spcDefMode_Toggle = {
      id = "Btn_SpaceCannonDefMode",
      onIcon = "Btn_SpaceCannonDefMode_Active",
      onIcon_Hover = "Btn_SpaceCannonDefMode_Pressed",
      onIcon_Pressed = "Btn_SpaceCannonDefMode_Hover",
      onIcon_Disabled = "Btn_SpaceCannonDefMode",
      offIcon = "Btn_SpaceCannonDefMode",
      offIcon_Hover = "Btn_SpaceCannonDefMode_Hover",
      offIcon_Pressed = "Btn_SpaceCannonDefMode_Pressed",
      offIcon_Disabled = "Btn_SpaceCannonDefMode",
      attributes = { active = false, interactable = false, rectAlignment = "UpperCenter", width = 420, height = 194},

      onClick = onButtonClicked_InvasionStep,
    }
    local bombModeBtn = ToggleButton.newAsXmlTable(bombMode_Toggle)
    local spcDefMode = ToggleButton.newAsXmlTable(spcDefMode_Toggle)
    ui.insertXml(bombModeBtn, "Pnl_BombardmentMode", 1)
    ui.insertXml(spcDefMode, "Pnl_SpaceCannonDefMode", 1)
    ToggleButton.newGroup({name = "InvSteps", members = {bombMode_Toggle.id, spcDefMode_Toggle.id}, activeLimit = 1})
  end
  invBtns()

  local function planets()
    for i = 1, 5, 1 do
      local _id = "p"..i
      local planet = {
        tag = "Panel",
        attributes = {
          id = _id,
          width = 452.0,
          height = 452.0,
          scale = "1 1 1",
          active = false
        },
        children = {
          {--PButton/OwnerIndicator
            tag = "Button",
            attributes = {
              id = _id .. "_ColorRing",
              image = "Wired_Color",
              color = "White", --dynamic
              transition = "SpriteSwap",
              highlightedSprite = "Wired_Color_Hover",
              pressedSprite = "Wired_Color_Pressed",
              interactable = false,
              active = false,

              onClick = self.getGUID().."/onPlanetButtonClicked("..i..")"
            }
          },
          {--Planet
            tag = "Image",
            attributes = {
              id = _id .."_Planet",
              image = "Wired_Planet", --dynamic
            }
          },
          {--HS highlight
            tag = "Image",
            attributes = {
              id = _id.."_HS",
              image = "Wired_Highlight",
              color = "White", --dynamic
              active = false
            }
          },
          { --Planetary Shield
            tag = "panel",
            attributes = {
              id = _id.."shieldRoot",
              offsetXY = "180 120"--"357 265",
            },
            children = {
              {--Shield image parent
                tag = "panel",
                attributes = {
                  id = _id .. "_shieldTransform",
                  offsetXY = "0 -8",
                  rotation = "0 0 12",
                  raycastTarget = false,
                },
                children = {
                  { --Active Shield
                    tag = "image",
                    attributes = {
                      id = _id.."_ShieldEnabled",
                      image = "PlanetaryShield_Enabled",
                      raycastTarget = false,
                      active = false
                    }
                  },
                  { --Disabled Shield
                    tag = "image",
                    attributes = {
                      id = _id.."_ShieldDisabled",
                      image = "PlanetaryShield_Disabled",
                      raycastTarget = false,
                      active = false
                    }
                  },
                }
              },
              { --Override button
                tag = "button",
                attributes = {
                  id = _id.."_Btn_shieldOverride",
                  width = 128.0 * 0.7,
                  height = 128.0 * 0.7,

                  transition = "SpriteSwap",
                  sprite = "Btn_PShield_NoOverride",
                  highlightedSprite = "Btn_PShield_Disable_Dark",
                  pressedSprite = "Btn_PShield_Disable",
                  disabledSprite = "Btn_PShield_NoOverride",
                  onClick = self.getGUID() .. "/onButtonClicked_PShieldOverride",

                  active = false,
                  interactable = false,
                }
              }
            }
          },
          {--Nameplate
            tag = "Image",
            attributes = {
              id = _id .. "_Nameplate",
              image = "Wired_Nameplate",
              offsetXY = "0 " .. -128,
              width = 456,
              preserveAspect = true
            },
            children = {--Txt
              {
                tag = "Text",
                attributes = {
                  id = _id.."_Txt",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  text = "NAME",
                  color = "White",
                  fontStyle = "Bold",
                  fontSize = 44,
                  resizeTextMaxSize = 54,
                  alignment = "MiddleCenter",
                  offsetXY = "0 " .. 6
                }
              }
            }
          },
          {--QuickBomb
            tag = "Button",
            attributes = {
              id = _id .."_QuickBombard",
              image = "QuickBtn_Bombardment",
              highlightedSprite = "QuickBtn_Bombardment_Hover",
              pressedSprite = "QuickBtn_Bombardment_Pressed",
              transition = "SpriteSwap",
              width = 128.0 * 0.85,
              height = 106.0 * 0.85,--112
              onClick = self.getGUID().. "/onQuickRollBombardment()",
              offsetXY = "".. -221 .." ".. (-62 * 0.8),
              interactable = false,
              active = false,
            }
          },
          {--QuickPDS
            tag = "Button",
            attributes = {
              id = _id .."_QuickPDS",
              image = "QuickBtn_PDS",
              highlightedSprite = "QuickBtn_PDS_Hover",
              pressedSprite = "QuickBtn_PDS_Pressed",
              transition = "SpriteSwap",
              width = 128.0 * 0.85,
              height = 106.0 * 0.85,
              onClick = self.getGUID().. "/onQuickRollSpaceCannonDef()",
              offsetXY = "".. 221 .." "..(-62 * 0.8),
              interactable = false,
              active = false,
            }
          },
          {--PlasmaScoring
            tag = "Button",
            attributes = {
              id = _id.."_Btn_PlasmaScoring",
              width = 128.0 * 0.6,
              height = 128.0 * 0.6,
              --height = 106.0 * 0.6,--112
              offsetXY = "".. -143 .." ".. (-62 * 0.1),

              transition = "SpriteSwap",
              sprite = "Icon_PlasmaScoring",
              --highlightedSprite = "Icon_PlasmaScoring_Hover",
              pressedSprite = "Icon_PlasmaScoring_Active",
              disabledSprite = "Icon_PlasmaScoring",

              isOn = false,
              active = false,
              interactable = false,
              onClick = self.getGUID().. "/onPlasmaTargetSelected()",
            },
          },
          {--traitIcon
            tag = "Image",
            attributes = {
              id = _id.."_Trait",
              image = "Icon_Cultural",
              offsetXY = "0 " .. Planets.traits.data.offset,
              width = "152",
              preserveAspect = true,
              active = false,
            }
          }
        }
      }
      ui.newShow(_id.."_ShieldEnabled", {
        active = false,
        show = {
          clip = uiClips.grow,
          params = {duration = 0.6},
          onStop = uiClips.revertScale
        },
        hide = {
          clip = uiClips.fadeOut,
          params = {duration = 0.6},
          onStop = uiClips.revertFade
        }
      })
      ui.newShow(_id.."_ShieldDisabled", {
        active = false,
        show = {
          clip = uiClips.fadeIn,
          params = {duration = 0.4},
          onStop = uiClips.revertFade
        },
        hide = {
          clip = uiClips.fadeOut,
          params = {duration = 0.4},
          onStop = uiClips.revertFade
        }
      })
      ui.insertXml(planet, "Pnl_InvasionHex_Lower")
      PShield.status[i] = {enabled = 0, override = 0, visible = 0, hasShield = false}
    end
  end
  planets()
end

--optional params = {show, hide, active, isButton}
    --params.show/hide = {clip = coroutine(uiClip.someClip), delay = #(time), params = table(passed to clip), onStop = function(revert changes to initial state), onStart = func(id, params, isInDelay)}
ui.newShow = function(elementID, params)
  params = params or {}
  params.show = params.show or {}
  params.hide = params.hide or {}
  ui._showData[elementID] = ui._showData[elementID] or
    {
      isAnimating = 0,
      inDelay = false,
      isButton = params.isButton,
      showState = params.active == nil and true or params.active
    }
  local data = ui._showData[elementID]

  data.showDelay = params.show.delay or false
  data.showClip = params.show.clip or false
  data.onStartShow = params.show.onStart or false
  data.onStopShow = params.show.onStop or false
  data.onEndShow = params.show.onEnd or false
  data.show = function(id, callback, showParams)
    local _data = ui._showData[id]
    local function animateShow(completionCode)
      _data.inDelay = false
      if completionCode == -1 then return end --coroutine/show was cancelled
      if _data.onStartShow then _data.onStartShow(id, showParams) end
      local function onAnimComplete()
        if _data.onEndShow then _data.onEndShow(id, showParams) end
        if callback then callback() end
      end
      if _data.showClip then
        local co = _data.showClip(id, showParams)
        _data.runningAnimation = co
        Coru.run(co, {callback = onAnimComplete})
      else
        ui.batchSet(id, {active = true})
        onAnimComplete()
      end
    end
    _data.showState = true
    if _data.showDelay then
      _data.inDelay = true
      _data.isAnimating = 1
      _data.runningAnimation = Coru.wait(_data.showDelay, animateShow)
      if _data.onStartShow then _data.onStartShow(id, showParams, true) end
    else
      animateShow()
    end
  end
  data.stopShow = function(id, stopParams)
    local _data = ui._showData[id]
    if _data.runningAnimation then
      Coru.stop(_data.runningAnimation)
    end

    --onStopShow should undo any changes to the ui done by the show coroutine (like resetting opacity)
    if not _data.inDelay and _data.onStopShow then --If the show never made it out of the delay, there is nothing to undo
      _data.onStopShow(id, stopParams)
    end

    _data.inDelay = false
    _data.isAnimating = 0
    self.UI.setAttribute(id, "active", false)
  end

  data.hideDelay = params.hide.delay or false
  data.hideClip = params.hide.clip or false
  data.onStartHide = params.hide.onStart or false
  data.onStopHide = params.hide.onStop or false
  data.onEndHide = params.hide.onEnd or false
  data.hide = function(id, callback, hideParams)
    local _data = ui._showData[id]
    local function animateHide(completionCode)
      _data.inDelay = false
      if completionCode == -1 then return end
      if _data.onStartHide then _data.onStartHide(id, hideParams) end
      local function onAnimComplete()
        if _data.onEndHide then _data.onEndHide(id, hideParams) end
        if callback then callback() end
      end

      if _data.hideClip then
        local co = _data.hideClip(id, hideParams)
        _data.runningAnimation = co
        Coru.run(co, {callback = onAnimComplete})
      else
        ui.batchSet(id, {active = false})
        onAnimComplete()
      end
    end

    _data.showState = false
    if _data.hideDelay then
      _data.inDelay = true
      _data.isAnimating = -1
      _data.runningAnimation = Coru.wait(_data.hideDelay, animateHide)
      if _data.onStartHide then _data.onStartHide(id, hideParams, true) end
    else
      animateHide()
    end
  end
  data.stopHide = function(id, stopParams)
    local _data = ui._showData[id]
    if _data.runningAnimation then
      Coru.stop(_data.runningAnimation)
    end

    if not _data.inDelay and _data.onStopHide then
      _data.onStopHide(id, stopParams)
    end

    _data.inDelay = false
    _data.isAnimating = 0
    self.UI.setAttribute(id, "active", true)
  end

  data.showParams = params.show.params or {}
  data.hideParams = params.hide.params or {}
end

ui.show = function(elementID, skipAnimation, callback, overrides)
  ui.setShowing(elementID, true, skipAnimation, callback, overrides)
end

ui.hide = function(elementID, skipAnimation, callback, overrides)
  ui.setShowing(elementID, false, skipAnimation, callback, overrides)
end

ui.setShowing = function(elementID, toState, skipAnimation, callback, overrides)
  --print("\nsetShowing: ", elementID, " -> ", toState)
  if not ui._showData[elementID] then
    --print("Missing show data for ", elementID)
    ui.batchSet(elementID, {active = toState})
    if callback then callback() end
    return
  end

  overrides = overrides or {}
  local animData = ui._showData[elementID]
  if animData.showState == toState then --don't replay animations
    --print(elementID," is already ", toState and "showing" or "hiding")
    if callback then callback() end return
  end
  local passParams = toState and (animData.showParams or {}) or animData.hideParams or {}

  if animData.isAnimating ~= 0 then --If the element is currently animating, stop that animation
    --print("Stopping animation: ", elementID, " ", animData.isAnimating)
    local stop = animData.isAnimating == 1 and animData.stopShow or animData.stopHide
    stop(elementID, passParams)
  end

  if Tac.disableAnimations or skipAnimation or (toState and not animData.show) or (not toState and not animData.hide) then
    animData.showState = toState
    animData.isAnimating = 0
    ui.batchSet(elementID, {active = toState})
    if callback then callback() end
    return
  end

  if next(overrides) then
    passParams = copyTable(passParams)
    for k,v in ipairs(overrides) do
      passParams[k] = v
    end
  end

  animData.showState = toState
  if toState then
    --print("Showing ", elementID,"...")
    animData.isAnimating = 1
    local function onComplete(stopCode)
      animData.isAnimating = 0
      if stopCode == -1 then return end --was the animation cancelled?
      if animData.isButton then ui.batchSet(elementID, {interactable = true}) end
      if callback then callback() end
    end
    animData.show(elementID, onComplete, passParams)
  else
    --print("Hiding ", elementID,"...")
    animData.isAnimating = -1
    local function onComplete(stopCode)
      animData.isAnimating = 0
      if stopCode == -1 then return end --was the animation cancelled?
      if animData.isButton then ui.batchSet(elementID, {active = false, interactable = false}) end
      if callback then callback() end
    end
    animData.hide(elementID, onComplete, passParams)
  end
end

ui._inserts = {}--{ [parent] = {{xml = element, i = insertIndex}}}
ui._waitingInsert = false
ui.onXmlInjected = false
ui.insertXml = function(xml, parentID, index)
  local function resolve()
    ui._waitingInsert = false

    local function insert(tbl, pID)
      for _, each in ipairs(ui._inserts[pID]) do
        if each.i then
          table.insert(tbl, each.i, each.xml)
        else
          table.insert(tbl, each.xml)
        end
      end
      ui._inserts[pID] = nil
    end

    local function recursiveSearch(table)
      if not table.children then return end --assume I put an empty children {} table in the xml

      for _, each in ipairs(table.children) do
        if ui._inserts[each.attributes.id] then
          insert(each.children, each.attributes.id)
          if not next(ui._inserts) then return end
        end
        if each.children then recursiveSearch(each) end
      end
    end

    recursiveSearch(ui.xmlTable[1])
    if ui.onXmlInjected then
      ui.onXmlInjected()
      ui.onXmlInjected = false
    end
  end

  --Wait to gather all insert requests then resolve in 1 pass
  if not ui._waitingInsert then ui._waitingInsert = Wait.frames(resolve, 1) end
  ui._inserts[parentID] = ui._inserts[parentID] or {}
  table.insert(ui._inserts[parentID], {xml = xml, i = index})
end

ui.batchSet = function(uid, deltaTable)
  ui._batchChanges[uid] = ui._batchChanges[uid] or {}
  for k,v in pairs(deltaTable) do
    ui._batchChanges[uid][k] = v
  end

  if not ui._batchCo then
    ui._batchCo = coroutine.create(function()
      local extraFrames = 0
      while(next(ui._batchChanges) or extraFrames <= 5) do --keep the coroutine alive for a few frames after the current batch is completed
        extraFrames = extraFrames + 1
        if(next(ui._batchChanges)) then
          while(self.UI.loading) do coroutine.yield(0) end
          for uid,changeTable in pairs(ui._batchChanges) do
            self.UI.setAttributes(uid, changeTable)
          end
          ui._batchChanges = {}
          extraFrames = 0 --reset delay
        end
        coroutine.yield(0)
      end
      ui._batchCo = false
    end)
    Coru.run(ui._batchCo)
  end
end

ui.onStratDrop = function(obj)
  if Tac.State ~= Tac.eStates.Turns() then return end
  local name = obj.getName()
  if not data.stratCards[name] then return end

  local landingZone = data.stratCards[name].holder()
  if ui.stratAssignments[name] ~= landingZone then
    ui.setTurnUI(true)
  end
end

ui.setTurnUI = function(enabled)
  if not enabled then
    ui.batchSet("Pnl_Turns", {["active"] = false})
    return
  end

  local zoneColors = _zoneHelper.zones()
  if not zoneColors then return end
  local playerData = {} --contains: color, faction, passed, stratCards, seat, trunOrder
  for seat,color in ipairs(zoneColors) do
    local factionTable = _factionHelper.fromColor(color)
    playerData[color] = {
      faction = factionTable and factionTable.tokenName or false,
      passed = data.isPlayerPassed(color),
      stratCards = data.getPlayerStrats(color),
      seat = seat,
      color = color
    }
  end

  local turnOrder = Turns.order
  local nextTurn = 1
  for i,eachCol in ipairs(turnOrder) do --turnOrder may hold unseated/unplayable colors
    if playerData[eachCol] then
      playerData[eachCol].turnOrder = nextTurn
      playerData[nextTurn] = eachCol
      nextTurn = nextTurn + 1
    end
  end
  --printTable(playerData)

  --Turn off all elements first, then turn on only the needed ones
  for _,eachCol in ipairs(data.playableColors) do
    ui.batchSet("Turns_".. eachCol .."_inactive", {["active"] = false})
    ui.batchSet("Turns_PassedPlayer_".. eachCol, {["active"] = false})
  end
  for name,each in pairs(data.stratCards)do
    ui.batchSet("Icon_StratCard_" .. name, {["active"] = false})
    ui.stratAssignments[name] = "Grey"
  end
  ui.batchSet("Icon_StratCardActive",{["active"] = false})
  ui.batchSet("Pnl_ActivePlayer", {active = false})

  local pCount = #turnOrder
  local runningOffset = 0
  for i = pCount, 1, -1 do
    local p = playerData[playerData[i]]--dataFromTurnPosition
    local off = 0
    if not p then goto continue end

    off = p.passed and ui.settings.turns.yPadding_Passed or ui.settings.turns.yPadding
    runningOffset = runningOffset + off

    ui.batchSet("Turns_".. p.color .."_inactive", {["active"] = Turns.turn_color ~= p.color and not p.passed, ["offsetXY"] = "0 ".. runningOffset})
    ui.batchSet("Turns_PassedPlayer_".. p.color, {["active"] = p.passed, ["offsetXY"] = "0 ".. runningOffset + (15 * 7)})
    ui.batchSet("Turns_" .. p.color .. "_Name", {text = " " .. (p.faction or p.color)}) --["offsetXY"] = "0 ".. (runningOffset*4),
    if Turns.turn_color == p.color and not p.passed then
      ui.batchSet("Pnl_ActivePlayer", {active = true, offsetXY = "0 ".. (runningOffset)})
      ui.batchSet("Turns_activePlayer", {color = p.color})
      local displayName = p.faction or p.color
      ui.batchSet("Turns_activePlayerName", {text = " "..displayName, fontSize = #displayName < 20 and ui.settings.turns.fontSize or (ui.settings.turns.fontSize - 8)})
    end

    if p.stratCards then
      for _,strat in ipairs(p.stratCards) do
        ui.stratAssignments[strat] = p.color
      end
      if not p.passed then
        --Order strategy cards by initative
        local initList = {}
        for _,eachStrat in ipairs(p.stratCards) do
          for i,each in ipairs(initList) do
            if data.stratCards[eachStrat].i < data.stratCards[eachStrat].i then
              table.insert(initList, i, eachStrat)
              break
            end
          end
          table.insert(initList, eachStrat)
        end

        --iterate through cards -> highest init to lowest which sets them right to left (Lowest leading)
        local sCount = #initList
        for i = sCount, 1, -1 do
          ui.batchSet("Icon_StratCard_" .. initList[i],
            {
              active = true,
              offsetXY = "" .. ui.settings.turns.stratStackOff * (sCount - i) .. " " .. runningOffset,
              color = data.stratObjs[initList[i]].is_face_down and "Grey" or data.stratCards[initList[i]].color
            })
        end
        if Turns.turn_color == p.color then
          ui.batchSet("Icon_StratCardActive",{
            ["active"] = true,
            ["color"] = data.stratCards[initList[1]].color,
            ["offsetXY"] = "" .. ui.settings.turns.stratStackOff * (sCount - 1) .. " ".. runningOffset})
        end
      end
    end

    ::continue::
  end


  ui.batchSet("Pnl_TurnsTransform", {["offsetXY"] = "0 " .. ((8*ui.settings.turns.yPadding) - runningOffset)/2.0})--Move up to keep centered
  ui.batchSet("Pnl_Turns", {["active"] = true})
  ui.hide("icon_agenda")
end

ui.animateHeaderColor = function(toColor, callback)
  local co = coroutine.create(function()
    --self.UI.setAttributes("Header_ProgressMask", {active = true, width = 5})
    ui.batchSet("Header_ProgressMask", {width = 6, color = XML.rgbaFromName(toColor)})
    ui.batchSet("Header_GradientTransition", {active = false, color = XML.rgbaFromName(toColor, "Header_GradientTransition")})
    ui.batchSet("Header_DecoTransition", {active = false, color = XML.rgbaFromName(toColor, "Header_DecoTransition")})
    coroutine.yield(0)
    ui.show("Header_ProgressMask")
    ui.show("Header_DecoTransition")
    ui.show("Header_GradientTransition")
    ui.hide("Header_Deco")
    ui.hide("Header_Gradient")
    local p = 0
    local t1 = Time.time

    while(p < 1) do
      local val = Tween.easeIn(p) * 2030--296
      ui.batchSet("Header_ProgressMask",{width = val})
      coroutine.yield(p)
      p = (Time.time - t1)/3
    end
    coroutine.yield(1)
    ui.setHeaderColor(toColor)
  end)

  Tac.color = toColor
  Coru.run(co, {callback = callback})
end

ui.setHeaderColor = function(color)
  local toColor = color or ActivePlayer.color
  Tac.color = toColor

  ui.hide("Header_ProgressMask")
  ui.batchSet("Header_ColorProgress", {color = XML.rgbaFromName(toColor, "Header_ColorProgress"), active = true})
  ui.batchSet("Header_Gradient", {color = XML.rgbaFromName(toColor, "Header_Gradient"), active = true})
  ui.batchSet("Header_Deco", {color = XML.rgbaFromName(toColor, "Header_Deco"), active = true})
  ui.hide("Header_GradientTransition")
  ui.hide("Header_DecoTransition")
  ui.show("Header_Gradient")
  ui.show("Header_Deco")
end

ui._activeTacStep = false
ui._TacStepAnimation = false
--params: all optional- stepName defaults to the currently open step
--params = {disable = false, skipAnimation = false, callback = nil}
ui.setTacStep = function(stepName, params)
  params = params or {}
  params.skipAnimation = Tac.disableAnimations or params.skipAnimation
  local function tryCallback() if params.callback then params.callback() end end

  stepName = stepName or ui._activeTacStep
  if not stepName then return tryCallback() end
  local open = params.disable ~= true
  if (open and ui._activeTacStep == stepName) or (not open and ui._activeTacStep ~= stepName)then return tryCallback() end
  local switch = {--step name to ui id
    ["Movement"] = {
      stateBtn = "Btn_MovementState",
      cover = "Img_MovementCover",
      panel = "Pnl_MovementStep_Active",
      lower = {"SpaceCombat", "Invasion"},
      labels = {"BtnBounds_SpaceCombatState", "BtnBounds_InvasionState"},
      footer = "Img_MovementFooterCover",
      --These buttons seem to be clickable while their parent is not active, even tho they are invisible, so manually setting intereactable = false
      childButtons = {"Btn_ConfirmMovement_Outline", "Btn_ConfirmMovement", "Btn_Roll_SpaceCannonOff", "Btn_Roll_SpaceCannonOff_Outline", "SmartBtn_SpaceCannonOff_Att", "SmartBtn_SpaceCannonOff_Def"}
    },
    ["SpaceCombat"] = {
      stateBtn = "Btn_SpaceCombatState",
      cover = "Img_SpaceCombatCover",
      panel = "Pnl_SpaceCombatStep_Active",
      lower = {"Invasion"},
      labels = {"BtnBounds_InvasionState"},
      footer = "Img_SpaceCombatFooterCover",
      childButtons = {"Btn_Roll_AFB", "Btn_Roll_AFB_Outline","Btn_Roll_SpaceCombat_Outline", "Btn_Roll_SpaceCombat", "SmartBtn_SpaceCombat_Att", "SmartBtn_SpaceCombat_Def", "SmartBtn_AFB_Att", "SmartBtn_AFB_Def"}
    },
    ["Invasion"] = {
      stateBtn = "Btn_InvasionState",
      cover = "Img_InvasionCover",
      panel = "Pnl_InvasionStep_Active",
      lower = {},
      labels = {},
      --footer = "",
      childButtons = {"Btn_BombardmentMode", "Btn_SpaceCannonDefMode", "SmartBtn_SpaceCannonDef", "SmartBtn_Bombardment",
                      "Btn_Roll_InvasionContext", "Btn_Roll_InvasionContext_Outline", "SmartBtn_InvasionContext_Att","SmartBtn_InvasionContext_Def"}
    }
  }
  if ui._TacStepAnimation then Coru.stop(ui._TacStepAnimation) ui._TacStepAnimation = false end
  ui._activeTacStep = open and stepName or false
  if stepName == "Invasion" then --Stripping this out into its own func since the animation is so different
    ui.setInvasionStep(params) return
  end
  local data = assert(switch[stepName])

  local setDisplay = coroutine.create(function()
    --Pre animation
    -----------------------------------------------------------
    self.UI.setAttribute(data.panel, "active", true)--this needs to happen now, so don't batch
    coroutine.yield(0) coroutine.yield(0) coroutine.yield(0) --give the ui plenty of time to load before editing its child elements
    ToggleButton.setState(ToggleButton.btns[data.stateBtn], open)
    --turn lower panels off
    for _, each in ipairs(data.lower) do
      ui.batchSet(switch[each].panel, {active = false})
    end
    --Set childrenButtons interactable/active
    if open then --enable child buttons
      for _, each in ipairs(data.childButtons) do
        ui.batchSet(each, {interactable = true})
      end
      coroutine.yield(0)
      for _, each in ipairs(data.childButtons) do
        ui.show(each, params.skipAnimation)
      end
    end

    local pos = open and -1120 or 0
    local coverOffset = 20
    local labelGap = 280 - 60 --dist + coverOffset
    local labelOffset = open and labelGap or 0

    --Post animation
    -----------------------------------------------------------
    local function onAnimComplete(completeCode)
      ui._TacStepAnimation = false
      if completeCode == -1 then return end

      ui.batchSet(data.cover, {offsetXY = "0 " .. (pos + coverOffset), active = true})
      for _,each in ipairs(data.labels) do
        ui.batchSet(each, {offsetXY = "0 " .. (pos + labelOffset)})
      end
      for _, each in ipairs(data.childButtons) do
        ui.batchSet(each, {interactable = open})
        ui.setShowing(each, open, params.skipAnimation)
      end
      --Set footer
      ui.batchSet(data.footer, {active = not open})

      --keep all masks on if no step is open
      if not open then
        for eachStep,data in pairs(switch) do
          ui.batchSet(data.panel, {active = true})
        end
      end

      tryCallback()
    end

    if params.skipAnimation then
      onAnimComplete()
    else
      --Animate
      -----------------------------------------------------------
      local duration = open and 0.75 or 0.5
      local t1 = Time.time
      local delta = 1120
      local footerSet = false
      local labelSet = false
      ui._TacStepAnimation = coroutine.create(function()
        if not open then --play hide animations for smart buttons as window closes
          for _, each in ipairs(data.childButtons) do
            if ui._showData[each] then --only play hide animations, dont hide other elements
              ui.hide(each)
            end
          end
        end
        --open/close window
        while Time.time - t1 <= duration do
          local percent = (Time.time - t1)/duration
          local next = Tween.lerp(0, delta, Tween.easeOut(percent))
          next = open and -next or -(delta - next)
          ui.batchSet(data.cover, {offsetXY ="0 " .. (coverOffset + next)})

          --Move labels with gap/delay
          if next + labelGap <= 0 then
            for _,each in ipairs(data.labels) do
              ui.batchSet(each, {offsetXY = "0 " .. (next + labelGap)})
            end
          elseif not labelSet then
            --When the labels reach their approximate final position, set it to the real final pos
            --Fixes image jumping when 'next' changes alot between frames. (frame1_next + gap) = -1 ...--> (frame2_next + gap) = 5 (pixel jump of 6)
            labelSet = true
            for _,each in ipairs(data.labels) do
              ui.batchSet(each, {offsetXY = "0 0"})
            end
          end

          if not footerSet and ((open and percent >= 0.7) or (not open and percent >= 0.1)) then
            footerSet = true
            ui.batchSet(data.footer, {active = not open})
          end

          coroutine.yield(percent)
        end
        return 1
      end)
      Coru.run(ui._TacStepAnimation, {callback = onAnimComplete})
    end
  end)
  Coru.run(setDisplay)
end

--dont call directly, child func on setTacStep
ui.setInvasionStep = function(params)
  params = params or {}
  local open = params.disable ~= true
  ui._activeTacStep = open and "Invasion" or false

  --Pre animation
  ui.batchSet("Pnl_InvasionStep_Active", {active = true})
  ui.batchSet("Hex_ActivePlayer", {color = ActivePlayer.color})
  ToggleButton.setState(ToggleButton.btns["Btn_InvasionState"], open)
  local delta = 1945
  local headerOff = 20
  local headerMax = 1815
  local rectMin = 5


  if open then
    ui.hide("Img_FooterFade")
    Invasion.setActive(true)
  else
    ui.show("Img_FooterFade")
  end

  --Post animation
  local function onAnimComplete()
    ui._TacStepAnimation = false
    ui.batchSet("Img_InvasionCoverRect", {height = rectMin+ (open and 0 or delta)})
    ui.batchSet("Img_InvasionCover", {active = true, offsetXY = "0 " .. headerOff + (open and -headerMax or 0)})
    Invasion.setActive(open)

    if params.callback then params.callback() end
  end

 if params.skipAnimation then
   onAnimComplete()
 else
   --Animate
   -------------------------------------------
   local duration = open and 0.9 or 0.75
   local t1 = Time.time

   ui._TacStepAnimation = coroutine.create(function()
     while Time.time - t1 <= duration do
       local percent = (Time.time - t1)/duration
       local pos = Tween.lerp(0, delta, Tween.easeOut(percent))
       --pos = open and -pos or -(delta - next)
       ui.batchSet("Img_InvasionCoverRect", { height = rectMin + (open and delta - pos or pos)})
       --Constrain how far the header can open
       pos = (open and pos > headerMax) and headerMax or pos
       ui.batchSet("Img_InvasionCover", {offsetXY = "0 " .. headerOff + (open and -pos or (pos - delta))})

       coroutine.yield(percent)
     end
     return 1
   end)
   Coru.run(ui._TacStepAnimation, {callback = onAnimComplete})
 end
end

ui.enableTacStepButtons = function(enabled)
  local bool = enabled and true or false
  ui.batchSet("Btn_SpaceCombatState", {interactable = bool})
  ui.batchSet("Btn_MovementState", {interactable = bool})
  ui.batchSet("Btn_InvasionState", {interactable = bool})
end

ui.setSmartButtonColors = function(setDefenders, setBoth)
  if setDefenders then
    local defenderBtns = {"SmartBtn_SpaceCombat_Def", "SmartBtn_AFB_Def"}
    for _,each in ipairs(defenderBtns) do
      ui.batchSet(each, {color = MultiRoller.getDefender("Space")})
    end

    ui.batchSet("SmartBtn_InvasionContext_Def", {color = Planets.getFocusOrSoloOwner() or "Grey"})
    if not setBoth then return end
  end

  local attackerBtns = {"SmartBtn_SpaceCannonOff_Att", "SmartBtn_SpaceCombat_Att", "SmartBtn_AFB_Att", "SmartBtn_Bombardment"}
  for _,each in ipairs(attackerBtns) do
    ui.batchSet(each, {color = ActivePlayer.color})
  end
end

--Main--------------------------------------------------------------------------
--optional params: color (defaults to ActivePlayer.color), skipAnimation = bool, callback
Tac.setColor = function(params)
  params = params or {}
  params.skipAnimation = params.skipAnimation or Tac.disableAnimations

  local toColor = params.color or ActivePlayer.color
  if ActivePlayer.color ~= toColor then ActivePlayer.update(toColor) end
  local function tryCallback()
    if params.callback then params.callback() end
  end
  if toColor == Tac.color then tryCallback() return end
  Tac.color = toColor

  if params.skipAnimation then
    ui.setHeaderColor(toColor)
    _cmdToken.setDisplayToken(toColor, true, params.callback)
  else
    ui.animateHeaderColor(toColor, params.callback)
    _cmdToken.setDisplayToken(toColor, false)
  end
  ui.setSmartButtonColors()
end

Tac._resolveTurnReset = false
Tac.onGameEvent = function(event, params)
  params = params or {}

  --expects params: {active = bool, tacStep = Tac.eStates}
  local function resolveTacStepBtnClicked()
    local state = assert(params.tacStep)
    local activate = params.activate or false

    if not activate then
      Tac.setState(Tac.eStates.Turns(), {fastOpen = true})
    elseif ActivePlayer.system then
      if Tac.highlightAdjSystems[ActivePlayer.color] then _systemHelper.getAdjacentSystems({color = ActivePlayer.color, highlight = true}) end
      Tac.setState(state, params)
    end
  end

  --params = {color, system, (optional)token = objRef to TacToken}
  local function resolveSystemActivated()
    assert(params.color and params.system)
    ActivePlayer.update(params.color or Turns.turn_color)
    ActivePlayer.prevSystem = ActivePlayer.system ~= params.system and ActivePlayer.system or ActivePlayer.prevSystem
    ActivePlayer.system = params.system

    Tac.isActionPhase = true
    Tac.setColor({skipAnimation = true})
    ui.enableTacStepButtons(true)
    ui.setSubheaderTxt(ui.eSubTxt.FactionName())
    ui.setSmartButtonColors()
    MultiRoller.buildTacData(params.system)
    _cmdToken.animateActivation(function()
      --after animation, maybe set state to movement
      if not Tac.inStateTransition then
        if Tac.State == Tac.eStates.Invasion() or Tac.State == Tac.eStates.SpaceCombat() then
          Tac.updateActiveState()
        else
          Tac.setState(Tac.eStates.Movement())
        end
      end
    end)
  end

  --params = {activePlayer, system}
  local function resolveEndOfTacticalAction()

  end

  local function resolvePlayerPassed()
    if not Tac.isActionPhase then return end

    if Tac.State == Tac.eStates.Turns() then --remove player name from active players
      ui.setTurnUI(true)
    end
  end

  --Triggered on onPlaceTradeGoodsAndSetTurns, or if a system is activated outside of the action phase
  local function resolveStartActionPhase()
    Tac.isActionPhase = true
    Wait.frames(function()
      Tac.onGameEvent(Tac.eGameEvents.NewActivePlayer())
    end, 1)
  end

  --triggered when the last active/passed token has been flipped
  local function resolveEndActionPhase()
    Tac.isActionPhase = false
    ActivePlayer.prevSystem = nil
    ActivePlayer.system = nil
    Tac.setState(Tac.eStates.Main(), params, function() Tac.setColor("Grey") end)
  end

  --expects params: {color, prev, skipAnimation = bool}
  local function resolveNewActivePlayer()
    local newColor = params.color or (Turns.enable and Turns.turn_color or "Grey")
    if not _zoneHelper.zoneAttributes(newColor) then Tac.setState(Tac.eStates.Main(), params) return end

    ActivePlayer.update(newColor)
    if ActivePlayer.color == Tac.color then
      _cmdToken.animateActivation()
      return
    end

    Tac.setColor({color = newColor, skipAnimation = params.skipAnimation or Tac.disableAnimations})
    Tac.setState(Tac.eStates.Turns(), params)
  end

  --params: {color, prev, turnsDisabled = bool}
  local function resolvePlayerTurnStart()
    if not Tac.isActionPhase or Tac.color == params.color then return end
    local turnsDisabled = params.color == "Grey"

    if turnsDisabled then
      if Tac._resolveTurnReset then return end --dont stack waits
      Tac._resolveTurnReset = true
      Wait.frames(function()
        if not Tac._resolveTurnReset then return end --cancel wait if turn was re-enabled
        Tac._resolveTurnReset = false
        Tac.setState(Tac.eStates.Main())
      end, 1)
      return
    end
    --else:
    Tac._resolveTurnReset = false --override and cancel any turn reset that may have been called earlier this frame
    Tac.onGameEvent(Tac.eGameEvents.NewActivePlayer(), params)
  end

  local function resolveUnitMapUpdated()
    ui.setSmartButtonColors(true)
    PShield.update()
  end

  local switch = { --Each key coresponds to an entry in: Tac.eGameEvents
    ["StartActionPhase"] = resolveStartActionPhase,
    ["EndActionPhase"] = resolveEndActionPhase,
    ["EndOfTacticalAction"] = resolveEndOfTacticalAction,
    ["NewActivePlayer"] = resolveNewActivePlayer,
    ["PlayerTurnStart"] = resolvePlayerTurnStart,
    ["SystemActivated"] = resolveSystemActivated,
    ["PlayerPassed"] = resolvePlayerPassed,
    ["TacStepBtnClicked"] = resolveTacStepBtnClicked,
    ["UnitMapUpdated"] = resolveUnitMapUpdated,
  }
  switch[event]()
end

--params{skipAnimation = bool, fastOpen/fastClose = bool} callback = func
    --skipAnimation skips both the open and closing animation of states, fastOpen/Close skips only the respective opening/closing
Tac.setState = function(toState, params, callback)
  --print("\nTry setState to >", toState, "<\nState|Prev|Transit")
  --print(Tac.State, "|", Tac.previousState, "|", Tac.inStateTransition)
  if Tac.inStateTransition then Tac.inStateTransition = toState Tac._onStateOpen = callback return end
  if toState == Tac.State  then Tac.updateActiveState(callback, params) return end
  if callback then Tac._onStateOpen = callback end
  params = params or {}

  --print("\nSetting state to ", toState, " from ", Tac.State)
  local function onOpenComplete()
    --print("State change complete\nState|Prev|Transit")
    --print(Tac.State, "|", Tac.previousState, "|", Tac.inStateTransition)
    if Tac.State == Tac.inStateTransition then
      Tac.inStateTransition = false
      Tac.onStateOpen()
    elseif Tac.inStateTransition then --A request to change state may have been made while opening this state
      local quedState = Tac.inStateTransition
      Tac.inStateTransition = false
      Tac.setState(quedState, params)
    end
  end

  local function onCloseComplete()
    --print("Openeing >", Tac.inStateTransition, "<")
    Tac.State = Tac.inStateTransition
    Tac.openState(Tac.State, onOpenComplete, params)
  end

  Tac.inStateTransition = toState
  Tac.previousState = Tac.State
  --print("Closing >", Tac.previousState, "<")
  Tac.closePreviousState(onCloseComplete, params)
end

--params{ skipAnimation = bool, fastOpen = bool}
Tac.openState = function(state, callback, params)
  params = params or {}
  params.skipAnimation = params.skipAnimation or Tac.disableAnimations
  local function tryCallback()
    if callback then callback() end
  end
  if not Tac.inStateTransition and state == Tac.State then tryCallback() return end

  local function openMain()
    ActivePlayer.update("Grey")
    ui.show("icon_agenda")
    ui.setSubheaderTxt(ui.eSubTxt.NonActive())
    Tac.setColor({color = "Grey", skipAnimation = params.skipAnimation or params.fastOpen, callback = callback})
  end

  local function openTurns()
    ui.setTurnUI(true)
    ui.setSubheaderTxt(ActivePlayer.system and ui.eSubTxt.FactionName() or ui.eSubTxt.Activate())
    ui.enableTacStepButtons(ActivePlayer.system)
    tryCallback()
  end

  local function openInvasion()
    ui.setTacStep(state, {callback = callback, skipAnimation = params.skipAnimation or params.fastOpen})
  end

  local function openSpaceCombat()
    ui.setTacStep(state, {callback = callback, skipAnimation = params.skipAnimation or params.fastOpen})
  end

  local function openMovement()
    ui.setTacStep(state, {callback = callback, skipAnimation = params.skipAnimation or params.fastOpen})
    if Tac.highlightAdjSystems[ActivePlayer.color] then
      print("TODO: Set adj system highlight btn")
      --highlight will be applied during buildTacData
    end
  end

  local switch = {
    ["Main"] = openMain,
    ["Turns"] = openTurns,
    ["Invasion"] = openInvasion,
    ["SpaceCombat"] = openSpaceCombat,
    ["Movement"] = openMovement,
    ["catch"] = function() print("Attempting to open unknown state: ", state) tryCallback() end
  }
  --print("Opening state >", state, "<")
  local try = switch[state] and state or "catch"
  switch[try]()
end

Tac.onStateOpen = function()
  if Tac._onStateOpen then Tac._onStateOpen() end
  Tac._onStateOpen = false
end

--params {skipAnimation = bool, fastClose = bool}
Tac.closePreviousState = function(callback, params)
  params = params or {}
  params.skipAnimation = params.skipAnimation or Tac.disableAnimations
  local function tryCallback()
    if callback then Wait.frames(callback, 1) end--Coru.waitFrames(1, callback) end
  end

  local function closeMain()
    local closeCo = coroutine.create(function()
      ui.hide("icon_agenda")
      local t1 = Time.time
      while Time.time -t1 <= 1.25 do
        coroutine.yield(0)
      end
      return 1
    end)
    if params.skipAnimation or params.fastClose then
      ui.hide("icon_agenda", true)
      tryCallback()
    else
      Coru.run(closeCo, {callback = callback})
    end
  end

  local function closeTurns()
    ui.setTurnUI()
    tryCallback()
  end

  local function closeInvasion()
    ui.setTacStep(Tac.eStates.Invasion(),{callback = tryCallback, skipAnimation = params.skipAnimation or params.fastClose, disable = true})
  end

  local function closeSpaceCombat()
    ui.setTacStep(Tac.eStates.SpaceCombat(),{callback = tryCallback, skipAnimation = params.skipAnimation or params.fastClose, disable = true})
  end

  local function closeMovement()
    _systemHelper.removeSystemHighlights()
    ui.setTacStep(Tac.eStates.Movement(), {callback = tryCallback, skipAnimation = params.skipAnimation or params.fastClose, disable = true})
  end

  local switch = {
    ["Main"] = closeMain,
    ["Turns"] = closeTurns,
    ["Initializing"] = tryCallback,
    ["Uninitialized"] = tryCallback,
    ["Invasion"] = closeInvasion,
    ["SpaceCombat"] = closeSpaceCombat,
    ["Movement"] = closeMovement,
    ["catch"] = function() print("Attempting to close unrecognized state: ", Tac.previousState) tryCallback() end
  }
  --print("Closing state >", Tac.previousState, "<")
  local try = switch[Tac.previousState] and Tac.previousState or "catch"
  switch[try]()
end

--params {skipAnimation = bool, callback}
Tac.updateState = function(state, callback, params)
  if Tac.inStateTransition then return end
  params = params or {}
  params.skipAnimation = params.skipAnimation or Tac.disableAnimations

  local function updateTurns()
    ui.setTurnUI(true)
    ui.setSubheaderTxt(ui.eSubTxt.Activate())
    ui.enableTacStepButtons(ActivePlayer.system)
  end

  local function updateInvasion()
    Invasion.reset()
  end

  local switch = {
    ["Main"] = function() end,
    ["Turns"] = updateTurns,
    ["Initializing"] = function() end,
    ["Uninitialized"] = function() end,
    ["Invasion"] = updateInvasion,
    ["SpaceCombat"] = function() end,
    ["Movement"] = function() end,
    ["catch"] = function() print("Trying to update unknown state: ", state) if callback then callback() end end
  }
  --print("Updating state >", state, "<")
  local try = switch[state] and state or "catch"
  switch[try]()
end

Tac.updateActiveState = function(callback, params)
  Tac.updateState(Tac.State, callback, params)
end

--Invasion UI handler-----------------------------------------------------------
Invasion.active = false
Invasion.State = "Overview"
Invasion.eStates = {
  Overview = function() return "Overview" end,
  Bombardment = function() return "Bombardment" end,
  SpaceCannonDef = function() return "SpaceCannonDef" end,--SpC defense
  GroundCombat = function() return "GroundCombat" end,
}

-------State machine
Invasion.reset = function()
  Invasion.setContext()
  Invasion.setFocus()
  --update active system data
  Invasion.setState(Invasion.eStates.Overview())
  Invasion.setActive(Tac.State == Tac.eStates.Invasion())
  Plasma.setTarget("default")
  PShield.update()
  --Planets.buildActiveSystem()
end

Invasion.setActive = function(activate, skipAnimation)
  activate = activate and true or false
  --if Invasion.active == activate then return end
  Invasion.active = activate

  --When the panel is closed, buttons need to be explicitly de-activated or the mouse pointer will have the button effect while hovering over the invisible elements
  local _childButtons = {"Btn_BombardmentMode", "Btn_SpaceCannonDefMode", "SmartBtn_SpaceCannonDef", "SmartBtn_Bombardment"}
  local _contextButtons = {"Btn_Roll_InvasionContext", "Btn_Roll_InvasionContext_Outline", "SmartBtn_InvasionContext_Att","SmartBtn_InvasionContext_Def"}

  for _,each in ipairs(_childButtons) do
    ui.batchSet(each, {active = activate, interactable = activate})
  end

  local pCount = ActivePlayer.system and ActivePlayer.system.planets and #ActivePlayer.system.planets or 0
  for i = 1, 5, 1 do --Only reactivate buttons on visible planets
    ui.batchSet("p"..i.."_ColorRing", {active = activate and i <= pCount or false, interactable = activate and i <= pCount or false})
    ui.batchSet("p"..i.."_QuickBombard", {active = activate and i <= pCount or false, interactable = activate and i <= pCount or false})
    ui.batchSet("p"..i.."_QuickPDS", {active = activate and i <= pCount or false, interactable = activate and i <= pCount or false})
  end

  Plasma.setEnabled(activate, activate)
  PShield.setEnabled(activate, activate)
  if activate then
    --first time opening for this system? Build the system
    if not Planets._displayedSystem or (Planets._displayedSystem and Planets._displayedSystem ~= ActivePlayer.system) then
      Invasion.setState(Invasion.eStates.Overview())
      Invasion.setFocus()
      Planets.buildActiveSystem(nil, skipAnimation)
    else --Keep current focus and context
      Invasion.setState(Invasion.eStates.Overview())
      Invasion.showContextButtons()
      Invasion.showFocusButtons()
      Planets.buildActiveSystem(nil, skipAnimation)
    end
  end
end

Invasion.setState = function(state, params)
  if state ~= Invasion.State then Invasion.closeActiveState(params) end
  Invasion.State = state
  Invasion.openState(state, params) --open/refresh
end

Invasion.openState = function(state, params)
  params = params or {}

  local function openSpaceCannon()
    --sync ToggleButton
    ToggleButton.setState(ToggleButton.btns["Btn_SpaceCannonDefMode"], true)

    Invasion.setContext(state)
    ui.batchSet("SmartBtn_SpaceCannonDef", {active = true, interactable = true, color = Planets.getFocusOrUniformOwner()})
  end

  local function openBombardment()
    ToggleButton.setState(ToggleButton.btns["Btn_BombardmentMode"], true)

    Invasion.setContext(state)
    ui.batchSet("SmartBtn_Bombardment", {color = ActivePlayer.color or "Grey"})

    --Plasma.setShowing(true) --Moved to be always showing
  end

  local function openCombat()
    Invasion.setContext(state)
  end

  local function openOverview()
    Invasion.setContext()
    ui.batchSet("SmartBtn_Bombardment", {active = true, interactable = true, color = ActivePlayer.color or "Grey"})
    ui.batchSet("SmartBtn_SpaceCannonDef", {active = true, interactable = true, color = Planets.getFocusOrUniformOwner() or "Grey"})
  end

  local switch = {
    ["Overview"] = openOverview,
    ["GroundCombat"] = openCombat,
    ["Bombardment"] = openBombardment,
    ["SpaceCannonDef"] = openSpaceCannon,
    ["catch"] = function() print("Caught unregisted case >", state, "< in Invasion.OpenState") return end
  }
  local try = switch[state] and state or "catch"
  switch[try]()
end

Invasion.closeActiveState = function(params)
  params = params or {}

  local function closeSpaceCannon()
    --sync ToggleButton
    ToggleButton.setState(ToggleButton.btns["Btn_SpaceCannonDefMode"], false)
  end

  local function closeBombardment()
    ToggleButton.setState(ToggleButton.btns["Btn_BombardmentMode"], false)
    --Changing where this is enabled/disabled so that plasma buttons are always visible Plasma.setShowing(false)
    --Handle bombardment helper
  end

  local function closeOverview()
  end
  local function closeCombat()
  end

  local switch = {
    ["Overview"] = closeOverview,
    ["GroundCombat"] = closeCombat,
    ["Bombardment"] = closeBombardment,
    ["SpaceCannonDef"] = closeSpaceCannon,
    ["catch"] = function() print("Caught unregisted case >", Invasion.State, "< in Invasion.closeActiveState") return end
  }
  local try = switch[Invasion.State] and Invasion.State or "catch"
  switch[try]()
end

--unimplemetned
Invasion.onSystemActivated = function()
  if not Invasion.active then return end

  --first time opening for this system? Build the system
  if not Planets._displayedSystem or (Planets._displayedSystem and Planets._displayedSystem ~= ActivePlayer.system) then
    Invasion.setState(Invasion.eStates.Overview())
    Invasion.setFocus()
    Planets.buildActiveSystem()
  else --Keep current focus and context
    Invasion.setState(Invasion.eStates.Overview())
    Invasion.showContextButtons()
    Invasion.showFocusButtons()
    Planets.buildActiveSystem()
  end
end

-------Context and Focus
Invasion.focus = false --or planetName
Invasion.setFocus = function(pIndex, skipAnimation) --index of the planet in its system's "planets" table
  local target = pIndex and Planets.getName(pIndex) or false

  --Removing focus, but already dont have one
  if(not target and not Invasion.focus) then return end

  --Repeated setting a target removes that target from focus like a toggle
  if(target == Invasion.focus) then target = false end

  --prevent focus setting while animating --!!!May be incomplete
  if not Invasion.active or Planets._nextSystem or Planets.AnimState == Planets.eAnim.focusSwap() or Planets.AnimState == Planets.eAnim.clearing() or Planets.AnimState == Planets.eAnim.building() then return end
  if target then --validate the target planet
    --Check active system has a planet to focus
    if not ActivePlayer.system or not ActivePlayer.system.planets or not next(ActivePlayer.system.planets) then return end
    --Check target is in active system
    local inSystem = false
    for _,each in ipairs(ActivePlayer.system.planets) do
      if each.name == target then inSystem = true break end
    end
    if not inSystem then return end
  end

--!Move to Planets section
  local function onFocusChangeComplete()
    local fBool = Invasion.focus and true or false
    if fBool then
      ui.batchSet("SmartBtn_InvasionContext_Def", {color = Planets.getOwner(target)})
      ui.batchSet("Txt_HexFocusLabel", {text = string.upper(target)})
      --enter ground combat context when planet is clicked
      if not Invasion.context then Invasion.setState(Invasion.eStates.GroundCombat()) end
    else
      --Ground combat state is only available while a planet is in focus
      if Invasion.State == Invasion.eStates.GroundCombat() then Invasion.setState(Invasion.eStates.Overview()) end

      --maybe remove smart button color
      ui.batchSet("SmartBtn_InvasionContext_Def", {color = Planets.getFocusOrSoloOwner()})
    end
    ui.batchSet("Hex_FocusNameplate", {active = fBool})
    ui.batchSet("SmartBtn_SpaceCannonDef", {color = Planets.getFocusOrUniformOwner()})
  end

  Invasion.focus = target
  Planets.setFocus({callback = onFocusChangeComplete, skipAnimation = skipAnimation}, not target)
end

--!unimplemented
Invasion.showFocusButtons = function(hide)
  hide = hide and true or false
  local show = not hide
  if show and not Invasion.foucs then return end

  --ui.batchSet("", {active = show, interactable = show})
end

--Context refers to the "Context Button" that appears at the base of the hex
--It determines what is rolled for when it is pressed
Invasion.context = false
Invasion.setContext = function(state)
  local contextSettings = {
    ["GroundCombat"] = {context = "groundCombat", label = "GROUND COMBAT", defender = Invasion.focus},
    ["Bombardment"] = {context = "bombardment", label = "BOMBARDMENT", defender = false},
    ["SpaceCannonDef"] = {context = "spaceCannonDef", label = "SPACE CANNON", defender = Invasion.focus}
  }
  Invasion.context = contextSettings[state] and contextSettings[state].context or false
  local setActive = Invasion.context and true or false
  ui.batchSet("Btn_Roll_InvasionContext_Outline", {active = setActive, interactable = setActive})
  ui.batchSet("Btn_Roll_InvasionContext", {active = setActive, interactable = setActive})
  ui.batchSet("Btn_Roll_InvasionContext_Txt", {text = setActive and contextSettings[state].label or ""})
  --Set smart context colors
  ui.batchSet("SmartBtn_InvasionContext_Att", {active = setActive, interactable = setActive, color = setActive and ActivePlayer.color or "Grey"})
  ui.batchSet("SmartBtn_InvasionContext_Def", {active = setActive, interactable = setActive,
    color = setActive and Planets.getFocusOrSoloOwner()})--contextSettings[state].defender and MultiRoller.getDefender(contextSettings[state].defender)
end

--Setting context also shows
Invasion.showContextButtons = function(hide)
  hide = hide and true or false
  local show = not hide
  if show and not Invasion.context then return end

  ui.batchSet("SmartBtn_InvasionContext_Att", {active = show, interactable = show})
  ui.batchSet("SmartBtn_InvasionContext_Def", {active = show, interactable = show})
  ui.batchSet("Btn_Roll_InvasionContext_Outline", {active = show, interactable = show})
  ui.batchSet("Btn_Roll_InvasionContext", {active = show, interactable = show})
end

------Orbitals/Planets
Invasion.orbitals = {}
Invasion.orbitIds = {}

Invasion.getOrbitals = function(system_guid)
  system_guid = system_guid or (ActivePlayer.system and ActivePlayer.system.guid)
  if not system_guid then return end
  if Invasion.orbitals[system_guid] then return Invasion.orbitals[system_guid] end

  --generate orbital layout
  local systemOrbit = {
    unused = {},
  }
  Invasion.orbitals[system_guid] = systemOrbit
  return systemOrbit
end

Invasion.animator = false
Invasion.animateOrbitals = function(orbit, reverse)
end

--target = #index or string name of xml planet id {p1, p2,... p5}
--fromSystem defaults to the active system
Planets.getName = function(target, fromSystem)
  fromSystem = fromSystem or ActivePlayer.system
  if not fromSystem or not fromSystem.planets or not next(fromSystem.planets) then return nil end
  local switch = {
    ["p1"] = 1, ["p2"] = 2, ["p3"] = 3, ["p4"] = 4, ["p5"] = 5,
  }
  local i = type(target) == "string" and switch[target] or tonumber(target)
  return i <= #fromSystem.planets and fromSystem.planets[i].name or nil
end

Planets.getIndex = function(pName, fromSystem)
  fromSystem = fromSystem or ActivePlayer.system
  if not fromSystem or not fromSystem.planets or not next(fromSystem.planets) then return nil end
  for i,each in ipairs(fromSystem.planets) do
    if pName == each.name then return i end
  end
  return nil
end

--pTable = table of all planets in this system *optional, defaults to active system
--index = i of the planet in the pTable
Planets.getScale = function(index, pTable)
  return Planets.getRawScale(index, Planets._iFocus, pTable)
  --[[pTable = pTable or (ActivePlayer.system and ActivePlayer.system.planets)
  if not pTable or not next(pTable) then return end

  local scale = Planets.focusLayouts[1][1].scale
  if Planets._displayedFocus and Planets._iFocus == index then
    return "" .. scale .. " " .. scale .. " 1"
  end

  local pCount = #pTable
  --if reading from the focusTable, planet indexes are shifted down by 1 (focus planet is removed from total planet count)
  if Planets._displayedFocus then index = Planets._iFocus >= index and index or index -1 end

  scale = Planets._displayedFocus and Planets.focusLayouts[pCount][index].scale or Planets.layouts[pCount][index].scale
  if pCount == 1 then--apply additional scale bassed on the planet's radius
    --ratio of change from default radius (a planet with the default radius will not be get additional scale)
    local radScale = (pTable[index].radius/0.8) * 0.7 --Reduce the change
    radScale = radScale >= 1 and radScale or 1 --Dont shrink small planets
    scale = scale * radScale
  end

  return "" .. scale .. " " .. scale .. " 1"--]]
end

Planets.getRawScale = function(index, proxyFocusIndex, pTable)
  proxyFocusIndex = proxyFocusIndex and proxyFocusIndex > 0 and proxyFocusIndex or -1
  local scale = Planets.focusLayouts[1][1].scale
  if proxyFocusIndex == index then
    return "" .. scale .. " " .. scale .. " 1"
  end

  pTable = pTable or (ActivePlayer.system and ActivePlayer.system.planets)
  if not pTable or not next(pTable) then return end
  local pCount = #pTable
  local useFocusTable = proxyFocusIndex > 0
  local mappedIndex = useFocusTable and Planets.mapPlanetIndexToFocusIndex(index, proxyFocusIndex, pCount) or index
  scale = useFocusTable and Planets.focusLayouts[pCount][mappedIndex].scale or Planets.layouts[pCount][mappedIndex].scale
  if pCount == 1 then--apply additional scale bassed on the planet's radius
    --ratio of change from default radius (a planet with the default radius will not be get additional scale)
    local radScale = (pTable[index].radius/0.8) * 0.7 --Reduce the change
    radScale = radScale >= 1 and radScale or 1 --Dont shrink small planets
    scale = scale * radScale
  end

  return "" .. scale .. " " .. scale .. " 1"
end

Planets.getOffset = function(index, pTable)
  return Planets.getRawOffset(index, Planets._iFocus, pTable)
  --[[pTable = pTable or (ActivePlayer.system and ActivePlayer.system.planets)
  if not pTable or not next(pTable) then return end

  if Planets._displayedFocus and Planets._iFocus == index then --== pTable[index].name or
    return Planets.focusLayouts[1][1].x .. " " .. Planets.focusLayouts[1][1].y
  end

  --if reading from the focusTable, planet indexes are shifted down by 1 (focus planet is removed from total planet count)
  if Planets._displayedFocus then index = Planets._iFocus >= index and index or index -1 end
  local pCount = #pTable
  local offX = Planets._displayedFocus and Planets.focusLayouts[pCount][index].x or Planets.layouts[pCount][index].x
  local offY = Planets._displayedFocus and Planets.focusLayouts[pCount][index].y or Planets.layouts[pCount][index].y
  return offX .. " " .. offY--]]
end

Planets.getRawOffset = function(index, proxyFocusIndex, pTable)
  proxyFocusIndex = proxyFocusIndex and proxyFocusIndex > 0 and proxyFocusIndex or -1
  if proxyFocusIndex == index then
    return Planets.focusLayouts[1][1].x .. " " .. Planets.focusLayouts[1][1].y
  end

  pTable = pTable or (ActivePlayer.system and ActivePlayer.system.planets)
  if not pTable or not next(pTable) then return end

  local pCount = #pTable
  local useFocusTable = proxyFocusIndex > 0
  local mappedIndex = useFocusTable and Planets.mapPlanetIndexToFocusIndex(index, proxyFocusIndex, pCount) or index
  local offX = useFocusTable and Planets.focusLayouts[pCount][mappedIndex].x or Planets.layouts[pCount][mappedIndex].x
  local offY = useFocusTable and Planets.focusLayouts[pCount][mappedIndex].y or Planets.layouts[pCount][mappedIndex].y
  return offX .. " " .. offY
end

Planets.mapPlanetIndexToFocusIndex = function(planetIndex, focusIndex, planetCount)
  assert(planetIndex and focusIndex and planetCount)
  --Planet index is the index of the planet in its table. This index is used directly in Planets.layouts[i]
  --FocusIndex[1] is not garranteed to represent PlanetIndex[1], Planets.focusLayouts[i] needs to be determined by which planet is currently in focus
  local i = 1
  if(planetCount > 2)then
    i = planetIndex - focusIndex
    if(planetIndex < focusIndex)then i = planetCount + i end
  end
  return i
end

--indexOrName of planet
--pTable = table of all planets in this system *optional, defaults to active system
Planets.getOwner = function(indexOrName, pTable)
  local function nameFromIndex()
    pTable = pTable or (ActivePlayer.system and ActivePlayer.system.planets)
    assert(pTable, "To get a planet's ownerColor by that planet's index, you must provide the .planets table from the planet's system.")
    if not pTable or not next(pTable) or indexOrName <= 0 or indexOrName > #pTable then return "Grey" end

    return pTable[indexOrName] and pTable[indexOrName].name or "Grey"
  end

  --convert indexOrName to a name
  local pName = type(indexOrName) == "number" and nameFromIndex() or indexOrName or false
  if not pName then return "Grey" end --given name was not in given planet table or active system

  local pCard = Planets.getCard(pName)
  return pCard ~= nil and _zoneHelper.zoneFromPosition(pCard.getPosition()) or "Grey"
end

--gets the owner color of the only planet in a system
Planets.getFocusOrSoloOwner = function()
  if Invasion.focus then return Planets.getOwner(Invasion.focus) end
  local planets = ActivePlayer.system and ActivePlayer.system.planets or false
  return planets and #planets == 1 and Planets.getOwner(planets[1].name) or "Grey"
end

--gets the owner color of the focus planet, or the only player that controlls planets in the system -- returns "Grey" if mixed players
Planets.getFocusOrUniformOwner = function(includeUncontrolledPlanets)
  local color = Planets.getFocusOrSoloOwner()
  --see if all planets in the system are owned by the same player (maybe ignoring uncontrolled grey planet owners)
  if color == "Grey" and ActivePlayer.system then
    local planets = ActivePlayer.system.planets or {}
    local allSame = "init"
    for _,each in ipairs(planets) do
      local owner = Planets.getOwner(each.name)
      if owner ~= "Grey" or includeUncontrolledPlanets then
        allSame = allSame == "init" and owner or owner == allSame and owner
        if not allSame then return "Grey" end
      end
    end
    color = allSame ~= "init" and allSame or "Grey"
  end
  return color
end

--params = {isHS = bool, scale, offset} (only set scale and offset to overrid the default settings)
Planets.setPlanet = function(index, planetData, pCount, params)
  params = params or {}
  local id = "p" .. index

  if not planetData then
    ui.batchSet(id, {active = false})
    ui.batchSet(id.. "_HS", {active = false})
    ui.batchSet(id.."_ColorRing", {active = false, interactable = false})
    ui.batchSet(id.."_QuickBombard", {active = false, interactable = false})
    ui.batchSet(id.."_QuickPDS", {active = false, interactable = false})
    ui.batchSet(id.."_Btn_shieldOverride", {active = false, interactable = false})
    return
  end

  local function getPlanetImage()
    if planetData.legendary then return "Wired_legendary" end
    if planetData.trait then return "Wired_" .. planetData.trait end
    if planetData.name == "Mecatol Rex" then return "Wired_Rex" end
    return "Wired_Planet" --HS or no trait
  end

  local function getFactionColor(getSecondary)
    --If not a faction planet, return owner color
    return Planets.getOwner(index)
  end

  --else
  local inFocus = Planets._displayedFocus and index == Planets._iFocus or false
  ui.batchSet(id, {active = true, offsetXY = params.offset or Planets.getOffset(index), scale = params.scale or Planets.getScale(index)})
  ui.batchSet(id.."_ColorRing", {active = true, interactable = true, color = Planets.getOwner(index)})
  ui.batchSet(id.."_Planet", {image = getPlanetImage(), color = (planetData.trait or planetData.name == "Mecatol Rex") and "White" or getFactionColor()})
  ui.batchSet(id.."_HS", {active = params.isHS and true or false, color = "Orange"}) --getFactionColor("secondary")})
  ui.batchSet(id.."_Txt", {text = string.upper(planetData.name)})
  ui.batchSet(id.."_Trait", {active = planetData.trait and true or false})

  --Elements effected by focus
  if planetData.trait and Planets.traits[planetData.trait] then
    ui.batchSet(id.."_Trait", {
      image = Planets.traits[planetData.trait],
      offsetXY = "0 " .. (inFocus and Planets.traits.data.focusOffset or Planets.traits.data.offset)
    })
  end
  ui.batchSet("p"..index.."_Btn_PlasmaScoring", {
    offsetXY = inFocus and Plasma.focusOffset or Plasma.offset,
    scale = inFocus and Plasma.focusScale or "1 1 1"
  })
  ui.batchSet(id.."_QuickBombard", {active = true, interactable = true,
    offsetXY = inFocus and Planets.focusBanner.inFocus.quickBomb.offset or Planets.focusBanner.outOfFocus.quickRoll.offsetLeft,
    width = inFocus and Planets.focusBanner.inFocus.quickBomb.width or Planets.focusBanner.outOfFocus.quickRoll.width,
    height = inFocus and Planets.focusBanner.inFocus.quickBomb.height or Planets.focusBanner.outOfFocus.quickRoll.height,
  })
  ui.batchSet(id.."_QuickPDS", {active = true, interactable = true,
    offsetXY = inFocus and Planets.focusBanner.inFocus.quickPDS.offset or Planets.focusBanner.outOfFocus.quickRoll.offsetRight,
    width = inFocus and Planets.focusBanner.inFocus.quickPDS.width or Planets.focusBanner.outOfFocus.quickRoll.width,
    height = inFocus and Planets.focusBanner.inFocus.quickPDS.height or Planets.focusBanner.outOfFocus.quickRoll.height,
  })
end

Planets.Animator = false
Planets.AnimState = false --Building, clearing, focusUp, focusDown
Planets.eAnim = {
  ["clearing"]  = function() return "clearing"  end,
  ["building"]  = function() return "building"  end,
  ["focusUp"]   = function() return "focusUp"   end,
  ["focusDown"] = function() return "focusDown" end,
  ["focusSwap"] = function() return "focusSwap" end
  --["idle"] = function() return "idle" end
}

------------
--Defines the bezier curves that the planets move through
local eBezTypes = {
  SHIFT = function() return "SHIFT" end,
  SWAP = function() return "SWAP" end,
  JUMP = function() return "JUMP" end
}
--Bez[planetCount][BezType].getCurve(pIndex, +/-) --all values multiplied by 4.4
local Bez = {
  scaleMod = 4.4,
  [1] = {},
  [2] = {},
  [3] = {
    ["SHIFT"] = {
      [1] = {0, -107},--Origin
      [2] = {-79, -98},--O_HandleB
      [3] = {-99, -16},--P1_HandleA
      [4] = {-85, 1},--P1_Origin
      [5] = {-119, 20},--P1_HandleB
      [6] = {-62, 50},--FocusPosA_HandleA
      [7] = {-41, 50},--FocusPosA_Origin
      [8] = {-35, 63},--FocusPosA_HandleB
      [9] = {-27, 93},--P2_HandleA
      [10] = {29, 65},--P2_Origin
      [11] = {37, 89},--P2_HandleB
      [12] = {43, 76},--FocusPosB_HandleA
      [13] = {47, 75},--FocusPosB_Origin
      [14] = {59, 69},--FocusPosB_HandleB
      [15] = {181, 46},--P3_HandleA
      [16] = {53, -46},--P3_Origin
      [17] = {46, -62},--P3_HandleB
      [18] = {67, -106},--Origin_HandleA
      [19] = {0, -107},--Origin
    },
    ["SWAP"] = {
        [-2] = {47, 75},--Counterclockwise FB_Origin
        [-1] = {128, 32},----Counterclockwise FB_HandleB
        [0] = {163, -107},--Counterclockwise O_HandleA
      [1] = {0, -107},--Origin
      [2] = {-196, -52},--O_HandleB
      [3] = {-136, 34},--FA_HandelA
      [4] = {-41, 50},--FA_Origin
      [5] = {-15, 87},--FA_HandleB
      [6] = {-22, 112},--FB_HandleA
      [7] = {47, 75},--FB_Origin
      [8] = {128, 32},--FB_HandleB
      [9] = {163, -107},--O_HandleA
      [10]= {0, -107}--Origin
    },
    ["JUMP"] = {
      [1] = {-85, 1}, --P1_Origin
      [2] = {-43, 152},--P1_HandleA
      [3] = {43, 78},--FB_HandleA
      [4] = {47, 75},--FB_Origin

      [5] = {29, 65},--P2_Origin
      [6] = {192, -67},--P2_HandleA
      [7] = {0, -107},--Origin_HandleA
      [8] = {0, -107},--Origin

      [9] = {53, -46},--P3_Origin
      [10]= {-129, -83},--P3_HandleA
      [11]= {-120, 58},--FA_HandelA
      [12]= {-41, 50},--FA_Origin
    },
  },
  [4] = {},
  [5] = {}
}

Bez.getPath = function(planetCount, curveType, planetIndex, clockwise, oldFocus, newFocus)
  assert(planetIndex and planetIndex > 0 and planetIndex <= planetCount, "Invalid planet index of "..(planetIndex or "nil_or_false"))
  local path = {}
  oldFocus = oldFocus or -1
  newFocus = newFocus or -1

  if(planetCount == 3)then
    if(curveType == eBezTypes.SHIFT()) then
      clockwise = clockwise and 1 or -1
      local index = ((planetIndex -1) * 6) + 4
      --?Shifting from focus or out of focus
      if(oldFocus > 0) then index = index + (-clockwise*3) end
      for i = 0, 3, 1 do
        table.insert(path,{
          Bez[3]["SHIFT"][index + (i*clockwise)][1]*Bez.scaleMod,
          Bez[3]["SHIFT"][index + (i*clockwise)][2]*Bez.scaleMod,
        })
      end
    elseif(curveType == eBezTypes.SWAP()) then
      assert(oldFocus > 0)
      oldFocus = oldFocus > 0 and oldFocus or 1 --Catch error scenario
      --override clockwise, meesed up the value somewhere
      local nextInTable = oldFocus + 1
      if(nextInTable > planetCount)then nextInTable = 1 end
      clockwise = newFocus == nextInTable and -1 or 1
      --Use oldFocus to determine which planet index coresponds to each path index
      --Path index: [1] = FocusPlanet, [2] = FocusPosA, [3] = FocusPosB
      local mappedIndex = (planetIndex - oldFocus + 1)
      if(planetIndex < oldFocus)then mappedIndex = 3 + mappedIndex end
      local index = ((mappedIndex-1)*3)+ 1
      --if(clockwise == -1 and mappedIndex == 1) then index = 10 end
      print("P["..planetIndex.."] mapped to ["..mappedIndex.."]")
      for i = 0, 3, 1 do
        table.insert(path,
        {
          Bez[3]["SWAP"][index + (i*clockwise)][1]*Bez.scaleMod,--x
          Bez[3]["SWAP"][index + (i*clockwise)][2]*Bez.scaleMod,--y
        })
      end
    else --curveType == eBezTypes.JUMP()
      assert(curveType == eBezTypes.JUMP())
      clockwise = clockwise and 1 or -1
      local index = 1+((planetIndex - 1)*4)
      if(clockwise == -1) then index = index + 3 end
      for i = 0, 3, 1 do
        table.insert(path,{
          Bez[3]["JUMP"][index +(i*clockwise)][1]*Bez.scaleMod,
          Bez[3]["JUMP"][index +(i*clockwise)][2]*Bez.scaleMod,
        })
      end
    end
    return path
  end

  return {}
end

Bez.getCoef = function(planetCount, curveType, planetIndex, clockwise, oldFocus, newFocus)
  --returns : {xCoef, yCoef} where xCoef = {#, #, #, #}
  local coef = {{},{}}--x, y
  local points = Bez.getPath(planetCount, curveType, planetIndex, clockwise, oldFocus, newFocus)
  assert(#points == 4)
  for xORy = 1, 2, 1 do
    table.insert(coef[xORy], points[1][xORy])
    table.insert(coef[xORy], (-3*points[1][xORy]) + (3*points[2][xORy]))
    table.insert(coef[xORy], (3*points[1][xORy]) - (6*points[2][xORy]) + (3*points[3][xORy]))
    table.insert(coef[xORy], -points[1][xORy] + (3*points[2][xORy]) - (3*points[3][xORy]) + points[4][xORy])
  end
  return coef
end

Bez.lerp = function(t, coef)
  assert(coef and type(coef) == "table" and #coef == 4, "Malformed coefficients")
  --Bezier curve expanded as Bernstien Polynomial coefficients, and factored as expressions of t^
  return coef[1] + (t*coef[2]) + ((t*t)*coef[3]) + ((t*t*t)*coef[4])
end

Planets._displayedFocus = false
--Planets._nextFocus = false
Planets._iFocus = 0
--Planets._iFocusNext = 0
--params = {callback, skipAnimation, fast = bool}
Planets.setFocus = function(params, disable)
  params = params or {}
  disable = disable or not Invasion.focus
  local skipAnim = params.skipAnimation or Tac.disableAnimations
  local function tryCallback() if params.callback then params.callback() end end

  --Are we already displaying the current focus target?
  if (disable and not Planets._displayedFocus) or (not disable and Invasion.focus == Planets._displayedFocus) then tryCallback() return end

  local function onAnimComplete()
    Planets.AnimState = false
    assert(Planets._displayedFocus == Invasion.focus, "Focus mismatch on complete")
    if(Planets._displayedFocus ~= Invasion.focus) then
      --Planets.setFocus(params)
      return
    end

    local _isActive = Invasion.focus and not disable and true or false
    ui.setShowing("Img_FocusBanner", _isActive, true)
    --refresh planet UI
    if(Planets._displayedSystem and Planets._displayedSystem.planets and #Planets._displayedSystem.planets > 0) then
      local numPlanets = #Planets._displayedSystem.planets
      for i = 1, numPlanets, 1 do
        Planets.setPlanet(i, Planets._displayedSystem.planets[i], numPlanets, {isHS = Planets._displayedSystem.home})
      end
    end

    print("\nPlanet anim complete:")
    print("Displayed focus: ".. (Planets._displayedFocus or "none"))
    print("Displayed index: ".. (Planets._iFocus or "nil"))
    print("Focus: "..(Invasion.focus or "none"))
    print("AnimState: "..(Planets.AnimState or "none"))
    tryCallback()
  end

  local function resolveAnim()
    --Are we already animating? If so, do nothing, the new focus target will be set at the end of the current animation
    if(Planets.AnimState) then return end

    if Invasion.focus and Planets._displayedFocus and Planets._displayedFocus ~= Invasion.focus then
      Planets.AnimState = Planets.eAnim.focusSwap()
    elseif disable then
      Planets.AnimState = Planets.eAnim.focusDown()
    else
      Planets.AnimState = Planets.eAnim.focusUp()
    end
    ---[[
    --if Planets.Animator then Planets.Animator.stop() end
    --Planets.Animator = Animate.newController()
    --Planets.Animator.onComplete = onAnimComplete

    local swapCo = function()
      local iTime = Time.time
      local duration = fast and 0.3 or 1.2
      local iPos = 0
      local iScale = 0
      Planets._displayedFocus = Invasion.focus
    end

    local simpleCo = function()

    end

    local testCo = function()
      local oldFocus = Planets._displayedFocus and Planets.getIndex(Planets._displayedFocus) or -1
      local newFocus = Invasion.focus and Planets.getIndex(Invasion.focus) or -1
      local numPlanets = 3

      --get transition type
      local curveType = eBezTypes.SHIFT()
      if numPlanets == 2 then
        curveType = (oldFocus > 0 and newFocus > 0) and eBezTypes.SWAP() or curveType
      elseif numPlanets == 3 then
        curveType = oldFocus ~= -1 and newFocus ~= -1 and eBezTypes.SWAP() or curveType
        if( (oldFocus == 2 and newFocus == -1) or (newFocus == 2 and oldFocus == -1)) then curveType = eBezTypes.JUMP() end
      end

      --get rotation direction
      local clockwise = true
      if(numPlanets == 2)then
        clockwise = newFocus == 2 or oldFocus == 1

      elseif numPlanets == 3 then
        if(newFocus == 1) then
          clockwise = oldFocus == 2
        elseif(newFocus == 2) then
          clockwise = oldFocus ~= 1
        elseif(newFocus == 3) then
          clockwise = true
        else --no new focus target
          clockwise = oldFocus == 1
        end
      end

      print("\n_______________\nBez Result:")
      print("#P: "..numPlanets)
      print("New Focus: ".. (newFocus ~= -1 and newFocus or "none"))
      print("Old Focus: ".. (oldFocus ~= -1 and oldFocus or "none"))
      print("Transition: "..curveType)
      print("Clockwise: ".. (clockwise and "true" or "false"))
      print("")

      local curveCoefs = {}--{[p_i] ={[1-4]}} --4 points to define the curve of each planet's path
      local scaleTargets = {}--{[p_i] = { {startingScale}, {targetScale}}}}
      for i = 1, numPlanets, 1 do
        table.insert(curveCoefs, Bez.getCoef(numPlanets, curveType, i, clockwise, oldFocus, newFocus))
        table.insert(scaleTargets, {})
        table.insert(scaleTargets[i], XML.scaleFromString(Planets.getRawScale(i, oldFocus)))--pre-focus pos
        table.insert(scaleTargets[i], XML.scaleFromString(Planets.getRawScale(i, newFocus)))--post-focus pos
      end
      local duration = 1.6--0.40
      local t1 = Time.time

      while(Time.time - t1 <= duration) do
        local percent = (Time.time - t1)/duration

        for i = 1, numPlanets, 1 do
          local pos = {Bez.lerp(Tween.smooth(percent), curveCoefs[i][1]), Bez.lerp(Tween.smooth(percent), curveCoefs[i][2])}
          local scaleTween = i == oldFocus and Tween.easeOut(percent) or Tween.easeIn(percent)
          local _scale = {
            Tween.lerp(scaleTargets[i][1].x, scaleTargets[i][2].x, scaleTween),
            Tween.lerp(scaleTargets[i][1].y, scaleTargets[i][2].y, scaleTween),
          }
          ui.batchSet("p"..i, {offsetXY = pos[1].." "..pos[2], scale = _scale[1] .." ".. _scale[2] .." 1"})
        end

        coroutine.yield(percent)
      end

      Planets._displayedFocus = newFocus ~= -1 and Planets.getName(newFocus) or false
      Planets._iFocus = newFocus
      return 1
    end

    --local co = coroutine.create(Planets.AnimState == Planets.eAnim.focusSwap() and swapCo or simpleCo)
    local co = coroutine.create(testCo)
    Coru.run(co, {callback = onAnimComplete})
    --Only activate buttons if Invasion.active is still true after animating

    --Planets.Animator.addClip()
    --Planets.Animator.run()
    --]]
    --temp
    --Planets.buildActiveSystem(tryCallback, skipAnim)
  end

  if skipAnim then
    Planets._displayedFocus = Invasion.focus
    Planets._iFocus = Planets.getIndex(Invasion.focus)
    onAnimComplete()
  else
    resolveAnim()
  end
end

Planets._nextSystem = false --or {callback, system, building}
Planets.buildSystem = function(system, callback, skipAnimation)
  skipAnimation = Tac.disableAnimations or skipAnimation or false
  local function tryCallback() if callback then callback() end end

  local function onBuildComplete()
    if Planets._displayedSystem ~= Planets._nextSystem.system then
      print("Build complete error")
      --close and build?
      tryCallback()
      return
    end

    Planets._nextSystem = false
    PShield.updateUI(skipAnimation)
    tryCallback()
  end

  local function onSystemCleared()
    if not Planets._nextSystem then
      print("Error clearing system")
      --set/animate orbitals for empty
      tryCallback()
      return
    end
    ---else
    local target = Planets._nextSystem.system
    Planets._displayedSystem = target
    Planets._nextSystem.building = true

    --enable red corners for hazardous systems
    if Planets._nextSystem.system and Planets._nextSystem.system.anomalies and #Planets._nextSystem.system.anomalies >= 1 then
      ui.batchSet("Hex_Anamoly", {active = true})
    end

    if target.planets and #target.planets >= 1 then
      local numPlanets = #target.planets
      for i = 1, numPlanets, 1 do
        Planets.setPlanet(i, target.planets[i], numPlanets, {isHS = target.home})
      end
    end

    --Animate planet entry or skip to complete

    onBuildComplete()
  end

  --building/clearing may take time, prevent call stacking
  if Planets._nextSystem then Planets._nextSystem = {callback = callback, system = system, building = Planets._nextSystem.building} return end
  Planets._nextSystem = {callback = callback, system = system, building = false}
  if Planets._displayedSystem == system then --Quickly update system if we are rebuilding the currently displayed system
    skipAnimation = true
    onSystemCleared()
  else
    Planets._clearBuiltSystem(onSystemCleared, skipAnimation)
  end
end
Planets.buildActiveSystem = function(callback, skipAnimation)
  Planets.buildSystem(ActivePlayer.system, callback, skipAnimation)
end

Planets._clearBuiltSystem = function(callback, skipAnimation)
  if not Planets._displayedSystem then if callback then callback() end return end
  skipAnimation = skipAnimation or Tac.disableAnimations or false
  --maybe stop running build animation
  --Clear focus

  local function onClearComplete()
    ui.batchSet("Hex_Anamoly", {active = false})

    for i = 1, 5, 1 do --hide planets
      Planets.setPlanet(i)
    end

    Planets._displayedSystem = false
    if callback then callback() end
  end

  local function resolveAnimation()
    --Planets.AnimState = Planets.eAnim.clearing()
    --clearFocus
    --Planets.animateFocus(callback, close, fast or skip)
    --Planets.animate(close, noSkip, callback)

    --temp
    onClearComplete()
  end

  if skipAnimation then onClearComplete()
  else resolveAnimation()
  end
end

--Sets the currently displayed system to the default empty system
Planets.clearSystem = function(callback, skipAnimation)
  if not Planets._displayedSystem then if callback then callback() end return end
  Planets.buildSystem({tile = -1, planets = {}}, callback, skipAnimation)
end

Planets._cache = {}--[pName] = cardObj
Planets.getCard = function(planetName)
  if Planets._cache[planetName] ~= nil then return Planets._cache[planetName] end

  --The first time the cache is loaded, find as many planets as possible in one go
  if not next(Planets._cache) then
    local allPlanets = _systemHelper.planets() or {}
    for _,eachObj in ipairs(getAllObjects()) do
      if eachObj.type == "Card" then
        local objName = eachObj.getName()
        if allPlanets[string.lower(objName)] then Planets._cache[objName] = eachObj end
      end
    end
    return Planets._cache[planetName]
  else -- just find the target planet
    for _,eachObj in ipairs(getAllObjects()) do
      if eachObj.type == "Card" and eachObj.getName() == planetName then
        Planets._cache[planetName] = eachObj
        return eachObj
      end
    end
  end
end

Planets._trackedCards = {}
--Update the color display to match the planet's owner when its card is dropped
Planets.onPlanetCardDropped = function(dropperColor, dropObj)
  if not Invasion.active then return end

  if not ActivePlayer.system then return end
  local objName = dropObj.getName()
  local owner = "Grey"
  for i,eachPlanet in ipairs(ActivePlayer.system.planets or {}) do
    if objName == eachPlanet.name then
      owner = _zoneHelper.zoneFromPosition(dropObj.getPosition()) or "Grey"
      ui.batchSet("p"..i.."_ColorRing", {color = owner})
      if Planets.getFocusOrSoloOwner() == owner then ui.batchSet("SmartBtn_InvasionContext_Def", {color = owner}) end
      return
    end
  end
end

PShield.setEnabled = function(toState, andShow)
  toState = toState and true or false --cast to boolean
  if PShield.enabled == toState or not ActivePlayer.system then return end

  PShield.enabled = toState
  PShield.setOverride()--reset overrides
  if not toState then
    PShield.setShowing(false)
  elseif andShow then
    PShield.setShowing(true)
  end
end

PShield.setShowing = function(toState)
  toState = toState and true or false
  if not Invasion.active or PShield.visible == toState then return end
  if not PShield.enabled then PShield.setEnabled(true, true) return end

  PShield.visible = toState
  if toState then
    PShield.update()
  else
    PShield.updateUI()
  end
end

--set or remove the shield override for a planet
--toState = -1|0|1 : forceOff|removeOverride|forceOn
PShield.setOverride = function(nameOrIndex, toState)
  if not ActivePlayer.system or not ActivePlayer.system.planets or not PShield.enabled then return end
  if not nameOrIndex or nameOrIndex == "all" then
    for i = 1, 5, 1 do
      PShield.setOverride(i, toState)
    end
    return
  end
  local pIndex = nameOrIndex
  if type(nameOrIndex) == "string" then
    pIndex = 0
    for i,each in ipairs(ActivePlayer.system.planets or {}) do
      if each.name == nameOrIndex then pIndex = i break end
    end
  end
  if pIndex < 1 or pIndex > #ActivePlayer.system.planets or pIndex > 5 then return end

  local status = PShield.status[pIndex]
  if not status then return end
  toState = toState or 0
  if toState ~= 0 and (not status.hasShield or status.enabled == 0) then return end
  status.override = toState

  --set shield enabeld to override or natural state
  if status.enabled ~= 0 then
    PShield.update()
  end
end

PShield.toggleOverride = function(nameOrIndex)
  if not PShield.enabled or not ActivePlayer.system or not ActivePlayer.system.planets then return end
  local pIndex = nameOrIndex
  if type(nameOrIndex) == "string" then
    pIndex = 0
    for i,each in ipairs(ActivePlayer.system.planets or {}) do
      if each.name == nameOrIndex then pIndex = i break end
    end
  end
  if pIndex < 1 or pIndex > #ActivePlayer.system.planets or pIndex > 5 then return end

  local status = PShield.status[pIndex] or false
  if not status or status.enabled == 0 then return end
  local next = status.enabled ~= 1 and 1 or -1
  PShield.setOverride(pIndex, next)
end

PShield.hasActiveShield = function(nameOrIndex)
  if not ActivePlayer.system or not ActivePlayer.system.planets then return end
  local pIndex = nameOrIndex
  if type(nameOrIndex) == "string" then
    pIndex = 0
    for i,each in ipairs(ActivePlayer.system.planets or {}) do
      if each.name == nameOrIndex then pIndex = i break end
    end
  end
  if pIndex < 1 or pIndex > #ActivePlayer.system.planets or pIndex > 5 or not PShield.status[pIndex] then return end

  return PShield.status[pIndex] and PShield.status[pIndex].enabled == 1 or false
end

PShield._hasShieldThisFrame = {} --{pName] = {color, hasShield}} --store results per frame to reduce overhead of update spam
PShield.update = function()
  if ActivePlayer.system and not TacData.unitMap or not TacData.unitMap[ActivePlayer.system.guid] then return end
  local prevStatus = copyTable(PShield.status or {})
  PShield.status.system = ActivePlayer.system.guid or false

  local function locationHasShield(location)
    local pOwner = Planets.getOwner(location)
    if not pOwner or pOwner == "Grey" then return false end

    if PShield._hasShieldThisFrame[location] and pOwner == PShield._hasShieldThisFrame[location].color then return PShield._hasShieldThisFrame[location].hasShield end
    PShield._hasShieldThisFrame[location] = {color = pOwner, hasShield = false}
    Coru.waitFrames(5, function() PShield._hasShieldThisFrame[location] = nil end)

    local pUnits = MultiRoller.getAttributes(pOwner, ActivePlayer.color ~= pOwner and ActivePlayer.color or false, "BOMBARDMENT", location)
    for eachUnit,attrs in pairs(pUnits) do
      if attrs.planetaryShield and attrs.count and attrs.count > 0 then
        PShield._hasShieldThisFrame[location].hasShield = true
        return true
      end
    end

    return false
  end

  --Find what planets in the active system have shields and who controls those planets
  local _planetsWithShields = {}--{[pName] = colorOwner}
  local planetCount = ActivePlayer.system and ActivePlayer.system.planets and #ActivePlayer.system.planets or 0
  for i = 1, 5, 1 do
    local planet = i <= planetCount and ActivePlayer.system.planets[i] or false
    if planet and locationHasShield(planet.name) then
      local owner = Planets.getOwner(i)
      _planetsWithShields[planet.name] = owner
      PShield.status[i].override = prevStatus.system == PShield.status.system and prevStatus[i] and prevStatus[i].override or 0
    else --remove shield UI: Planet i does not exist or has no shielding units
      PShield.status[i].enabled = 0
      PShield.status[i].override = 0
      PShield.status[i].hasShield = false
    end
  end

  --if there are any shielded planets, determine disable status
  if not next(_planetsWithShields) then PShield.updateUI() return end
  --to reduce the number of getAttribute calls, use data stored in TacData to narrow down the list of factions to check for
  local _hasUnitsInSystem = {}--{[color] = true,...}
  local systemSummary = TacData.unitMap[TacData.activeSystem.guid].summary or {}
  --who has units in system
  for eachLocation, colorTables in pairs(systemSummary) do
    for eachColor, unitCounts in pairs(colorTables or {}) do
      if next(unitCounts) then _hasUnitsInSystem[eachColor] = true end
    end
  end

  local _awaitingDisable = copyTable(_planetsWithShields)
  local disabledPlanets = {}--{[name] = true}

  --function modifies _awaitingDisable and disabledPlanets directly
  local function getPlanetsDisabledByColor(color)
    --does ANOTHER player own a planet in this system that has a shield that has not already been disabled?
    --gather planets to check
    local _planetsToCheck = {}
    for eachPlanet,owner in pairs(_awaitingDisable) do
      if owner ~= color then
        table.insert(_planetsToCheck, eachPlanet)
      end
    end
    if not next(_planetsToCheck) then return end

    local _units = MultiRoller.getAttributes(color, nil, "BOMBARDMENT", "Space")
    for unitType,eachUnit in pairs(_units or {}) do
      if type(eachUnit) == "table" then
        if eachUnit.disablePlanetaryShield and eachUnit.count and eachUnit.count > 0 then
          --added support for disablePlanetaryShield = "onThisPlanet". Disables per planet with this unit rather than entire system
          if eachUnit.disablePlanetaryShield == "onThisPlanet" then
            --search Tac data for locations(planets) that have 1 or more of this unit
            if TacData.unitMap and TacData.unitMap[TacData.activeSystem.system.guid] then
              local systemSummary = TacData.unitMap[TacData.activeSystem.system.guid].summary or {}
              for eachLocation,colorTables in pairs(systemSummary) do
                if eachLocation ~= "Space" then
                  --Is this someone else's planet? Does this location have my units? A unit matching unitType? and check non-zero?
                  if _planetsWithShields[eachLocation] ~= color and colorTables[color] and colorTables[TacData.activePlayer][unitType] and  colorTables[TacData.activePlayer][unitType] > 0 then
                    _awaitingDisable[eachLocation] = nil
                    disabledPlanets[eachLocation] = true
                  end
                end
              end
            end
          else -- standard system-wide disable
            for _,eachPlanet in ipairs(_planetsToCheck) do
              _awaitingDisable[eachPlanet] = nil
              disabledPlanets[eachPlanet] = true
            end
            return
          end
        end
      end
    end
  end

  for eachColor,_ in pairs(_hasUnitsInSystem) do
    if not next(_awaitingDisable) then break end
    --function modifies _awaitingDisable and disabledPlanets directly
    getPlanetsDisabledByColor(eachColor)
  end

  --apply results to UI data --UI planets outside of system bounds or without a shield have alerady been set
  for i = 1, 5, 1 do
    local planet = i <= planetCount and ActivePlayer.system.planets[i] or false
    if planet and _planetsWithShields[planet.name] then
      local shieldActive = not disabledPlanets[planet.name] and true or false
      --determine the state the ui SHOULD be in after overrides
      local override = PShield.status[i].override
      PShield.status[i].enabled = override ~= 0 and override or shieldActive and 1 or -1
      PShield.status[i].hasShield = true
    end
  end

  PShield.updateUI()
end

--onlyUpdatePlanet* optional or planetIndex, updates all planets if nil
local _animatingShields = {} --{[1] = {targetState}}
PShield.updateUI = function(skipAnimation, onlyUpdatePlanet)
  --only update if Invasion is open | Shield status has been gathered for the system | The planets are ready to display shields
  if not Invasion.active --ui not visible
    or not PShield.status.system  --we dont have the unit data yet, abort
    or Planets._nextSystem --the planets are still animating, they will dispaly shields when finished
    or not ActivePlayer.system --no active system
    or PShield.status.system ~= ActivePlayer.system.guid --visual/data mismatch
  then return end
  skipAnimation = skipAnimation or Tac.disableAnimations

  local function updatePlanetShield(i)
    if _animatingShields[i] then return end --will self update after animation

    --enabled: data state -1|0|1         RED| Planet has no shield |Blue
    --override:           -1|0|1  forced OFF|     no overrride     |forced ON
    --visible: UI state   -1|0|1 showing RED|       UI hidden      |showing BLUE
    local dataState = PShield.status[i] or {enabled = 0, visible = 0, override = 0, hasShield = false}

    local function onShieldActivated(cancelAnim)
      _animatingShields[i]= nil
      PShield.status[i].visible = 1
      ui.batchSet("p"..i.."_Btn_shieldOverride", {active = true, interactable = true, sprite = "Btn_PShield_NoOverride"})

      PShield.updateUI(skipAnimation or cancelAnim == -1, i)
    end

    --does the shield UI need to be hidden?
    if dataState.visible ~= 0 and (dataState.enabled == 0 or not PShield.visible) then
      ui.hide("p"..i.."_ShieldDisabled", skipAnimation)
      ui.hide("p"..i.."_ShieldEnabled", skipAnimation)
      ui.batchSet("p"..i.."_Btn_shieldOverride", {active = false, interactable = false})
      dataState.visible = 0
      return
    end

    --Do we need to play the showing animation?
    if dataState.visible == 0 and PShield.visible and dataState.enabled ~= 0 then
      _animatingShields[i] = Coru.wait(0.61, onShieldActivated)
      ui.show("p"..i.."_ShieldEnabled", skipAnimation)
      return
    end

    --set the next state for override button to not this state
    ui.batchSet("p"..i.."_Btn_shieldOverride",{active = dataState.visible ~= 0, interactable = dataState.visible ~= 0})
    if dataState.override == 0 then
      ui.batchSet("p"..i.."_Btn_shieldOverride", {
        sprite = "Btn_PShield_NoOverride",
        highlightedSprite = dataState.enabled == 1 and "Btn_PShield_Disable_Dark" or "Btn_PShield_Enable_Dark",
        pressedSpreite = dataState.enabled == 1 and "Btn_PShield_Disable" or "Btn_PShield_Enable"
      })
    else
      local setActive = dataState.enabled == 1 and true or false
      ui.batchSet("p"..i.."_Btn_shieldOverride", {
        sprite = setActive and "Btn_PShield_Enable" or "Btn_PShield_Disable",
        highlightedSprite = setActive and "Btn_PShield_Enable_Hover" or "Btn_PShield_Disable_Hover",
        pressedSprite = setActive and "Btn_PShield_Enable_Dark" or "Btn_PShield_Disable_Dark",
      })
    end

    if dataState.enabled == -1 and dataState.visible == 1 then
      ui.show("p"..i.."_ShieldDisabled", skipAnimation)
      dataState.visible = -1
    elseif dataState.enabled == 1 and dataState.visible == -1 then
      ui.hide("p"..i.."_ShieldDisabled", skipAnimation)
      dataState.visible = 1
    end
  end

  if onlyUpdatePlanet then
    updatePlanetShield(type(onlyUpdatePlanet) == "number" and onlyUpdatePlanet or Planets.getIndex(onlyUpdatePlanet))
  else
    for i = 1, 5, 1 do
      updatePlanetShield(i)
    end
  end
end

Plasma.setEnabled = function(toState, andShow)
  toState = toState and true or false
  if Plasma.enabled == toState then return end
  if toState and (not Invasion.active or not Plasma.hasPS()) then return end

  Plasma.enabled = toState
  Plasma.setTarget(toState and "default")
  if not toState then
    Plasma.setShowing(false)
  elseif andShow then
    Plasma.setShowing(true)
  end
end

Plasma.setShowing = function(toState)
  toState = toState and true or false
  if Plasma.visible == toState then return end
  if toState and not Plasma.enabled then Plasma.setEnabled(true) return end

  Plasma.visible = toState
  Plasma.update()
end

Plasma.hasPS = function(color)
  color = color or ActivePlayer.color
  local modifiers = _getColorToUnitModifiers() or {}
  for _, modifier in ipairs(modifiers[color] or {}) do
      if modifier == 'Plasma Scoring' then
          return true
      end
  end

  return false
end

Plasma.update = function()
  if not Invasion.active or not Plasma.enabled then return end
  if not Plasma.hasPS() then Plasma.setEnabled(false) return end

  Plasma.setTarget(Plasma.target or "default")
  Plasma.updateUI()
end

Plasma.updateUI = function()
  if not Plasma.visible then
    for i = 1, 5, 1 do
      ui.batchSet("p"..i.."_Btn_PlasmaScoring", { active = false, interactable = false})
    end
    return
  end
  --else

  local planets = ActivePlayer.system and ActivePlayer.system.planets or {}
  local numPlanets = #planets or 0
  for i = 1, 5, 1 do
    ui.batchSet("p"..i.."_Btn_PlasmaScoring", {
      active = i <= numPlanets, interactable = i <= numPlanets,
      isOn = i == Plasma.target,
      sprite = i == Plasma.target and "Icon_PlasmaScoring_Active" or "Icon_PlasmaScoring",
      pressedSprite = i == Plasma.target and "Icon_PlasmaScoring" or "Icon_PlasmaScoring_Active",
    })
  end
end

--set planetIndex = # or nil to remove any target or 0\"default" to find and set to a default target
Plasma.setTarget = function(planetIndex, toggle)
  local target = planetIndex == "default" and 0 or planetIndex or -1
  target = target <= 5 and target or -1 --planets have been capped at having 5 planets

  if toggle and planetIndex == Plasma.target then target = -1 end

  if target == 0 then
    local planets = ActivePlayer.system and ActivePlayer.system.planets or {}
    for i,eachPlanet in ipairs(planets) do
      local _isOn = Planets.getOwner(eachPlanet.name) ~= ActivePlayer.color
      if _isOn then target = i break end
    end
  end

  if Plasma.target == target then return end
  Plasma.target = target > 0 and target or false
  Plasma.updateUI()
end

--MultiRoller functionality-----------------------------------------------------

--[[TacData = {
  activeColor = ""
  activeSystem = {hex = "hex", system = systemTable, guid = system.guid},
  adjacentSystems = {} [perColor] = {["systemGuid1"] = {hex = "hexPosition", system = systemTableRef}, ["g2"] =...}
  adjacentSystems
  unitMap = {}--see MultiRoller.buildUnitMap for details
  hexToUnits
  initialized = bool
}--]]

--location = planetName or "Space"
--infers defender in active system locations
MultiRoller.getDefender = function(location)
  if not location then return end
  local result = "Grey"

  local function getSpaceDefender()
    if not TacData.unitMap or not ActivePlayer.system then return "Grey" end
    local systemData = TacData.unitMap[ActivePlayer.system.guid]
    local activeSpace = systemData and systemData.summary.Space or {}
    for eachCol,_ in pairs(activeSpace or {}) do
      if eachCol ~= ActivePlayer.color then return eachCol end
    end
    return "Grey"
  end

  --Planet owner is defender - even if they are also the active player
  local function getPlanetDefender()
    return Planets.getOwner(location) or "Grey"
  end

  return location == "Space" and getSpaceDefender() or getPlanetDefender()
end

MultiRoller._rollerCache = {}--{[color] = mRoller}
MultiRoller.getRoller = function(pColor)
  if MultiRoller._rollerCache[pColor] ~= nil then return MultiRoller._rollerCache[pColor] end

  local multiRollers = {}
  local colorToPosition = {}
  for _, object in ipairs(getAllObjects()) do
      local name = object.getName()
      if string.match(name, '^TI4 MultiRoller') then
          table.insert(multiRollers, object)
      end
      local color = string.match(name, '^Command Sheet %((%a+)%)$')
      if color then
          colorToPosition[color] = object.getPosition()
      end
  end

  MultiRoller._rollerCache = {}
  for color, p0 in pairs(colorToPosition) do
      local best = false
      local bestDistanceSq = false
      for _, multiRoller in ipairs(multiRollers) do
          local p1 = multiRoller.getPosition()
          local dSq = ((p1.x - p0.x) ^ 2) + ((p1.z - p0.z) ^ 2)
          if (not bestDistanceSq) or (dSq < bestDistanceSq) then
              best = multiRoller
              bestDistanceSq = dSq
          end
      end
      MultiRoller._rollerCache[color] = best
  end

  return MultiRoller._rollerCache[pColor]
end

local ENGAGEMENT_TYPE = {
    SPACE_CANNON_OFFENSE = { name = 'Space Cannon Offense', rollType = 'spaceCannon' },
    ANTI_FIGHTER_BARRAGE = { name = 'Anti-Fighter Barrage', rollType = 'antiFighterBarrage' },
    SPACE_COMBAT = { name = 'Space Combat', rollType = 'spaceCombat' },
    BOMBARDMENT = { name = 'Bombardment', perPlanet = true, rollType = 'bombardment' },
    SPACE_CANNON_DEFENSE = { name = 'Space Cannon Defense', perPlanet = true, rollType = 'spaceCannon' },
    GROUND_COMBAT = { name = 'Ground Combat', perPlanet = true, rollType = 'groundCombat' }
}

function getHexToUnits(units)
    assert(type(units) == 'table')

    local hexToUnits = {}
    for _, unit in ipairs(units) do
        local entry = hexToUnits[unit.hex]
        if not entry then
            entry = {}
            hexToUnits[unit.hex] = entry
        end
        table.insert(entry, unit)
    end
    return hexToUnits
end

MultiRoller.rewritePositionAndHexForInArenaUnits = function(hex, units)
    assert(type(hex) == 'string' and type(units) == 'table')

    local arenaName = 'TI4 Auto-fill MultiRoller Arena'

    -- Allow multiple arena objects to coexist.
    local bbToArenaObject = false
    for _, object in ipairs(getAllObjects()) do
        if object.getName() == arenaName then
            local bounds = object.getBounds()
            local bb = {
                min = {
                    x = bounds.center.x - bounds.size.x,
                    z = bounds.center.z - bounds.size.z,
                },
                max = {
                    x = bounds.center.x + bounds.size.x,
                    z = bounds.center.z + bounds.size.z,
                },
            }
            bbToArenaObject = bbToArenaObject or {}
            bbToArenaObject[bb] = object
        end
    end
    if not bbToArenaObject then
        return false
    end

    local activatedSystem = _systemHelper.getActivatedSystem()
    local activatedSystemObject = getObjectFromGUID(activatedSystem.guid)

    for _, unit in ipairs(units) do
        local p = unit.position
        for bb, arenaObject in pairs(bbToArenaObject) do
            if p.x >= bb.min.x and p.x <= bb.max.x and p.z >= bb.min.z and p.z <= bb.max.z then
                -- unit is in arena bounding box.  Get in-system position to
                -- make sure it is actually in the hex.
                p = activatedSystemObject.positionToWorld(arenaObject.positionToLocal(p))
                if hex == _systemHelper.hexFromPosition(p) then
                    -- Overwrite position data to act like in-hex rather than in-arena.
                    unit.hex = hex
                    unit.position = p  -- world position inside activated system
                end
            end
        end
    end

    return true
end

function getOpponentColor(selfColor, location)
  --print("Getting opponent for ", selfColor, " from ", location)
  return selfColor ~= ActivePlayer.color and ActivePlayer.color or MultiRoller.getDefender(location) or "Grey"
end

local _buildingTacData = false
MultiRoller.buildTacData = function(system, callback)
  if _buildingTacData then return end
  _buildingTacData = true

  system = system or ActivePlayer.system
  if not system then return end
  local systemObj = assert(getObjectFromGUID(system.guid))
  local activeHex = _systemHelper.hexFromPosition(systemObj.getPosition())

  TacData = {
    activePlayer = ActivePlayer.color or "Grey",
    activeSystem = {hex = activeHex, system = system, guid = system.guid},
  --added during coroutine:
    --adjacentSystems
    --unitMap
    --hexToUnits
    --initialized
  }

  local function _getAdjacentSystems()
    local adjacentSystems = {}
    local playableColors = _zoneHelper.zones()
    for _,eachColor in ipairs(playableColors) do
      --return: table of adjacent system guids with hex locations: {["guid1"] = {hex = "hexPosition", system = systemTableRef}, ["g2"] =...}
      adjacentSystems[eachColor] = _systemHelper.getAdjacentSystems({
          color = eachColor,
          system = system.guid,
          highlight = eachColor == ActivePlayer.color and Tac.highlightAdjSystems[ActivePlayer.color]
        })
      coroutine.yield(0)
    end
    TacData.adjacentSystems = adjacentSystems
  end

  local buildTacData = coroutine.create(function()
    coroutine.yield(0)
    coroutine.yield(0)

    _getAdjacentSystems()
    coroutine.yield(0)

    MultiRoller.buildUnitMap(system)
    coroutine.yield(0)

    _buildingTacData = false
    if callback then callback() end
    return 1
  end)

  Coru.run(buildTacData)
end

--[[unitMap_Layout = {
  [systemGUID] = {
    summary = {
      ["Space"] = {[color] = {[Mech] = #,...},},
      ["PlanetName"] = {[color] = {[Mech] = #}}
    },
    details = {
      [color] = {
        [Mech] = {
          total = #, --how many are in system
          count = { --count by location
            ["Space"] = #,
            ["PlanetName"] = #
          },
          units = {
            [guid] = {color = color, location = "Space|PlanetName", hex ="", position = {}}
          }
        }
      }
  }
  },
}--]]
local _hasBuiltUnitMapThisFrame = false
MultiRoller.buildUnitMap = function(system)
  if _hasBuiltUnitMapThisFrame then return end
  _hasBuiltUnitMapThisFrame = Wait.frames(function() _hasBuiltUnitMapThisFrame = false end, 1)

  local unitMap = {}
  local units = _unitHelper.getUnits()
  MultiRoller.rewritePositionAndHexForInArenaUnits(TacData.activeSystem.hex, units)
  local hexToUnits = getHexToUnits(units)
  for unitsHex, eachUnit in pairs(hexToUnits) do
      hexToUnits[unitsHex] = _unitHelper.fillUnitColors(eachUnit)  -- iteration allows overwrites of existing keys
  end

  --location represents a unit's position in game terms: either "Space" or a "Planet Name"
  local function getSystemLocations(system, asTable)
    local result = {["Space"] = asTable and {} or 0}
    for _,eachPlanet in ipairs(system.planets or {}) do
      result[eachPlanet.name] = asTable and {} or 0
    end
    return result
  end

  --transform data into unitMap format
  local _systemIsFormatted = {}
  --pramas: data = {hex, system}
  local function gatherUnits(systemGuid, data)
    --most systems will be referenced in each player's adjacentSystems table. We only need to get its units once.
    if not _systemIsFormatted[systemGuid] then
      _systemIsFormatted[systemGuid] = true

      unitMap[systemGuid] = {summary = getSystemLocations(data.system, true), details = {}}
      local details = unitMap[systemGuid].details
      for eachHex, units in pairs(hexToUnits[data.hex] or {}) do
        if units.color then
          details[units.color] = details[units.color] or {}
          details[units.color][units.unitType] = details[units.color][units.unitType] or {total = 0, count = getSystemLocations(data.system), units = {}}
          local unitDetails = details[units.color][units.unitType]
          unitDetails.units[units.guid] = {hex = units.hex, position = units.position, color = units.color}
          local location = _systemHelper.planetFromPosition({systemGuid = systemGuid,position = units.position, exact = true})
          location = location and location.name or "Space"
          unitDetails.units[units.guid].location = location
          unitDetails.total = details[units.color][units.unitType].total + 1
          unitDetails.count[location] = unitDetails.count[location] + (units.count or 1)
          --printTable(unitMap[systemGuid]
        end
      end
    end
  end

  gatherUnits(system.guid, {hex = TacData.activeSystem.hex, system = system})
  for eachColor, systems in pairs(TacData.adjacentSystems or {}) do
    for systemGuid, data in pairs(systems) do
      gatherUnits(systemGuid, data)
    end
  end
  --add summaries
  for systemGuid,eachSystem in pairs(unitMap) do
    for eachColor,details in pairs(eachSystem.details or {}) do
      for unitType, unitData in pairs(details) do
        for location, count in pairs(unitData.count) do
          if count > 0 then
            eachSystem.summary[location] = eachSystem.summary[location] or {}
            eachSystem.summary[location][eachColor] = eachSystem.summary[location][eachColor] or {}
            eachSystem.summary[location][eachColor][unitType] = count
          end
        end
      end
    end
  end

  TacData.unitMap = unitMap
  TacData.hexToUnits = hexToUnits
  TacData.units = units
  --announce unitMap
  --printTable(unitMap)
  Tac.onGameEvent(Tac.eGameEvents.UnitMapUpdated())
end

local eEngagementTypes = {
  ["groundCombat"] = { name = 'Ground Combat', perPlanet = true, rollType = 'groundCombat' },
  ["spaceCombat"] = { name = 'Space Combat', rollType = 'spaceCombat' },
  ["antifighterBarrage"] = { name = 'Anti-Fighter Barrage', rollType = 'antiFighterBarrage' },
  ["spaceCannonOff"] = { name = 'Space Cannon Offense', rollType = 'spaceCannon' },
  ["spaceCannonDef"] = { name = 'Space Cannon Defense', perPlanet = true, rollType = 'spaceCannon' },
  ["bombardment"] = { name = 'Bombardment', perPlanet = true, rollType = 'bombardment' }
}

local _colorToUnitOverrides_thisFrame = false --*5 frames
function _getColorToUnitOverrides()
  if _colorToUnitOverrides_thisFrame then return _colorToUnitOverrides_thisFrame end
  _colorToUnitOverrides_thisFrame = _unitHelper.getColorToUnitOverrides()
  Wait.frames(function() _colorToUnitOverrides_thisFrame = false end, 5)

  return _colorToUnitOverrides_thisFrame
end

local _colorToUnitModifiers_thisFrame = false --*5 frames
function _getColorToUnitModifiers()
  if _colorToUnitModifiers_thisFrame then return _colorToUnitModifiers_thisFrame end
  _colorToUnitModifiers_thisFrame = _unitHelper.getColorToUnitModifiers()
  Wait.frames(function() _colorToUnitModifiers_thisFrame = false end, 5)

  return _colorToUnitModifiers_thisFrame
end

MultiRoller.getAttributes = function(color, opponentColor, engagementType, location)
  --build unitAttributes
  local colorToUnitOverrides = _getColorToUnitOverrides()
  local colorToUnitModifiers = _getColorToUnitModifiers()

  -- Get per-hex unit attributes.  Per-hex because sometimes flagships modify
  -- peers, opponent non-fighter ships counts matter, etc.
  local useUnits = TacData.hexToUnits[TacData.activeSystem.hex] or {}
  --trim ground units
  if location and location ~= "Space" then
    local function inPlanetZone(unit)
        if unit.unitType == 'Flagship' then
            return true -- always include flagship for modifiers to kick in
        end
        local p = _systemHelper.planetFromPosition({
            systemGuid = ActivePlayer.system.guid,
            position = unit.position,
            exact = false
        })
        return p and p.name == location
    end
    local planetaryUnits = {}
    for _,data in ipairs(useUnits or {}) do
      if inPlanetZone(data) then
        table.insert(planetaryUnits, data)
      end
    end
    useUnits = planetaryUnits
  end

  local colorToUnits = _unitHelper.getColorToUnits(useUnits)
  local unitTypeToCount = _unitHelper.getUnitTypeToCount(colorToUnits[color] or {})
  local opponentUnitTypeToCount = colorToUnits[opponentColor] and _unitHelper.getUnitTypeToCount(colorToUnits[opponentColor]) or {}

  local unitOverrides = colorToUnitOverrides[color] or {}
  local unitAttrs = _unitHelper.getUnitAttributes(unitOverrides)

  local _tacData = copyTable(TacData)
  _tacData.location = location
  _tacData.engagement = engagementType
  --_tacData.combatRound = #

  -- Apply flagships.
  unitAttrs = _unitHelper.applyFlagshipModifiers({
      unitAttrs = assert(unitAttrs),
      myColor = color,
      myUnitTypeToCount = unitTypeToCount,
      opponentColor = opponentColor,
      opponentUnitTypeToCount = opponentUnitTypeToCount,
      TacData = _tacData
  })

  -- Apply unit modifiers.
  unitAttrs = _unitHelper.applyUnitModifiers({
      unitAttrs = assert(unitAttrs),
      myColor = color,
      myUnitModifiers = colorToUnitModifiers[color] or {},
      myUnitTypeToCount = unitTypeToCount,
      opponentColor = opponentColor,
      opponentUnitModifiers = colorToUnitModifiers[opponentColor] or {},
      opponentUnitTypeToCount = opponentUnitTypeToCount,
      TacData = _tacData
  })

  for eachUnit,attributes in pairs(unitAttrs) do
    attributes.count = (attributes.count or 0) + (unitTypeToCount[eachUnit] or 0)
  end
  return unitAttrs
end

--queue functionality added to roll for all planets with 1 click (Bombardment/spaceCannonDef)
MultiRoller.status = {}--[color] = nil or engagementType
MultiRoller.queue = {} --[color] = {}
--Each player may have only 1 queued engagementType at a time.
--That player will be unable to request rolls or queues while the current queue is resolving
MultiRoller.tryNewQueue = function(color)
  return not MultiRoller.status[color] and (MultiRoller.queue[color] == nil or not next(MultiRoller.queue[color]))
end

MultiRoller.resolveEngagement = function(color, engagementType, location, fillOnly)
  assert(eEngagementTypes[engagementType])
  local _multiRollerObj = MultiRoller.getRoller(color)
  assert(_multiRollerObj, "ROLL ABORTED: Could not find the " .. color .. " player's Multi-Roller")

  if(MultiRoller.status[color]) then
    pcall(printToAll("Roll already in progress, " .. engagementType .. " roll aborted.", Color.Red))
    return
  end

  --update/rebuild unit tables
  MultiRoller.buildUnitMap(ActivePlayer.system)

  location = not eEngagementTypes[engagementType].perPlanet and "Space" or assert(location)
  local opponent = getOpponentColor(color, location)
  local rollType = eEngagementTypes[engagementType].rollType
  local unitAttributes = MultiRoller.getAttributes(color, opponent, engagementType, location)

  local function countRangedUnits(unitType, unitData)
    if not unitData[rollType].range or unitData[rollType].range < 1 then return 0 end
    if engagementType == "spaceCannonDef" then return 0 end --not emplemented
    local result = 0
    --giving ground units range allows them to roll combat for each planet IN their system
    if engagementType == "groundCombat" then
      activeSystemMap = TacData.unitMap[TacData.activeSystem.system.guid] or false
      if not activeSystemMap or not activeSystemMap.details[color] or not activeSystemMap.details[color][unitType] then return result end
      for eachLocation, localCount in pairs(activeSystemMap.details[color][unitType].count or {}) do
        if eachLoaction == "Space" then
          result = result + (unitData[rollType].requireGround and 0 or localCount)
        elseif eachLocation ~= location then --we're only counting units on other adjacent planets in the system
          result = result + localCount
        end
      end

      return result
    end
    --else, range allows units in adjacent systems to participate
    for eachSystem, mapData in pairs(TacData.unitMap) do
      if eachSystem ~= TacData.activeSystem.system.guid and mapData.details[color] and mapData.details[color][unitType] then
        if unitData[rollType].requireGround then
          result = result + (mapData.details[color][unitType].total - mapData.details[color][unitType].count.Space)
        elseif unitData[rollType].requireSpace then
          result = result + mapData.details[color][unitType].count.Space
        else
          result = result + mapData.details[color][unitType].total
        end
      end
    end

    return result
  end

  --build table of units that will participate in this roll
  local engagedUnitCount = {}
  for unitType,unitData in pairs(unitAttributes) do
    if unitData[rollType] then --only count units that can make this roll
      --count units in and adjacentHex
      unitData.count = (unitData.count or 0) + countRangedUnits(unitType, unitData)
      --apply unit limits (Experimental Battlestation)
      if unitData[rollType].unitLimit then
        unitData.count = unitData.count <= unitData[rollType].unitLimit and unitData.count or unitData[rollType].unitLimit
      end
      engagedUnitCount[unitType] = unitData.count
    end
  end

  local plasmaScoring = false
  if engagementType == "bombardment" then
    if PShield.hasActiveShield(location) then pcall(broadcastToAll("Unable to bombard: "..location.." is protected by a planetary shield.", "Red")) return end
    plasmaScoring = Plasma.target and Planets.getName(Plasma.target) == location
  elseif engagementType == "spaceCannonDef" or engagementType == "spaceCannonOff" then
    local uMods = _getColorToUnitModifiers()
    for _,eachMod in ipairs(uMods[color] or {}) do
      if eachMod == "Plasma Scoring" then plasmaScoring = true break end
    end
  end

  -- Nebula Defence?
  local extraUnitModifiers = false
  local function isNebula()
      for _, anomaly in ipairs(ActivePlayer.system.anomalies or {}) do
          if anomaly == 'nebula' then
              return true
          end
      end
  end
  if isNebula() and color ~= ActivePlayer.color then
      extraUnitModifiers = extraUnitModifiers or {}
      table.insert(extraUnitModifiers, 'Nebula Defence')
  end

  local function generateMsg()
    local prefix = { 'AutoRoll ' .. eEngagementTypes[engagementType].name }
    if location ~= "Space" then
        table.insert(prefix, '(' .. location .. ')')
    end
    table.insert(prefix, color .. ' vs ' .. (opponent or '<unknown>'))
    local message = table.concat(prefix, ' ') .. ': '

    local messages = {}
    --[[
    for unitType, count in pairs(fillUnitTypeToCount) do
        if count > 0 then
            local name = unitType
            if count > 1 and unitType ~= 'Infantry' and unitType ~= 'PDS' then
                name = name .. 's'
            end
            local message = count .. ' ' .. name
            if adjacentUnitTypeToCount[unitType] and adjacentUnitTypeToCount[unitType] > 0 then
                message = message .. ' (' .. adjacentUnitTypeToCount[unitType] .. ' adjacent)'
            end
            if psUnitType == unitType then
                message = message .. ' (Plasma Scoring)'
            end
            table.insert(messages, message)
        end
    end--]]
    if #messages == 0 then
        if engagementType == ENGAGEMENT_TYPE.BOMBARDMENT and planetaryShield then
            table.insert(messages, 'no units (Planetary Shield)')
        else
            table.insert(messages, 'no units')
        end
    end
    --[[
    if fillUnitTypeToCount['Flagship'] and fillUnitTypeToCount['Flagship'] > 0 then
        for _, modifier in ipairs(unitTypeToAttrs._flagshipModifiers) do
            if modifier.isCombat and modifier.type == 'mutate' then
                table.insert(messages, '(' .. modifier.name .. ': ' .. modifier.description .. ')')
            end
        end
    end
    for _, modifier in ipairs(unitTypeToAttrs._unitModifiers) do
        if modifier.isCombat and modifier.type == 'mutate' then
            table.insert(messages, '(' .. modifier.name .. ': ' .. modifier.description .. ')')
        end
    end

    if psAlreadyUsed then
        table.insert(messages, '(Plasma Scoring was used on “' .. _bombardmentPlasmaScoringOnPlanet .. '”)')
    end--]]

    if #messages > 0 then
        message = message .. table.concat(messages, ', ') .. '.'
    end
  end
  pcall(printToAll(generateMsg(), color))

  if fillOnly then
    pcall(printToColor('AutoFill: Units filled; left click to fill and roll.', params.clickerColor, "Yellow"))
  else
    MultiRoller.status[color] = true
  end

  --printTable(unitAttributes)
  --printTable(engagedUnitCount)
  local doClick = not fillOnly
  _multiRollerObj.call('inject', {
      clickerColor = color,
      vsColor = opponent,
      unitTypeToCount = engagedUnitCount,
      plasmaScoring = plasmaScoring,
      rollType = doClick and rollType or false,
      extraModifiers = extraUnitModifiers or false,
      location = location,
      callback = doClick and {guid = self.getGUID(), obj = self, func = "onMultirollComplete"} or nil
  })
end

--cannot queue fillOnly rolls
MultiRoller.queueEngagement = function(color, engagementType, location)
  if(not MultiRoller.status[color]) then
    MultiRoller.resolveEngagement(color, engagementType, location)
  else
    if(MultiRoller.queue[color] == nil) then
      MultiRoller.queue[color] = {}
    end
    table.insert(MultiRoller.queue[color], {engagementType = engagementType, location = location})
  end
end

function onMultirollComplete(params)
  params = params or {}
  local color = params.color
  if params.error then
    pcall(printToAll("An error occored during the roll: \n" .. params.error, Color.Red))
  end

  MultiRoller.status[color] = false
  if MultiRoller.queue[color] and next(MultiRoller.queue[color]) then
    local nextRoll = table.remove(MultiRoller.queue[color], 1)
    MultiRoller.resolveEngagement(color, nextRoll.engagementType, nextRoll.location)
  end
end

function autoFillCoroutine()
    local params = assert(table.remove(_autoFillQueue))
    assert(type(params.clickerColor) == 'string', 'clickerColor')
    assert(type(params.altClick) == 'boolean', 'altClick')
    assert(ENGAGEMENT_TYPE[params.autoFillType], 'autoFillType')
    assert(not params.planetIndex or type(params.planetIndex) == 'number', 'planetIndex')

    local autofillTypeAttributes = assert(ENGAGEMENT_TYPE[params.autoFillType])

    --updateColorToMultiRoller()
    coroutine.yield(0)

    local multiRoller = MultiRoller.getRoller(params.rollColor)
    if not multiRoller then
        printToAll(TAG .. ': no MultiRoller for ' .. params.clickerColor, {1,0,0})
        return 1
    end

    local system = _systemHelper.getActivatedSystem()
    local systemObject = system and getObjectFromGUID(system.guid)
    if not systemObject then
        printToAll(TAG .. ': no activated system', {1,0,0})
        return 1
    end

    local activatingColor = Turns.turn_color
    if not activatingColor then
        printToAll(TAG .. ': no activating player', {1,0,0})
        return 1
    end

    -- Get units in hex and adjacent (including wormholes) systems.
    local hex, adjacentHexes = getHexAndAdjacent(systemObject.getPosition(), params.clickerColor)
    coroutine.yield(0)
    local units = _unitHelper.getUnits()
    coroutine.yield(0)
    rewritePositionAndHexForInArenaUnits(hex, units)
    coroutine.yield(0)
    local hexToUnits = getHexToUnits(units)
    for unitsHex, units in pairs(hexToUnits) do
        hexToUnits[unitsHex] = _unitHelper.fillUnitColors(units)  -- iteration allows overwrites of existing keys
    end
    coroutine.yield(0)

    local colorToUnitOverrides = _unitHelper.getColorToUnitOverrides()
    coroutine.yield(0)
    local colorToUnitModifiers = _unitHelper.getColorToUnitModifiers()
    coroutine.yield(0)

    -- Get per-hex unit attributes.  Per-hex because sometimes flagships modify
    -- peers, opponent non-fighter ships counts matter, etc.
    local function getUnitAttrs(units, color, opponentColor)
        local colorToUnits = _unitHelper.getColorToUnits(units)
        local unitTypeToCount = _unitHelper.getUnitTypeToCount(colorToUnits[color] or {})
        local opponentUnitTypeToCount = _unitHelper.getUnitTypeToCount(colorToUnits[opponentColor] or {})

        local unitOverrides = colorToUnitOverrides[color] or {}
        local unitAttrs = _unitHelper.getUnitAttributes(unitOverrides)

        -- Apply flagships.
        unitAttrs = _unitHelper.applyFlagshipModifiers({
            unitAttrs = assert(unitAttrs),
            myColor = color,
            myUnitTypeToCount = unitTypeToCount,
            opponentColor = opponentColor,
            opponentUnitTypeToCount = opponentUnitTypeToCount
        })

        -- Apply unit modifiers.
        unitAttrs = _unitHelper.applyUnitModifiers({
            unitAttrs = assert(unitAttrs),
            myColor = color,
            myUnitModifiers = colorToUnitModifiers[color] or {},
            myUnitTypeToCount = unitTypeToCount,
            opponentColor = opponentColor,
            opponentUnitModifiers = colorToUnitModifiers[opponentColor] or {},
            opponentUnitTypeToCount = opponentUnitTypeToCount
        })

        return unitAttrs
    end

    -- If a planet is given, restrict to ground combat units.  Need to get
    -- attributes in order to apply fighters-on-ground, even through do not yet
    -- know opponent color (attributes may be slightly off, but good enough).
    local planet = false
    if params.planetIndex then
        if system and system.planets and #system.planets >= params.planetIndex then
            planet = system.planets[params.planetIndex].name

            local function inPlanetZone(unit)
                if unit.unitType == 'Flagship' then
                    return true -- always include flagship for modifiers to kick in
                end
                if unit.groundCombat and unit.groundCombat.anyPlanet then
                    return true
                end
                local p = _systemHelper.planetFromPosition({
                    systemGuid = system.guid,
                    position = unit.position,
                    exact = false
                })
                return p and (p.name == planet)
            end

            for unitsHex, units in pairs(hexToUnits) do
                local useUnits = {}
                if unitsHex == hex then
                    local units = hexToUnits[hex]
                    for _, unit in ipairs(units) do
                        if inPlanetZone(unit) then
                            table.insert(useUnits, unit)
                        end
                    end
                end
                hexToUnits[unitsHex] = useUnits
            end
        end
    end
    coroutine.yield(0)

    -- Deduce enemy color as the only non-self in the system.
    local selfColor = params.clickerColor
    local enemyColor = getOpponentColor(selfColor, activatingColor, hexToUnits[hex] or {})

    -- Split into self and enemy units.
    local adjacentHexSet = {}
    for _, adjacentHex in ipairs(adjacentHexes) do
        adjacentHexSet[adjacentHex] = true
    end
    local selfUnitsInHex = {}
    local enemyUnitsInHex = {}
    local selfUnitsAdjacent = {}
    for unitHex, units in pairs(hexToUnits) do
        for _, unit in ipairs(units) do
            if unitHex == hex then
                if unit.color == selfColor then
                    table.insert(selfUnitsInHex, unit)
                elseif unit.color == enemyColor then
                    table.insert(enemyUnitsInHex, unit)
                end
            elseif adjacentHexSet[unit.hex] and unit.color == selfColor then
                table.insert(selfUnitsAdjacent, unit)
            end
        end
    end
    local selfUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsInHex)
    local enemyUnitTypeToCount = _unitHelper.getUnitTypeToCount(enemyUnitsInHex)
    local selfAdjUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsAdjacent)
    coroutine.yield(0)

    -- Is bombardment allowed?
    local planetaryShield = false
    if enemyColor then
        local unitTypeToAttrs = assert(getUnitAttrs(hexToUnits[hex] or {}, enemyColor, selfColor))
        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.planetaryShield and (enemyUnitTypeToCount[unitType] or 0) > 0 then
                planetaryShield = true
                break
            end
        end
    end
    local unitTypeToAttrs = assert(getUnitAttrs(hexToUnits[hex] or {}, selfColor, enemyColor))
    for unitType, attrs in pairs(unitTypeToAttrs) do
        if attrs.disablePlanetaryShield and (selfUnitTypeToCount[unitType] or 0) > 0 then
            planetaryShield = false
            break
        end
    end
    coroutine.yield(0)

    -- Apply any require{Ground|Space} attributes.
    if autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_COMBAT then
        local warnUnitSet = {}
        local keep = {}
        for _, unit in ipairs(selfUnitsInHex) do
            local attrs = unitTypeToAttrs[unit.unitType] or {}
            if attrs.spaceCombat and attrs.spaceCombat.requireSpace then
                if not warnUnitSet[unit.unitType] then
                    warnUnitSet[unit.unitType] = true
                    local name = attrs.name or unitType
                    printToAll('Place ' .. name .. ' in space for space combat.', params.clickerColor)
                end
                local p = _systemHelper.planetFromPosition({
                    systemGuid = system.guid,
                    position = unit.position,
                    exact = true
                })
                if not p then
                    table.insert(keep, unit)  -- not on a planet
                end
            else
                table.insert(keep, unit)
            end
        end
        selfUnitsInHex = keep
        selfUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsInHex)
    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.GROUND_COMBAT then
        local warnUnitSet = {}
        local keep = {}
        for _, unit in ipairs(selfUnitsInHex) do
            local attrs = unitTypeToAttrs[unit.unitType] or {}
            if attrs.groundCombat and attrs.groundCombat.requireGround then
                if not warnUnitSet[unit.unitType] then
                    warnUnitSet[unit.unitType] = true
                    local name = attrs.name or unitType
                    printToAll('Place ' .. name .. ' on a planet for ground combat.', params.clickerColor)
                end
                local p = _systemHelper.planetFromPosition({
                    systemGuid = system.guid,
                    position = unit.position,
                    exact = true
                })
                if p then
                    table.insert(keep, unit)  -- on the planet
                end
            else
                table.insert(keep, unit)
            end
        end
        selfUnitsInHex = keep
        selfUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsInHex)
    end

    -- Apply any per-unit limits (Experimental Battlestation).
    local function applyUnitLimit(unitLimit, inHex, adjHex)
        local avail = unitLimit
        inHex = math.min(inHex, avail)
        avail = avail - inHex
        adjHex = math.min(adjHex, avail)
        return inHex, adjHex
    end

    -- Now get just the units that matter for the combat type.
    local fillUnitTypeToCount = {}
    local adjacentUnitTypeToCount = {}
    if autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_CANNON_OFFENSE then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.spaceCannon then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
                if attrs.spaceCannon.range and attrs.spaceCannon.range > 0 then
                    fillUnitTypeToCount[unitType] = fillUnitTypeToCount[unitType] + (selfAdjUnitTypeToCount[unitType] or 0)
                    adjacentUnitTypeToCount[unitType] = (adjacentUnitTypeToCount[unitType] or 0) + (selfAdjUnitTypeToCount[unitType] or 0)
                end
                if attrs.spaceCannon.unitLimit then
                    local a, b = applyUnitLimit(attrs.spaceCannon.unitLimit, fillUnitTypeToCount[unitType], adjacentUnitTypeToCount[unitType])
                    fillUnitTypeToCount[unitType] = a
                    adjacentUnitTypeToCount[unitType] = b
                end
            end
        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.ANTI_FIGHTER_BARRAGE then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.antiFighterBarrage then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
            end
        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_COMBAT then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.spaceCombat then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
            end
        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.BOMBARDMENT then

        if not planetaryShield then
            for unitType, attrs in pairs(unitTypeToAttrs) do
                if attrs.bombardment then
                    fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
                end
            end

            if not _bombardmentPlasmaScoringOnPlanet then
                _bombardmentPlasmaScoringOnPlanet = planet
            end

        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_CANNON_DEFENSE then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.spaceCannon then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
                if unitType == 'Space Dock' then
                    fillUnitTypeToCount[unitType] = 0  -- Experimental Battlestation does not apply
                end
            end
        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.GROUND_COMBAT then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.groundCombat or unitType == 'Flagship' then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
            end
        end

        -- Reset for L1Z1X Harrow (bombardment each ground combat round).
        _bombardmentPlasmaScoringOnPlanet = false

    else
        error(TAG .. ' unknown type "' .. typeAttributes.name .. "'")
    end

    if unitTypeToAttrs['Flagship'].spaceCombat.diceAsCount then
        fillUnitTypeToCount['Flagship'] = unitTypeToAttrs['Flagship'].spaceCombat.dice
    end

    -- Plasma scoring.  Using it, and for which unit?
    local plasmaScoring = false
    for _, modifier in ipairs(colorToUnitModifiers[selfColor] or {}) do
        if modifier == 'Plasma Scoring' then
            plasmaScoring = true
            break
        end
    end

    -- Disable plasma scoring when bombarding a second planet.
    local psAlreadyUsed = false
    if autofillTypeAttributes == ENGAGEMENT_TYPE.BOMBARDMENT and _bombardmentPlasmaScoringOnPlanet and _bombardmentPlasmaScoringOnPlanet ~= planet then
        psAlreadyUsed = plasmaScoring
        plasmaScoring = false
    end

    -- Compute best PS unit based on available candidates.  Assigns extra die
    -- to the best non-zero-count unit.
    local psUnitType = false
    if plasmaScoring then
        local fillUnits = {}
        for unitType, count in pairs(fillUnitTypeToCount) do
            if count > 0 then
                table.insert(fillUnits, { unitType = unitType, color = selfColor, count = 1 })
            end
        end
        local fillUnitTypeToAttrs = getUnitAttrs(fillUnits, selfColor, enemyColor)
        for unitType, attrs in pairs(fillUnitTypeToAttrs) do
            if autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_CANNON_OFFENSE then
                if attrs.spaceCannon and (attrs.spaceCannon.extraDice or 0) > 0 then
                    psUnitType = unitType
                    break
                end
            elseif autofillTypeAttributes == ENGAGEMENT_TYPE.BOMBARDMENT then
                if attrs.bombardment and (attrs.bombardment.extraDice or 0) > 0 then
                    psUnitType = unitType
                    break
                end
            elseif autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_CANNON_DEFENSE then
                if attrs.spaceCannon and (attrs.spaceCannon.extraDice or 0) > 0 then
                    psUnitType = unitType
                    break
                end
            end
        end
    end

    -- Nebula Defence?
    local extraUnitModifiers = false
    local function isNebula()
        for _, anomaly in ipairs(system.anomalies or {}) do
            if anomaly == 'nebula' then
                return true
            end
        end
    end
    if isNebula() and selfColor ~= activatingColor then
        extraUnitModifiers = extraUnitModifiers or {}
        table.insert(extraUnitModifiers, 'Nebula Defence')
    end

    local prefix = { 'AutoFill ' .. autofillTypeAttributes.name }
    if planet then
        table.insert(prefix, '(' .. planet .. ')')
    end
    table.insert(prefix, selfColor .. ' vs ' .. (enemyColor or '<unknown>'))
    local message = table.concat(prefix, ' ') .. ': '

    local messages = {}
    for unitType, count in pairs(fillUnitTypeToCount) do
        if count > 0 then
            local name = unitType
            if count > 1 and unitType ~= 'Infantry' and unitType ~= 'PDS' then
                name = name .. 's'
            end
            local message = count .. ' ' .. name
            if adjacentUnitTypeToCount[unitType] and adjacentUnitTypeToCount[unitType] > 0 then
                message = message .. ' (' .. adjacentUnitTypeToCount[unitType] .. ' adjacent)'
            end
            if psUnitType == unitType then
                message = message .. ' (Plasma Scoring)'
            end
            table.insert(messages, message)
        end
    end
    if #messages == 0 then
        if autofillTypeAttributes == ENGAGEMENT_TYPE.BOMBARDMENT and planetaryShield then
            table.insert(messages, 'no units (Planetary Shield)')
        else
            table.insert(messages, 'no units')
        end
    end

    if fillUnitTypeToCount['Flagship'] and fillUnitTypeToCount['Flagship'] > 0 then
        for _, modifier in ipairs(unitTypeToAttrs._flagshipModifiers) do
            if modifier.isCombat and modifier.type == 'mutate' then
                table.insert(messages, '(' .. modifier.name .. ': ' .. modifier.description .. ')')
            end
        end
    end
    for _, modifier in ipairs(unitTypeToAttrs._unitModifiers) do
        if modifier.isCombat and modifier.type == 'mutate' then
            table.insert(messages, '(' .. modifier.name .. ': ' .. modifier.description .. ')')
        end
    end

    if psAlreadyUsed then
        table.insert(messages, '(Plasma Scoring was used on “' .. _bombardmentPlasmaScoringOnPlanet .. '”)')
    end

    if #messages > 0 then
        message = message .. table.concat(messages, ', ') .. '.'
    end
    printToAll(message, params.clickerColor)

    local doClick = not params.altClick
    multiRoller.call('inject', {
        clickerColor = params.clickerColor,
        vsColor = enemyColor,
        unitTypeToCount = fillUnitTypeToCount,
        plasmaScoring = plasmaScoring and true or false,
        rollType = doClick and autofillTypeAttributes.rollType or false,
        extraModifiers = extraUnitModifiers or false,
        rollObjectGuid = _rollOnSelf and self.getGUID(),
    })
    if not doClick then
        printToAll('AutoFill: left click to fill and roll.', params.clickerColor)
    end

    return 1
end

--UI button events--------------------------------------------------------------
function onButtonClicked_TacState(clickPlayer, btnIsOn, btnID)
  local switch = {
    ["Btn_MovementState"] = Tac.eStates.Movement(),
    ["Btn_SpaceCombatState"] = Tac.eStates.SpaceCombat(),
    ["Btn_InvasionState"] = Tac.eStates.Invasion(),
  }
  assert(switch[btnID])
  Tac.onGameEvent(Tac.eGameEvents.TacStepBtnClicked(), {activate = btnIsOn, tacStep = switch[btnID]})
end

function onButtonClicked_MulitRoller(clickPlayer, mouseBtn, btnID)
  local clickType = mouseBtn == "-1" and "roll" or mouseBtn == "-2" and "fill" or false
  if not clickType then return end

  local rollTarget = assert(ui.btnLookup[btnID].rollTarget)
  local function resolve(engagementType, location)
    engagementType = engagementType or rollTarget
    MultiRoller.resolveEngagement(clickPlayer.color, engagementType, location, clickType == "fill" and true or false)
  end

  local function resolveMovement()
    pcall(printToAll(">>Movement finalized>>", "Teal"))
    MultiRoller.buildTacData(ActivePlayer.system)
  end

  local function resolveAtFocusPlanet(engagementType)
    local planetTarget = Invasion.focus
    if not planetTarget then
      local soloPlanet = ActivePlayer.system and ActivePlayer.system.planets and ActivePlayer.system.planets[1] or false
      if not soloPlanet then
        engagementType = engagementType or rollTarget
        pcall(printToAll("Select a planet before rolling for ".. engagementType..".", "Yellow"))
        return -1
      end
      planetTarget = soloPlanet.name
    end
    resolve(engagementType, planetTarget)
  end

  local function resolveContext()
    if not Invasion.context then return end
    resolveAtFocusPlanet(Invasion.context)
  end

  local switch = {
    ["spaceCombat"] = resolve,
    ["antifighterBarrage"] = resolve,
    ["spaceCannonOff"] = resolve,
    ["spaceCannonDef"] = resolveAtFocusPlanet,
    ["bombardment"] = resolveAtFocusPlanet,
    ["groundCombat"] = resolveAtFocusPlanet,
    ["confirmMovement"] = resolveMovement,
    ["invasionContext"] = resolveContext,
    ["catch"] = function() print("Caught unregistered case >", rollTarget, "< from >",btnID,"< in onBtnClicked_MultiRoller") end
  }
  local try = switch[rollTarget] and rollTarget or "catch"
  switch[try]()
end

function onSmartButtonClicked(clickPlayer, mouseBtn, btnID)
  local clickType = mouseBtn == "-1" and "roll" or mouseBtn == "-2" and "fill" or false
  if not clickType then return end
  local rollTarget = assert(ui.btnLookup[btnID].rollTarget)
  local smartColor = ui.btnLookup[btnID].smart == "attacker" and {ActivePlayer.color} or {self.UI.getAttribute(btnID, "color")}
  local function clickerCanRollFor(color)
    if not Tac.rollForMe[color] and clickPlayer.color ~= smartColor then
      if color == "Grey" or color == "Black" then
        pcall(printToColor("No smart target detected.", clickPlayer.color, "Yellow"))
      else
        pcall(printToColor("The ".. color .. " player has disabled Roll-For-Me.", clickPlayer.color, "Yellow"))
      end
      return false
    end

    return true
  end

  --Some smart buttons may roll for multiple defenders(spaceCannon). Schedule resolution for each of these colors
  if smartColor[1] == "Grey" and rollTarget ~= "bombardment" and (rollTarget ~= "invasionContext" or Invasion.context ~= "bombardment") then
    smartColor = {}
    local _factionCols = _factionHelper.allFactions()
    for eachCol,data in pairs(_factionCols) do
      if eachCol ~= ActivePlayer.color then
       table.insert(smartColor, eachCol)
      end
    end
  end

  local function resolve(smartCol, engagementType, location)
    engagementType = engagementType or rollTarget
    if not clickerCanRollFor(smartCol) then return end
    MultiRoller.resolveEngagement(smartCol, engagementType, location, clickType == "fill" and true or false)
  end

  local function resolveAtFocusPlanet(smartCol, engagementType)
    local planetTarget = Invasion.focus
    if not planetTarget then
      local soloPlanet = ActivePlayer.system and ActivePlayer.system.planets and ActivePlayer.system.planets[1] or false
      if not soloPlanet then
        engagementType = engagementType or rollTarget
        pcall(printToAll("Select a planet before rolling for ".. engagementType..".", "Yellow"))
        return -1
      end
      planetTarget = soloPlanet.name
    end
    resolve(smartCol, engagementType, planetTarget)
  end

  local function resolveContext(smartCol)
    if not Invasion.context then return -1 end
    return resolveAtFocusPlanet(smartCol, Invasion.context)
  end

  local switch = {
    ["spaceCombat"] = resolve,
    ["antifighterBarrage"] = resolve,
    ["spaceCannonOff"] = resolve,
    ["spaceCannonDef"] = resolveAtFocusPlanet,
    ["bombardment"] = resolveAtFocusPlanet,
    ["groundCombat"] = resolveAtFocusPlanet,
    ["invasionContext"] = resolveContext,
    ["catch"] = function(sCol) print("Caught unregistered case >", rollTarget, "< from >", btnID, "< in onSmartButtonClicked") return -1 end
  }
  local try = switch[rollTarget] and rollTarget or "catch"

  for _,eachCol in ipairs(smartColor) do
    local maybeAbort = switch[try](eachCol)
    if maybeAbort == -1 then return end
  end
end

--Resolves spaceCannonDef or bombardment on all possible planets
function onSmartButtonClicked_AutoResolve(clickPlayer, mouseBtn, btnID)
  if mouseBtn ~= "-1" or not ActivePlayer.system then return end
  local rollTarget = assert(ui.btnLookup[btnID].rollTarget)

  local function clickerCanRollFor(color)
    if not Tac.rollForMe[color] and clickPlayer.color ~= color then
      if color == "Grey" or color == "Black" then
        pcall(printToColor("No smart target detected.", clickPlayer.color, "Yellow"))
      else
        pcall(printToColor("The ".. color .. " player has disabled Roll-For-Me.", clickPlayer.color, "Yellow"))
      end
      return false
    end

    return true
  end

  --Auto resolve each SpcDeff
  if rollTarget == "spaceCannonDef" then
    for _,eachPlanet in ipairs(ActivePlayer.system.planets or {}) do
      local owner = Planets.getOwner(eachPlanet.name)
      if owner ~= "Grey" and owner ~= ActivePlayer.color and clickerCanRollFor(owner) then
        MultiRoller.queueEngagement(owner, "spaceCannonDef", eachPlanet.name)
      end
    end
  --Auto resolve each bombardment
  elseif clickerCanRollFor(ActivePlayer.color) then
    if(not MultiRoller.tryNewQueue(ActivePlayer.color)) then
      if(clickPlayer.color == ActivePlayer.color) then
        printToColor("A roll is already in progress.", clickPlayer.color, Color.Red)
      else
        printToColor("The " .. ActivePlayer.color .." player is already rolling.", clickPlayer.color, Color.Red)
      end
    else
      Plasma.setEnabled(true)
      for _,eachPlanet in ipairs(ActivePlayer.system.planets or {}) do
        local owner = Planets.getOwner(eachPlanet.name)
        if(owner != ActivePlayer.color) then
          MultiRoller.queueEngagement(ActivePlayer.color, "bombardment", eachPlanet.name)
        end
      end
    end
  end
end

function onButtonClicked_InvasionStep(clickPlayer, btnIsOn, btnID)
  local idToState = {
    ["Btn_SpaceCannonDefMode"] = "SpaceCannonDef",
    ["Btn_BombardmentMode"] = "Bombardment",
  }

  --if disabling this state, revert to overview unless a planet is in focus; in which case set to ground combat
  Invasion.setState(btnIsOn and idToState[btnID] or Invasion.focus and Invasion.eStates.GroundCombat() or Invasion.eStates.Overview())
end

function onQuickRollBombardment(clickPlayer, mouseBtn, btnID)
  local clickType = mouseBtn == "-1" and "roll" or mouseBtn == "-2" and "fill" or false
  local pIndex = tonumber(string.sub(btnID, 2, 2)) or false
  local planet = Planets.getName(pIndex)
  if not clickType or not pIndex or not planet then return end

  MultiRoller.resolveEngagement(clickPlayer.color, "bombardment", planet, clickType == "fill" and true or false)
end

function onQuickRollSpaceCannonDef(clickPlayer, mouseBtn, btnID)
  local clickType = mouseBtn == "-1" and "roll" or mouseBtn == "-2" and "fill" or false
  local pIndex = tonumber(string.sub(btnID, 2, 2)) or false
  local planet = Planets.getName(pIndex)
  if not clickType or not pIndex or not planet then return end

  MultiRoller.resolveEngagement(clickPlayer.color, "spaceCannonDef", planet, clickType == "fill" and true or false)
end

function onPlanetButtonClicked(clickerPlayer, planetIndex, btnID)
  Invasion.setFocus(tonumber(planetIndex))
end

function onButtonClicked_PShieldOverride(clickerPlayer, mouseBtn, btnID)
  local clickType = mouseBtn == "-1" and "toggle" or mouseBtn == "-2" and "revert" or false
  local pIndex = tonumber(string.sub(btnID, 2, 2)) or false
  if not clickType or not pIndex or not Invasion.active then return end

  if clickType == "toggle" then
    PShield.toggleOverride(pIndex)
  else
    PShield.setOverride(pIndex, 0)
  end
end

function onPlasmaTargetSelected(clickerPlayer, mouseBtn, btnID)
  if mouseBtn ~= "-1" or not Invasion.active then return end
  local pIndex = tonumber(string.sub(btnID, 2, 2)) or false

  Plasma.setTarget(pIndex, "toggle")
end

function onButtonClicked_LookAtPlayer(clickerPlayer, mouseBtn, btnID)
  if mouseBtn ~= "-1" then return end
  local btnColor = self.UI.getAttribute(btnID, "color")
  lookAtPlayer({clickerPlayer.color, btnColor})
end

--TI4 Event receivers-----------------------------------------------------------

--from "Strategy Card Mat"
function onPlaceTradeGoodsAndSetTurns()
  Tac.onGameEvent(Tac.eGameEvents.StartActionPhase())
end

--Called from _systemHelper
function onSystemActivation(system)
  Tac.onGameEvent(Tac.eGameEvents.SystemActivated(), {color = ActivePlayer.color or Turns.enable and Turns.turn_color, system = system})
end

--Event from Global
--params = {prev = "", phase = "SETUP|DRAFT|STRATEGY|ACTION|AGENDA"}
function onPhaseStart(params)
  if params.phase ~= "ACTION" then
    if Tac.isActionPhase then
      Tac.onGameEvent(Tac.eGameEvents.EndActionPhase())
    end
  elseif not Tac.isActionPhase then
    Tac.onGameEvent(Tac.eGameEvents.StartActionPhase())
  end
end

--global events-----------------------------------------------------------------

local _pingDoOnce = true
function onPlayerPing(player, position, object)

  local function activateSystem()
    local system = _systemHelper.systemFromPosition(position)
    if system then _systemHelper.activateSystem({system = system.guid, color = ActivePlayer.color}) end
  end

  if _pingDoOnce then
    _pingDoOnce = false
  end

  --Set active player to random color
  --local i = math.random(1, #data.playableColors)
  --Tac.setColor({color = data.playableColors[i]})

  --local rgbaVal = "rgba(7.1,1,0.2,1.2)"
  --local subOpacity, matchCount = string.gsub(rgbaVal, "(%d+%.?%d*)%s*%p%s*(%d+%.?%d*)%s*%p%s*(%d+%.?%d*)%s*%p%s*(%d+%.?%d*)", "%1 %2 %3 a")
  --print(subOpacity, " #: ", matchCount)

  --setSystemHighlighter({color = "Blue", enabled = true})
  --setSystemHighlighter({color = "White", toggle = true})
  --activateSystem()
  --MultiRoller.buildUnitMap(ActivePlayer.system)

  Wait.frames(function()
  end, 20)

  --MultiRoller.buildTacData()

  local function debugState()
    print("State|Prev|Transition")
    print(Tac.State, "|", Tac.previousState, "|", Tac.inStateTransition)
  end
  --debugState()
  --ui.setSmartButtonColors()
  --ui.animateHeaderColor(_zoneHelper.zoneFromPosition(position) or "Black")
end

function onPlayerChangeColor(player_color)
  --print("onColorChange >", player_color, "<")
  Coru.waitFrames(40, function() Tac.updateActiveState(nil, {skipAnimation = player_color == Tac.color}) end)
end

local _turnChangeWait = false --{next = color, prev = color}
function onPlayerTurnStart(activeColor, previousColor)
  --print("Turn start event >", activeColor, "<")
  local color = activeColor ~= "" and activeColor or "Grey"
  if not Turns.enable then color = "Grey" end

  local function resolveChange()
    Tac.onGameEvent(Tac.eGameEvents.PlayerTurnStart(), {color = _turnChangeWait.next, prev = _turnChangeWait.prev})
    _turnChangeWait = false
  end

  if _turnChangeWait then
    _turnChangeWait.next = activeColor
    return
  end

  _turnChangeWait = {next = activeColor, prev = previousColor}
  Coru.waitFrames(125, resolveChange)
end

function onObjectRotate(object, spin, flip, player_color, old_spin, old_flip)
  --Track strategy card and active/pass token flips for turn display
  if Tac.State == Tac.eStates.Turns() and not Tac.inStateTransition and flip ~= old_flip then
    local objName = object.getName()
    --Activate/deactive strategy card icons
    if data.stratCards[objName] then
      ui.batchSet("Icon_StratCard_" .. objName,
                  {["color"] = flip <= 5 and data.stratCards[objName].color or "Grey"})

    --Remove player name from active player turn list
    elseif data.activePassedTokens[object] then
      if Tac.State ~= Tac.eStates.Turns() then return end

      Wait.frames(function()
        if flip >= 5 then
          Tac.onGameEvent(Tac.eGameEvents.PlayerPassed())
        elseif Tac.State == Tac.eStates.Turns() then--Reactivate color
          ui.setTurnUI(true)
        end
      end, 24)
    end
  end
end

function onObjectDrop(playerColor, object)
  devMode_systemActivator(playerColor, object)
  _cmdToken.onObjectDrop(playerColor, object)
  ui.onStratDrop(object)
  Planets.onPlanetCardDropped(playerColor, object)
end

function onObjectPickUp(playerColor, object)
  _cmdToken.onObjectPickup(playerColor, object)
end

function onPlayerAction(player, action, targets)
  local function resolveDelete()
    --prevent the _cmdToken from being deleted
    if action == Player.Action.Delete then
      for _,each in ipairs(targets or {}) do
        if each == _cmdToken.obj then return false end
      end
    end
    return true
  end

  local function resolveFlip()
    for _,each in ipairs(targets) do
      if each == _cmdToken.obj then return false
      elseif _cmdToken.dropTokens[each.getGUID()] then
        _cmdToken.onDropTokenFlipped(each.getGUID())
        return true-- false
      end
    end
    return true
  end

  local switch = {
    [Player.Action.FlipOver] = resolveFlip,
    [Player.Action.Delete] = resolveDelete,
    ["catch"] = function() return true end
  }
  local try = switch[action] and action or "catch"
  return switch[try]()
end

--object self events------------------------------------------------------------
function onLoad(save_state)
  self.setLock(true)--temp

  if save_state then
    local state = JSON.decode(save_state)
    _cmdToken.guid = type(state) == "table" and state.cmdGUID or nil
  end

  data.initStratCards()
  self.UI.setCustomAssets(ui.assets)
  local function delayedLoad()
    local function load()
      _cmdToken.canAnimate = true
      Tac.setState(Tac.eStates.Main())
      self.addContextMenuItem("Set Active Player", context_setActivePlayer)
      self.addContextMenuItem("Set State", context_setState)--dev command
      self.addContextMenuItem("Toggle Animations", context_toggleAnimations)
      self.addContextMenuItem('Toggle "Roll For Me"', context_toggleRollForMe)
      self.addContextMenuItem("Look At Me", context_lookAtMe)
      self.addContextMenuItem("Reload", context_reload)
    end

    local function uploadUI()
      self.UI.setXmlTable(ui.xmlTable, ui.assets)
      Wait.condition(load, function() return self.UI.loading == false end, 15, load)
    end
    ui.generateXML(uploadUI)
  end
  Wait.condition(delayedLoad, function() return self.UI.loading == false end, 15, delayedLoad)
  --self.UI.setXmlTable(ui.xmlTable, ui.assets)

  _cmdToken.setDisplayToken()
  _cmdToken.orient()

  Events.addListener({eventName = "phaseStart", objGUID = self.getGUID()})
end

function onSave()
  if _cmdToken.guid then
    return JSON.encode({cmdGUID = _cmdToken.guid})
  end
end

function onDrop(player_color)
  local function release()
    _cmdToken.canAnimate = true
    _cmdToken.setTracking()
  end

  Wait.condition(release, function() return self.resting end , 2.5, release)
end

function onPickUp(player_color)
  _cmdToken.canAnimate = false
  _cmdToken.setTracking(true)
end

function onRotate(spin, flip, player_color, old_spin, old_flip)
  if _cmdToken.tracking then return end
  --print("Called rotate")
  local function release()
    _cmdToken.canAnimate = true
    _cmdToken.setTracking()
  end

  _cmdToken.setTracking(true)
  Wait.condition(release, function() return self.resting end , 2.5, release)
end

function onDestroy()
  --Destroy the Tactician's command token
  if _cmdToken.obj ~= nil then
    ignoreDeletedItem(_cmdToken.guid)
    _cmdToken.obj.destruct()
  end
  --destroy any "drop tokens"
  for each,data in pairs(_cmdToken.dropTokens or {}) do
    getObjectFromGUID(each).destruct()
  end
end

--Context Menu items------------------------------------------------------------
--remeber to clear selection after exiting the context menue: Player[clickerColor].clearSelectedObjects()

function context_setActivePlayer(clickerColor, objPos, obj)
  local function onConfirm(selected, selected_index, player_color)
    selected = selected == "None" and "Grey" or selected
    Tac.onGameEvent(Tac.eGameEvents.NewActivePlayer(), {color = selected})
  end

  local options = _zoneHelper.zones()
  table.insert(options, "None")
  Player[clickerColor].showOptionsDialog("Select a player color", options, "Grey", onConfirm)
  Player[clickerColor].clearSelectedObjects()
end

function context_toggleAnimations(clickerColor, objPos, obj)
  Tac.disableAnimations = not Tac.disableAnimations

  local txt = Tac.disableAnimations and "disabled" or "enabled"
  local col = Tac.disableAnimations and "Red" or "Blue"
  pcall(printToAll("Tactician animations " .. txt, col))
  Player[clickerColor].clearSelectedObjects()
end

function context_toggleRollForMe(clickerColor, objPos, obj)
  Tac.rollForMe[clickerColor] = not Tac.rollForMe[clickerColor]
  local abled = Tac.rollForMe[clickerColor] and "enabled" or "disabled"
  pcall(printToAll("The "..clickerColor.." player has "..abled.." the ability for other players to roll for them on the TI4 Tactician.", clickerColor))
  Player[clickerColor].clearSelectedObjects()
end

function context_lookAtMe(clickerColor, objPos, obj)
  Player[clickerColor].clearSelectedObjects()
  lookAtMe(clickerColor, objPos)
end

--dev context
function context_setState(clickerColor, objPos, obj)
  local options = {}
  for name,each in pairs(Tac.eStates) do
    if each() ~= "Initializing" then
      table.insert(options, name)
    end
  end
  local function onConfirm(selected, selected_index, player_color)
     Tac.setState(selected, {skipAnimation = true})
  end

  Player[clickerColor].showOptionsDialog("Select State", options, "Main", onConfirm)
  Player[clickerColor].clearSelectedObjects()
end

--dev context
function context_reload()
  self.reload()
end

--Misc functions----------------------------------------------------------------

--activate system without turns
function devMode_systemActivator(playerColor, object)
  local tokenName = string.match(object.getName(), '^(.*) Command Token')
  if not tokenName then return end

  local faction = _factionHelper.fromTokenName(tokenName)
  if not faction then return end

  --_system helper will catch the expected case
  if Turns.enable and (Turns.turn_color == playerColor and faction.color == playerColor) then return end

  local system = _systemHelper.systemFromPosition(object.getPosition())
  if not system then
      return
  end

  print("WARNING: devMode_systemActivator has not been disabled")

  Tac.setColor({color =faction.color, skipAnimation = true})
  _systemHelper.activateSystem({color = faction.color, system = system.guid})
end

--Floating command token--------------------------------------------------------
_cmdToken.setDisplayToken = function(_toColor, skipAnimation, tokenLoadedCallback)
 assert(_toColor == nil or type(_toColor) == "string")
 local toColor = _toColor or "Black"

 local function getFactionToken(faction)
   if not faction or type(faction) ~= "table" then return false end

   local factionTokens = {}
   factionTokens[faction.tokenName .. " Command Token"] = true
   local tokenInstance = false
   for _,eachObj in ipairs(getAllObjects()) do
     if factionTokens[eachObj.getName()] then
       return eachObj
     end
   end

   return false
 end

 local function getOrSpawnToken(tCol)
   if _cmdToken.obj ~= nil then return _cmdToken.obj end

   local fromGUID = _cmdToken.guid and getObjectFromGUID(_cmdToken.guid) or false
   if fromGUID then _cmdToken.obj = fromGUID return fromGUID end

   --Search the table for an unpacked faction's command token --Copy that token, and alter it
   local copyData = false
   local factions = _factionHelper.allFactions()
   local factionTokens = {}
   for _,eachFaction in pairs(factions) do
     factionTokens[eachFaction.tokenName .. " Command Token"] = true
   end

   for _, eachObj in ipairs(getAllObjects()) do
     if factionTokens[eachObj.getName()] then
        copyData = eachObj.getData()
       break
     end
   end
   if not copyData then return end --No command tokens on the table

   for k,v in pairs(_cmdToken.data) do
     copyData[k] = v
   end
   copyData.CustomMesh.DiffuseURL = _cmdToken.diffuse
   local atPos = self.positionToLocal(self.getPosition())
   local withRotate = self.getRotation()
   atPos.y = atPos.y + _cmdToken.posOffset.y
   atPos.x = atPos.x + _cmdToken.posOffset.x
   atPos.z = atPos.z + _cmdToken.posOffset.z
   atPos = self.positionToWorld(atPos)
   _cmdToken.obj = spawnObjectData({data = copyData, position = atPos, rotation = withRotate})
   _cmdToken.guid = _cmdToken.obj.getGUID()
   Wait.frames(function()
     _cmdToken.obj.use_gravity = false
     local audio = _cmdToken.obj.getComponent("AudioSource")
     audio.set("mute", true)
   end, 1)

   return _cmdToken.obj
 end

 local tokenObj = getOrSpawnToken(toColor)
 if not tokenObj then return end

 --maybe set the diffuse to look like active faction
 local factionToken = getFactionToken(_factionHelper.fromColor(toColor))
 local targetDiffuse = factionToken and factionToken.getCustomObject().diffuse or _cmdToken.diffuse
 if not toColor then toColor = "Black" end

 local activeDiff = _cmdToken.obj.getCustomObject().diffuse
 if activeDiff == targetDiffuse then if tokenLoadedCallback then tokenLoadedCallback() end return end

 if skipAnimation then
   Coru.run(_cmdToken.updateTokenCoroutine(targetDiffuse, toColor), {callback = tokenLoadedCallback})
 else
   _cmdToken.animateColorChange(toColor, targetDiffuse, tokenLoadedCallback)
 end
end

_cmdToken.updateTokenCoroutine = function(diffuse, color)
  local co = coroutine.create(function()
    if _cmdToken.obj == nil then return end
    _cmdToken.obj.setColorTint(color)
    _cmdToken.obj.setCustomObject({diffuse = diffuse})
    _cmdToken.obj.interactable = false
    ignoreDeletedItem(_cmdToken.guid)
    coroutine.yield(0)
    _cmdToken.obj = _cmdToken.obj.reload()

    while(_cmdToken.obj.loading_custom or _cmdToken.obj.spawning) do coroutine.yield(0) end
    _cmdToken.guid = _cmdToken.obj.getGUID()
    _cmdToken.obj.use_gravity = false
    _cmdToken.obj.interactable = true
    local audio = _cmdToken.obj.getComponent("AudioSource")
    audio.set("mute", true)
  end)

  return co
end

_cmdToken.orient = function()
  if _cmdToken.obj == nil then return end

  local pos = self.positionToLocal(self.getPosition())
  local vec = self.getTransformForward()
  pos.x = pos.x + _cmdToken.posOffset.x
  pos.z = pos.z + _cmdToken.posOffset.z
  pos = self.positionToWorld(pos)
  pos.y = pos.y + _cmdToken.posOffset.y

  _cmdToken.obj.use_gravity = false
  _cmdToken.obj.setPosition(pos)
  _cmdToken.obj.setRotation(self.getRotation())

  local tacScale = self.getScale()
  _cmdToken.obj.setScale({x = _cmdToken.scaleRatio * tacScale.x, y = 1, z = _cmdToken.scaleRatio * tacScale.z})
  _cmdToken.obj.interactable = true
end

_cmdToken.setTracking = function(toState)
  --Comparing (false or coroutine) to (boolean or nil)
  if (_cmdToken.tracking and toState) or (not _cmdToken.tracking and not toState) then return end

  local co = coroutine.create(function()
    while _cmdToken.tracking do
      _cmdToken.orient()
      _cmdToken.obj.interactable = false
      coroutine.yield(0)
    end
  end)
  if toState then
    _cmdToken.tracking = co
    _cmdToken.stopAnimation()
    Coru.run(co)
  else
    Coru.stop(_cmdToken.tracking)
    _cmdToken.tracking = false
    _cmdToken.orient()
  end
end

_cmdToken.onObjectPickup = function(playerColor, object)
  --is this the tac's command token?
  if _cmdToken.obj == nil or object ~= _cmdToken.obj then return end
  --is the token available for pickUp?
  if not _cmdToken.canAnimate or _cmdToken.tracking then return end

  local function onTokenSpawned(obj)
    _cmdToken.canAnimate = true
    _cmdToken.obj = obj
    _cmdToken.guid = obj.getGUID()
    _cmdToken.orient()
  end

  local spawnParams = {
    data = _cmdToken.obj.getData(),
    position = _cmdToken.obj.getPosition(),
    rotation = _cmdToken.obj.getRotation(),
    scale = _cmdToken.obj.getScale(),
    callback_function = onTokenSpawned
  }

  _cmdToken.canAnimate = false
  _cmdToken.dropTokens[_cmdToken.guid] = {obj = _cmdToken.obj, tokenColor = ActivePlayer.color, holder = playerColor, activateColor = ActivePlayer.color, dropping = false}
  _cmdToken.obj.use_grid = true
  _cmdToken.obj.use_gravity = true
  ignoreDeletedItem(_cmdToken.guid)
  local newToken = spawnObjectData(spawnParams)
end

_cmdToken.onObjectDrop = function(playerColor, object)
  local dropToken = _cmdToken.dropTokens[object.getGUID()] or false
  if not dropToken then return end

  local function onDropLanded()
    if dropToken.obj == nil then dropToken = nil return end
    local system = _systemHelper.systemFromPosition(object.getPosition())
    if dropToken.activateColor ~= ActivePlayer.color then Tac.setColor({color = dropToken.activateColor}) end
    if system then _systemHelper.activateSystem({system = system.guid, color = dropToken.activateColor}) end
    coroutine.yield(0)
    dropToken.obj.destruct()
    dropToken = nil
  end

  if not dropToken.dropping then
    dropToken.dropping = true
    --dropToken.dropping = Wait.condition(onDropLanded, function() return dropToken.obj == nil or dropToken.obj.resting end, 1.6, onDropLanded)
    local dropCoru = coroutine.create(function()
      while dropToken.obj ~= nil and not dropToken.obj.resting do
        coroutine.yield(0)
        coroutine.yield(0)
        coroutine.yield(0)
      end

      onDropLanded()
      return 1
    end)

    Coru.run(dropCoru)
  end
  dropToken.obj.interactable = false
end

--When the "drop token" is flipped, it toggle between the color of the active player and the color of the player holding it
--once dropped, it activates the system for the current color
_cmdToken.onDropTokenFlipped = function(tokenGUID)
  local dropToken = _cmdToken.dropTokens[tokenGUID]
  if not dropToken or not _factionHelper.fromColor(dropToken.holder) then return end

  dropToken.activateColor = dropToken.activateColor == dropToken.holder and dropToken.tokenColor or dropToken.holder
  dropToken.obj.setColorTint(dropToken.activateColor)
end

_cmdToken.stopAnimation = function()
  if not _cmdToken.animator or _cmdToken.animator.status ~= "running" then return end

  _cmdToken.animator.stop()
  _cmdToken.orient()
end

_cmdToken.animateColorChange = function(toColor, factionToken, callback)
  if not _cmdToken.canAnimate or _cmdToken.tracking then return end
  --Stop any existing animation
  if _cmdToken.animator and _cmdToken.animator.status == "running" then
    _cmdToken.stopAnimation()
  end

  local lockState = self.getLock()
  self.setLock(true)
  _cmdToken.obj.interactable = false

  local function onComplete()
    self.setLock(lockState)
    _cmdToken.orient()
    if callback then callback() end
  end

  local anim = Animate.newController()
  anim.onComplete = onComplete
  local token = _cmdToken.guid

  anim.addClip("bump_1",
    {co = AnimClip.bump(token, {distance = 0.6, axis = "y", duration = 1.8, lerp = Tween.easeOut}),
    root = true, next = {next = {"bump_1_drop"}}})
  anim.addClip("bump_1_drop", {co = AnimClip.bump(token, {distance = -0.2, axis = "y", duration = 0.2, lerp = Tween.easeOut})})

  anim.addClip("rotateWait", {co = AnimClip.wait(0.1), root = true, next = {next = {"rotationStart"}}})
  anim.addClip("rotationStart", {co = AnimClip.rotate(token, {degrees = (360 *4), axis = "y", duration = 2, lerp = Tween.smooth}),
    next = {next = {"updateToken"}}})
  anim.addClip("Unwind", {co = AnimClip.rotate(token, {degrees = -360 , axis = "y", duration = 0.75, lerp = Tween.easeOut}), endClip = true})
  anim.addClip("bump_2", {co = AnimClip.bump(token, {distance = 0.4, axis = "y", duration = 0.3, lerp = Tween.linear}), next = {next = {"drop"}}})
  anim.addClip("drop", {co = AnimClip.bump(token, {distance = -0.8, axis = "y", duration = 0.4, lerp = Tween.easeOut})})

  if factionToken then anim.addClip("updateToken", {co = _cmdToken.updateTokenCoroutine(factionToken, toColor),
      next = {next = {"flip", "bump_2"}}})
    anim.addClip("flip", {co = AnimClip.rotate(token, {degrees = 360, axis = "z", duration = 0.5, lerp = Tween.easeOut}),
      next = { percent = {["Unwind"] = 0.55}}--{next = {"Unwind", "bump_2"}}
      })
  else
    anim.addClip("updateToken", {co = coroutine.create(function() _cmdToken.obj.setColorTint(toColor) end), next = {next = {"Unwind", "bump_2"}}})
  end

  _cmdToken.animator = anim
  anim.play()
end

_cmdToken.animateActivation = function(callback)
  if not _cmdToken.canAnimate or _cmdToken.tracking then return end
  --Stop any existing animation
  if _cmdToken.animator and _cmdToken.animator.status == "running" then
    _cmdToken.stopAnimation()
  end

  local lockState = self.getLock()
  self.setLock(true)
  _cmdToken.obj.interactable = false

  local function onComplete()
    self.setLock(lockState)
    _cmdToken.orient()
    if callback then callback() end
  end

  local anim = Animate.newController()
  anim.onComplete = onComplete
  local token = _cmdToken.guid

  --Build animation
  local _delta = 0.6
  local _dist = 0.6
  local t1 = 0.5
  local t2 = 0.2
  anim.addClip("Lift", {co = AnimClip.bump(token, {distance = _dist, axis = "y", duration = t1, lerp = Tween.easeOut}),
    root = true, next = {next = {"Dip"}}})
  anim.addClip("Dip", {co = AnimClip.bump(token, {distance = -_dist, axis = "y", duration = t2, lerp = Tween.easeOut}) })
  anim.addClip("Upscale", {co = AnimClip.scale(token, {duration = t1, delta = _delta, lerp = Tween.easeOut}), root = true, next = {next = {"Downscale"}}})
  anim.addClip("Downscale", {co = AnimClip.scale(token, {duration = t2, delta = -_delta, lerp = Tween.easeOut}), endClip = true})

  _cmdToken.animator = anim
  local function play()
    anim.play()
  end

  _cmdToken.setDisplayToken(ActivePlayer.color, true, play)
end

--XML utils---------------------------------------------------------------------

--pass an elementID to preserve the current alpha of the color
XML.rgbaFromName = function(colorName, elementID)
  local preserveOpacity = 1
  if elementID then
    preserveOpacity = XML.getColor(elementID)
    preserveOpacity = preserveOpacity and preserveOpacity.a or 1
  end
  local color = Color.fromString(colorName)
  local colTable = {color.r, color.g, color.b, preserveOpacity}
  return "rgba("..table.concat(colTable,",")..")"
end

--pass an elementID to preserve the current alpha of the color
XML.rgbaFromTable = function(colorTable, elementID)
  local preserveOpacity = colorTable.a or 1
  if elementID then
    preserveOpacity = XML.getColor(elementID)
    preserveOpacity = preserveOpacity and preserveOpacity.a or 1
  end
  local tbl = {colorTable.r, colorTable.g, colorTable.b, preserveOpacity}
  return "rgba("..table.concat(tbl,",")..")"
end

--returns: {r = #, g = #, b = #, a = #} or "ColorName"
XML.getColor = function(elementID, asName)
  local colorString = self.UI.getAttribute(elementID, "color") or false
  if not colorString then return end

  if string.find(colorString, "rgba", 1, true) then
    local rgbaTable = { r = 1, g = 1, b = 1, a = 1}
    local _rgbaNext = {"r","g","b","a"}
    local _next = 1
    for v in string.gmatch(colorString, "(%d+%.?%d*)") do
      rgbaTable[_rgbaNext[_next]] = tonumber(v)
      _next = _next + 1
    end
    return not asName and rgbaTable or Color(rgbaTable):toString()
  elseif string.find(colorString, "#", 1, true) then --not using hex colors in ui, so ignoring
    return nil
  else --is color name
    return asName and colorString or Color.fromString(colorString)
  end
end

--returns: {x = #, y = #}
XML.getOffset = function(elementID)
  local posString = self.UI.getAttribute(elementID, "offsetXY")
  if not posString then return {x = 0, y = 0} end

  local result = {}
  local _next = {"x", "y"}
  local _count = 1
  for val in string.gmatch(posString, "(%-?%d+%.?%d*)") do
    result[_next[_count]] = tonumber(val)
    _count = _count + 1
  end
  return result
end

--returns = {x = #, y = #, z = #}
XML.getScale = function(elementID)
  local scaleString = self.UI.getAttribute(elementID, "scale")
  if not scaleString then return {x = 1, y = 1, z = 1} end

  local result = {}
  local _next = {"x","y","z"}
  local _count = 1
  for val in string.gmatch(scaleString, "(%-?%d+%.?%d*)") do
    result[_next[_count]] = tonumber(val)
    _count = _count + 1
  end
  return result
end

--returns = {x = #, y = #, z = #}
XML.scaleFromString = function(scaleString)
  if not scaleString then return {x = 1, y = 1, z = 1} end

  local result = {}
  local _next = {"x","y","z"}
  local _count = 1
  for val in string.gmatch(scaleString, "(%-?%d+%.?%d*)") do
    result[_next[_count]] = tonumber(val)
    _count = _count + 1
  end
  return result
end

--Object animation clips--------------------------------------------------------

--degrees, axis, duration(time), lerp
AnimClip.rotate = function(objGUID, params)
  local co = coroutine.create(function()
    local obj = getObjectFromGUID(objGUID)
    local t_start = Time.time
    local initialRotation = obj.getRotation()[params.axis]

    while Time.time - t_start <= params.duration do
      if obj == nil then return -1 end
      local percent = (Time.time - t_start)/params.duration

      local rotation = obj.getRotation()
      rotation[params.axis] = Tween.lerp(initialRotation, initialRotation + params.degrees, params.lerp(percent))

      obj.setRotation(rotation)
      coroutine.yield(percent)
    end
  end)

  return co
end

--duration(time), lerp, delta = { x = ^, y = ^, z = ^}(each defaults to 0 -> no change in scale)
AnimClip.scale = function(objGUID, params)
  local co = coroutine.create(function()
    local t_start = Time.time
    local obj = getObjectFromGUID(objGUID)
    local baseScale = obj.getScale()
    if type(params.delta) == "number" then params.delta = {x = params.delta, y = params.delta, z = params.delta} end
    local target = {
      x = (params.delta.x or 0) + baseScale.x,
      y = (params.delta.y or 0) + baseScale.y,
      z = (params.delta.z or 0) + baseScale.z}

    while(Time.time - t_start <= params.duration) do
      if obj == nil then return -1 end
      local percent = (Time.time - t_start)/params.duration

      local pMod = params.lerp(percent)
      obj.setScale({
        x = Tween.lerp(baseScale.x, target.x, pMod),
        y = Tween.lerp(baseScale.y, target.y, pMod),
        z = Tween.lerp(baseScale.z, target.z, pMod)
        })
      coroutine.yield(percent)
    end
    return 1
  end)

  return co
end

--distance, axis, duration, lerp
AnimClip.bump = function(objGUID, params)
  local axis = params.axis or "y"
  local co = coroutine.create(function()
    local obj = getObjectFromGUID(objGUID)
    local t_start = Time.time
    local initPos = obj.getPosition()

    while Time.time - t_start <= params.duration do
      if obj == nil then return -1 end
      local percent = (Time.time - t_start)/params.duration

      local pos = obj.getPosition()
      pos[axis] = Tween.lerp(initPos[axis], initPos[axis] + params.distance, params.lerp(percent))
      obj.setPosition(pos)
      coroutine.yield(percent)
    end
    return 1
  end)

  return co
end

AnimClip.wait = function(delay)
  local co = coroutine.create(function()
    local ti = Time.time
    while Time.time - ti <= delay do
      coroutine.yield((Time.time - ti)/delay)
    end
  end)

  return co
end

Animate.newController = function()
  local animation = {
    name = "",
    status = "waiting", --running, waiting, terminated, complete
    runningCos = {},
    _nextWait = 0.0001,

    clips = {}, -- {[c_id] = clipData}
    --clipData = {co = clipCoroutine, tDelay, pDelay, onComplete, onYield}
    root = {},
    endClip = {},
    sequence = {},
    percentSequence = {},--[c_id] = { [%] = {c_id,...list}}
    waitingPercents = {},

    listeners = {},
  }

  animation.play = function()
    animation.status = "running"
    animation.waitingPercents = animation.percentSequence
    for _,eachID in ipairs(animation.root) do
      animation.startClip(eachID)
    end
  end

  animation.stop = function()
    animation.status = "terminated"
    for _,eachCo in pairs(animation.runningCos) do
      Coru.stop(animation.clips[eachCo].co)
    end
  end

  animation._onComplete = function()
    animation.status = "complete"
    animation.onComplete()

    --print("Animation complete")
    for _,each in ipairs(animation.listeners or {}) do
      each.obj.call(each.callback, {animation.name})
    end
  end

  animation.onComplete = function() end--override me

  animation.addListener = function(callback, callObj)
    table.insert(animation.listeners, {callback = callback, obj = callObj ~= nil and callObj or self})
  end

  animation.onClipComplete = function(c_id, result)
    animation.runningCos[c_id] = nil
    if animation.status == "terminated" then return end

    --Maybe start next
    if animation.sequence[c_id] then
      for _,eachID in pairs(animation.sequence[c_id]) do
        animation.startClip(eachID)
      end
    end

    --If last Then
    if c_id == animation.endClip then
      animation._onComplete()
    end
  end

  animation.onClipYield = function(c_id, result)
    --run yields
    if animation.clips[c_id].onYield then animation.clips[c_id].onYield(result) end

    --start pDelayed clips
    if animation.waitingPercents[c_id] then --and animation.percentSequence[c_id][]
      local pctRemove = {}
      for pct,list in pairs(animation.waitingPercents[c_id]) do
        if result >= pct then
          table.insert(pctRemove, pct)
          for _,eachID in ipairs(list) do
            animation.startClip(eachID)
          end
        end
      end

      for _,each in ipairs(pctRemove) do
        animation.waitingPercents[c_id][each] = nil
      end
      if not next(animation.waitingPercents[c_id]) then animation.waitingPercents[c_id] = nil end
    end
  end

  animation.startClip = function(c_id)
    if animation.status == "terminated" then return end
    local function _clipComplete(result)
      animation.onClipComplete(c_id, result)
    end

    local function _clipYield(result)
      animation.onClipYield(c_id, result)
    end
    local trackYield = animation.clips[c_id].onYield or animation.clips[c_id].next and animation.clips[c_id].next.percent
    --print("Starting ", c_id)
    table.insert(animation.runningCos, c_id)
    Coru.run(animation.clips[c_id].co, {callback = _clipComplete, yieldback = trackYield and _clipYield or nil})
  end

  --clipData = {co = clipCoroutine, onComplete = func, onYield = func, next, root = bool, endClip = bool}
  animation.addClip = function(c_id, clipData)
    clipData.c_id = c_id
    animation.clips[c_id] = clipData

    if clipData.root then table.insert(animation.root, c_id) end
    if clipData.endClip then animation.endClip = c_id end
    if clipData.next then animation.createSequence(c_id, clipData.next) end
  end

  --lists of clip ids that will be played after the given c_id
  --sequenceData = { next = {list of c_ids}, time = {[c_id] = delay}, percent = {[c_id] = %}} p: percentDelay| t: timeDelay(after completion)| c: onComplete(NoDelay)
    --After the main clip ends, time delay will play the next clip after the given amount of time passes
    --percentDelay will play the clip after the main clip reaches the given percentage of completion
  animation.createSequence = function(c_id, sequenceData)
    if sequenceData.next then
      animation.sequence[c_id] = animation.sequence[c_id] or {}
      for _, eachID in ipairs(sequenceData.next) do
        table.insert(animation.sequence[c_id], eachID)
      end
    end

    if sequenceData.percent then
      animation.percentSequence[c_id] = animation.percentSequence[c_id] or {}
      for eachID, percent in pairs(sequenceData.percent) do
        animation.percentSequence[c_id][percent] = animation.percentSequence[c_id][percent] or {}
        table.insert(animation.percentSequence[c_id][percent], eachID)
      end
    end

    local function newWait(t, nextClip)
      local wait = AnimClip.wait(t)
      animation._nextWait = animation._nextWait + 1
      animation.addClip(animation._nextWait, {co = wait, next = nextClip})
      return wait
    end

    if sequenceData.time then
      animation.sequence[c_id] = animation.sequence[c_id] or {}
      for cid, t in pairs(sequenceData.time) do
        local waitClip = newWait(t, cid)
        table.insert(animation.sequence[c_id], waitClip)
      end
    end
  end

  return animation
end

--uiClips-----------------------------------------------------------------------

--optional params = {from, to , duration, lerp}
uiClips.fadeOut = function(elementID, params)
  params = params or {}
  local co = coroutine.create(function()
    local iOpacity = params.from or 1
    local endOpacity = params.to or 0
    local duration = params.duration or 0.25 --seconds
      local _xmlCol = XML.getColor(elementID) or {r = 1, g = 1, b = 1}
    local color = {_xmlCol.r,_xmlCol.g,_xmlCol.b, iOpacity}--preserve current tint
    local lerp = params.lerp or Tween.smooth

    self.UI.setAttributes(elementID, {active = true, color = "rgba("..table.concat(color, ",")..")"})
    coroutine.yield(0)

    local iTime = Time.time
    while Time.time - iTime <= duration do
      local percent = (Time.time - iTime)/duration
      if percent > 1 then percent = 1 end
      local percentModified = lerp(percent)
      color[4] = Tween.lerp(iOpacity, endOpacity, percentModified)

      ui.batchSet(elementID, {color = "rgba("..table.concat(color, ",")..")"})
      coroutine.yield(percent)
    end
    --once invisible, setActive false and reset opacity
    self.UI.setAttribute(elementID, "active", false)
    coroutine.yield(1)
    color[4] = iOpacity
    ui.batchSet(elementID, {active = false, color = "rgba("..table.concat(color, ",")..")"})
    return 1
  end)

  return co
end

--optional params = {from, to , duration, lerp}
uiClips.fadeIn = function(elementID, params)
  params = params or {}
  local co = coroutine.create(function()
    local iOpacity = params.from or 0
    local endOpacity = params.to or 1
    local duration = params.duration or 0.25 --seconds
      local _xmlCol = XML.getColor(elementID) or {r = 1, g = 1, b = 1}
    local color = {_xmlCol.r,_xmlCol.g,_xmlCol.b, iOpacity}--preserve current tint
    local lerp = params.lerp or Tween.smooth

    --initialize the element to starting opacity and make sure its active
    self.UI.setAttributes(elementID, {active = true, color = "rgba("..table.concat(color, ",")..")"})
    coroutine.yield(1)

    local iTime = Time.time
    while Time.time - iTime <= duration do
      local percent = (Time.time - iTime)/duration
      if percent > 1 then percent = 1 end
      local percentModified = lerp(percent)
      color[4] = Tween.lerp(iOpacity, endOpacity, percentModified)

      ui.batchSet(elementID, {color = "rgba("..table.concat(color, ",")..")"})
      coroutine.yield(percent)
    end
    return 1
  end)

  return co
end

uiClips.revertFade = function(elementID, params)
  local colorTable = XML.getColor(elementID) or {r = 1, g = 1, b = 1, a = 1}
  colorTable.a = params and params.from or 1
  ui.batchSet(elementID, {color = XML.rgbaFromTable(colorTable)})
end

--Scale------
uiClips.grow = function(elementID, params)
  return uiClips.scale(elementID, true, params)
end

uiClips.shrink = function(elementID, params)
  return uiClips.scale(elementID, false, params)
end

--params = {origin = {x,y,z}(scale of element normally), magnitude(how much to scale), duration, lerp,}
uiClips.scale = function(elementID, scaleUp, params)
  params = params or {}
  local co = coroutine.create(function()
    local duration = params.duration or 0.25
    local lerp = params.lerp or Tween.smooth

    local originScale = params.origin or XML.getScale(elementID)--{x = #, y = #, z = #}
    local effectMagnitude = params.magnitude or {x = 0.01, y = 0.01, z = 1}
    local iScale = {x = scaleUp and effectMagnitude.x or originScale.x, y = scaleUp and effectMagnitude.y or originScale.y, z = 1}
    local endScale = {x = scaleUp and originScale.x or effectMagnitude.x, y = scaleUp and originScale.y or effectMagnitude.y, z = 1}

    self.UI.setAttributes(elementID, {active = true, scale = iScale.x.." "..iScale.y.." "..iScale.z})
    coroutine.yield(0)
    local t1 = Time.time
    while Time.time - t1 < duration do
      local percent = (Time.time - t1)/duration
      local modifiedPercent = lerp(percent)
      local x = Tween.lerp(iScale.x, endScale.x, modifiedPercent)
      local y = Tween.lerp(iScale.y, endScale.y, modifiedPercent)

      ui.batchSet(elementID, {scale = x.." "..y.." 1"})
      coroutine.yield(percent)
    end
    if not scaleUp then
      self.UI.setAttribute(elementID, "active", false)
      coroutine.yield(1)
    end
    ui.batchSet(elementID, {active = scaleUp and true or false, scale = originScale.x.." "..originScale.y.." 1"})
    return 1
  end)
  return co
end

uiClips.revertScale = function(elementID, params)
  local _scale = params.origin or {x = 1, y = 1, z = 1}
  ui.batchSet(elementID, {scale = _scale.x.." ".._scale.y.." 1"})
end

--Slides------
uiClips.slideIn_Left = function(elementID, params)
  return uiClips.slide(elementID, "LEFT", true, params)
end

uiClips.slideIn_Right = function(elementID, params)
  return uiClips.slide(elementID, "RIGHT", true, params)
end

uiClips.slideIn_Up = function(elementID, params)
  return uiClips.slide(elementID, "UP", true, params)
end

uiClips.slideIn_Down = function(elementID, params)
  return uiClips.slide(elementID, "DOWN", true, params)
end

uiClips.slideOut_Left = function(elementID, params)
  return uiClips.slide(elementID, "LEFT", false, params)
end

uiClips.slideOut_Right = function(elementID, params)
  return uiClips.slide(elementID, "RIGHT", false, params)
end

uiClips.slideOut_Up = function(elementID, params)
  return uiClips.slide(elementID, "UP", false, params)
end

uiClips.slideOut_Down = function(elementID, params)
  return uiClips.slide(elementID, "DOWN", false, params)
end

--params(defaults) = {duration = 0.25, lerp, padding = 1.2, magnitude = {x = #, y = #}}
uiClips.slide = function(elementID, dir, slideIn, params)
  params = params or {}
  slideIn = slideIn and true or false --cast to bool
  local directionToMod = { ["LEFT"] = {target = "x", dir = -1}, ["RIGHT"] = {target = "x", dir = 1}, ["UP"] = {target = "y", dir = -1}, ["DOWN"] = {target = "y", dir = 1}}
  local eDirections = {
    ["Left"] = "LEFT", ["left"] = "LEFT", [4] = "LEFT", ["a"] = "LEFT", ["LEFT"] = "LEFT",
    ["Right"] = "RIGHT", ["right"] = "RIGHT", ["RIGHT"] = "RIGHT", [6] = "RIGHT", ["d"] = "RIGHT",
    ["Up"] = "UP", ["up"] = "UP", ["UP"] = "UP", [8] = "UP", ["w"] = "UP",
    ["Down"] = "DOWN", ["down"] = "DOWN", ["DOWN"] = "DOWN", [2] = "DOWN", ["s"] = "DOWN",
  }

  local dirMod = assert(directionToMod[eDirections[dir]].dir) -- 1 or -1
  local targetDimention = directionToMod[eDirections[dir]].target --"x"or"y"

  local co = coroutine.create(function()
    local restingPos = params.from or XML.getOffset(elementID) --{x = #, y = #}

    local function getSlidePos()
      local dim = tonumber(self.UI.getAttribute(elementID, targetDimention == "x" and "width" or "height") or 100)
      dim = dim*(params.padding or 1.2)
      dim = restingPos[targetDimention] + (dim*dirMod)
      return {x = targetDimention == "x" and dim or restingPos.x, y = targetDimention == "y" and dim or restingPos.y}
    end
    local slidePos = params.magnitude or getSlidePos()--{x = #, y = #} --where is the element when it is fully displaced by the slide effect

    local duration = params.duration or 0.25
    local lerp = params.lerp or Tween.smooth
    local iPos = slideIn and slidePos or restingPos
    local endPos = slideIn and restingPos or slidePos

    self.UI.setAttributes(elementID, { active = true, offsetXY = iPos.x.." "..iPos.y })
    coroutine.yield(0)
    local t1 = Time.time
    while Time.time - t1 < duration do
      local percent = (Time.time - t1)/duration
      local modifiedPercent = lerp(percent)
      local lerpedVal = Tween.lerp(iPos[targetDimention], endPos[targetDimention], modifiedPercent)

      local stringVal = (targetDimention == "x" and lerpedVal or iPos.x).." "..(targetDimention == "y" and lerpedVal or iPos.y)
      ui.batchSet(elementID, {offsetXY = stringVal})
      coroutine.yield(percent)
    end

    if not slideIn then
      self.UI.setAttribute(elementID, "active", false)
      coroutine.yield(1)
    end
    ui.batchSet(elementID, {active = slideIn, offsetXY = restingPos.x .." ".. restingPos.y})

    return 1
  end)

  return co
end

uiClips.revertSlide = function(elementID, params)
  local originalPos = params and params.from or {x = 0, y = 0}
  ui.batchSet(elementID, {offsetXY = originalPos.x .." ".. originalPos.y})
end

--------------------------------------------------------------------------------
Tween.easeIn = function(t)
  return t * t
end

Tween.easeOut = function(t)
  return Tween.flip(Tween.square(Tween.flip(t)))
end

Tween.smooth = function(t)
  return Tween.lerp(Tween.easeIn(t), Tween.easeOut(t), t)
end

Tween.square = function(t)
  return t ^2--Tween.flip(Tween.easeIn(t))
end

Tween.linear = function(t)
  return t
end

Tween.spike = function(t)
  if t <= 0.55 then
    return (Tween.easeIn(t))
  end
  return Tween.flip(Tween.square(t))
end

Tween.flip = function(t)
  return 1 - t
end

Tween.lerp = function(a,b,t)
  return a + (b - a) * t
end

--Coroutine Runner---------------------------------------------------------------
function CoroutineRunner()
  while next(Coru._coroutines) do
    local deadList = {}
    --Progress each coroutine
    for eachCo,callbackData in pairs(Coru._coroutines) do
      local status = coroutine.status(eachCo)
      status = Coru.step[status] and status or "catch"
      local isDead = Coru.step[status](eachCo, callbackData) == -1 or status == "dead"
      if isDead then table.insert(deadList, eachCo) end
    end

    --Empty killQueue
    for _,each in ipairs(Coru._coKillQueue) do
      table.insert(deadList, each)
    end
    Coru._coKillQueue = {}

    --Remove dead coroutines
    for _,each in ipairs(deadList) do
      Coru._coroutines[each] = nil
    end

    coroutine.yield(0)
    --Add any waiting coroutines here
    for _,each in ipairs(Coru._coQueue) do
      Coru._coroutines[each.co] = {callback = each.callback, yieldback = each.yieldback}
    end
    Coru._coQueue = {}
  end

  Coru._coRunner = false
  return 1
end

--callbackData = { yieldback = func (called each time co yeilds), callback = func (called when co ends)}
Coru.run = function(newCo, callbackData)
  if Coru._coRunner then
    table.insert(Coru._coQueue, {co = newCo, callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback})
  else
    Coru._coroutines[newCo] = {callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback}
    Coru._coRunner = startLuaCoroutine(self, "CoroutineRunner")
  end
end

Coru.stop = function(co)
  for _,each in ipairs(Coru._coQueue) do
    if each.co == co then
      if each.callback then each.callback(-1) end
      each = nil
      break
    end
  end
  if not Coru._coroutines[co] then return end

  if Coru._coRunner then
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    table.insert(Coru._coKillQueue, co)
  else
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    Coru._coroutines[co] = nil
  end
end

Coru.wait = function(t, callback)
  local newWait = coroutine.create(function()
    local t1 = Time.time
    while Time.time - t1 < t do
      coroutine.yield(0)
    end
    return 1
  end)

  Coru.run(newWait, {callback = callback})
  return newWait
end

Coru.waitFrames = function(frames, callback)
  assert(frames and type(frames) == "number" and frames >= 1)
  local newWait = coroutine.create(function()
    local count = 0
    while count < frames do
      count = count + 1
      coroutine.yield(0)
    end
    return 1
  end)

  Coru.run(newWait, {callback = callback})
  return newWait
end

-------------------------------------------------------------------------------
function copyTable(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and copyTable(v) or v
        end
        t = copy
    end
    return t
end

function printTable(table)
  if not table or type(table) ~= 'table' then print("Error: printTable() requires a table param.") return end
  if not next(table) then print("Empty") end

  local function typeToPrintable(input)
   if input == nil then return "nil" end
   if type(input) == "string" and input == "" then return '""' end
   if type(input) == 'boolean' then return input and "true" or "false" end
   if type(input) == 'userdata' then return "userData" end
   if type(input) == "function" then return "function" end
   return input
  end

  local function pt(_table, depth)
    local string = ""
    for i = 1, depth, 1 do
      string = string .. "-"
    end

    for k,v in pairs(_table) do
      local keyString = typeToPrintable(k)
      if type(v) == "table" then
        local tableString = string .. keyString .. " = {"
        if not next(v) then tableString = tableString .. "}" end
        print(tableString)
        pt(v, depth + 1)
        print(string .. "}")
      else
        print(string .. keyString .. ": " .. typeToPrintable(v))
      end
    end
  end

  print("______________")
  pt(table, 0)
end

local _deletedItemsGuid = false
function ignoreDeletedItem(guid)
    local deletedItems = _deletedItemsGuid and getObjectFromGUID(_deletedItemsGuid)
    if not deletedItems then
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == 'TI4 Deleted Items' then
                _deletedItemsGuid = object.getGUID()
                deletedItems = object
                break
            end
        end
    end
    if deletedItems then
        deletedItems.call('ignoreGuid', guid)
    end
end

--Embeded toggle button functionality-------------------------------------------
--------------------------------------------------------------------------------
ToggleButton.groups = {}
ToggleButton.btns = {}
ToggleButton.uiTarget = {obj = self, guid = self.getGUID()}
--param is obj ref or obj guid
ToggleButton.setUiTarget = function(param)
  assert(param ~= nil)
  if type(param) == 'string' then
    assert(param ~= "")
    ToggleButton.uiTarget.guid = param
    ToggleButton.uiTarget.obj = getObjectFromGUID(param)
  else
    ToggleButton.uiTarget.obj = param
    ToggleButton.uiTarget.guid = param.getGUID()
  end
end

--params = {name = "groupName/id", members = {stringTable of ui IDs}, activeLimit = #of members able to be active at one time}
ToggleButton.newGroup = function(params)
  assert(params and type(params) == 'table')
  assert(params.name and type(params.name) == 'string' and ToggleButton.groups[params.name] == nil)
  assert(params.activeLimit == nil or type(params.activeLimit) == 'number')

  ToggleButton.groups[params.name] = {name = params.name, members = {}, activeLimit = params.activeLimit or 1, activeQueue = {}, restricting = true}
  if params.members ~= nil then
    if type(params.members) == 'string' then
      assert(ToggleButton.btns[params.members])
      ToggleButton.groups[params.name].members[params.members] = params.members
      ToggleButton.btns[params.members].group = params.name
    else
      assert(type(params.members) == 'table')
      for _,eachID in pairs(params.members) do
        assert(ToggleButton.btns[eachID])
        ToggleButton.groups[params.name].members[eachID] = eachID
        ToggleButton.btns[eachID].group = params.name
      end
    end
  end
end

ToggleButton.setGroupRestricting = function(groupName, toState)
  assert(ToggleButton.groups[groupName])
  assert(toState == nil or type(toState) == 'boolean')

  local group = ToggleButton.groups[groupName]
  if group.restricting == toState then return end

  group.restricting = toState or false
  if toState and #group.activeQueue > group.activeLimit then
    for i = #group.activeQueue, group.activeLimit, -1 do
      ToggleButton.setState(ToggleButton.btns[group.activeQueue[i]], false)
      group.activeQueue[i] = nil
    end
  end
end

ToggleButton.toggleGroupRestricting = function(groupName, toState)
  assert(ToggleButton.groups[groupName])
  ToggleButton.setGroupRestricting(groupName, ToggleButton.groups[groupName].restricting)
end

--Limit is the number of active toggleButtons allowed on at the same time
--max == nil means no limit, a limit of 0 is not supported
ToggleButton.setGroupLimit = function(groupName, max)
  assert(ToggleButton.groups[groupName])
  assert(max == nil or type(max) == 'number' and max ~= 0)
  local newMax = max ~= nil and max or 1000
  local group = ToggleButton.groups[groupName]
  local queueCount = #group.activeQueue
  if group.restricting and queueCount > newMax then
    --deactiveate excess active buttons
    for i = queueCount, group.activeLimit, -1 do
      ToggleButton.setState(ToggleButton.btns[group.activeQueue[i]], false)
      group.activeQueue[i] = nil
    end
  end

  group.activeLimit = newMax
end

ToggleButton.deselectGroupMembers = function(groupName)
  assert(ToggleButton.groups[groupName])

  local group = ToggleButton.groups[groupName]
  local actives = copyTable(group.activeQueue)
  local count = #actives
  for i = count, 0, -1 do
    ToggleButton.setState(ToggleButton.btns[group.activeQueue[i]], false)
  end
end

ToggleButton.group_AddToQueue = function(groupName, buttonID)
  assert(ToggleButton.groups[groupName])
  assert(ToggleButton.btns[buttonID])
  local group = ToggleButton.groups[groupName]
  local button = ToggleButton.btns[buttonID]
  if not group.members[buttonID] or not button.isOn then return end

  table.insert(group.activeQueue, 1, buttonID)
  local count = #group.activeQueue
  if group.restricting and count > group.activeLimit then
    local id = group.activeQueue[count]
    group.activeQueue[count] = nil
    ToggleButton.setState(ToggleButton.btns[id], false)
  end
end

ToggleButton.onGroupMemberStateChange = function(groupName, member, toState)
  assert(groupName and ToggleButton.groups[groupName])
  assert(member and ToggleButton.btns[member])
  assert(toState == nil or type(toState) == 'boolean')

  local _isOn = toState ~= nil and toState or ToggleButton.btns[member].isOn
  if _isOn then
    ToggleButton.group_AddToQueue(groupName, member)
  else
    local group = ToggleButton.groups[groupName]
    if not group.members[member] then return end
    for i = #group.activeQueue, 0, -1 do
      if group.activeQueue[i] == member then
        group.activeQueue[i] = nil
        return
      end
    end
  end
end

ToggleButton.removeFromGroup = function(memberIDs)
  assert(memberIDs ~= nil)

  local group = ""
  local button = ""
  if type(memberIDs) == 'string' then
    assert(ToggleButton.btns[memberIDs])
    button = ToggleButton.btns[memberIDs]
    group = ToggleButton.groups[button.group]
    if group then
      group.members[memberIDs] = nil
      if button.isOn then
        for i = #group.activeQueue, 0, -1 do
          if group.activeQueue[i] == memberIDs then
            group.activeQueue[i] = nil
            i = 0
          end
        end
      end
    end
    button.group = nil
  else
    assert(type(memberIDs) == 'table')
    for _,eachID in pairs(memberIDs) do
      button = ToggleButton.btns[eachID]
      assert(button)
      group = ToggleButton.groups[button.group]
      if group then
        group.members[eachID] = nil
        if button.isOn then
          for i = #group.activeQueue, 0, -1 do
            if group.activeQueue[i] == memberIDs then
              group.activeQueue[i] = nil
              i = 0
            end
          end
        end
      end
      button.group = nil
    end
  end
end

ToggleButton.addToGroup = function(groupName, memberIDs)
  assert(ToggleButton.groups[groupName])
  assert(memberIDs ~= nil)

  local group = ToggleButton.groups[groupName]
  if type(memberIDs) == 'string' then
    assert(ToggleButton.btns[memberIDs])
    if ToggleButton.btns[memberIDs].group ~= nil then  ToggleButton.removeFromGroup(groupName, memberIDs) end
    ToggleButton.btns[memberIDs].group = groupName
    group.members[memberIDs] = memberIDs
    if ToggleButton.btns[memberIDs].isOn then ToggleButton.group_AddToQueue(groupName, eachID) end
  else
    assert(type(memberIDs) == 'table')
    local button = ""
    for _,eachID in pairs(memberIDs) do
      button = ToggleButton.btns[eachID]
      assert(button)
      if button.group ~= groupName then
        if button.group ~= nil then ToggleButton.removeFromGroup(groupName, eachID) end
        button.group = groupName
        group.members[eachID] = eachID
        if button.isOn then ToggleButton.group_AddToQueue(groupName, eachID) end
      end
    end
  end
end

ToggleButton.new = function(params)
  assert(params and type(params) == 'table')
  local toggleBtn =
  {
    id = params.id, --should match the xml id attribute
    onIcon = params.onIcon,
    onIcon_Hover = params.onIcon_Hover,
    onIcon_Pressed = params.onIcon_Pressed,
    onIcon_Disabled = params.onIcon_Disabled,
    offIcon = params.offIcon,
    offIcon_Hover = params.offIcon_Hover,
    offIcon_Pressed = params.offIcon_Pressed,
    offIcon_Disabled = params.offIcon_Disabled,

    onClick = params.onClick,
    onValueChanged = params.onValueChanged,--onValueChanged('id', bool)
    isOn = false,
    isToggleButton = true, --type check, don't change
  }
  self.UI.setAttributes(toggleBtn.id, {
    transition = "SpriteSwap",
    isOn = false,
    onClick = "onToggleClicked"
  })
  ToggleButton.btns[toggleBtn.id] = toggleBtn
  ToggleButton.setSprite(toggleBtn, false)
  return toggleBtn
end

ToggleButton.newAsXmlTable = function(params)
  assert(params and type(params) == 'table')
  local toggleBtn =
  {
    id = params.id,
    onIcon = params.onIcon,
    onIcon_Hover = params.onIcon_Hover,
    onIcon_Pressed = params.onIcon_Pressed or params.onIcon,
    onIcon_Disabled = params.onIcon_Disabled or params.onIcon,
    offIcon = params.offIcon,
    offIcon_Hover = params.offIcon_Hover,
    offIcon_Pressed = params.offIcon_Pressed or params.offIcon,
    offIcon_Disabled = params.offIcon_Disabled or params.offIcon,

    onClick = params.onClick, --callback, not the same as the xml onClick
    onValueChanged = params.onValueChanged,--onValueChanged('id', bool)
    isOn = false,
    isToggleButton = true, --type check, don't change
  }
  local appendGUID = params.appendGUID and params.appendGUID .. "/" or ""
  --ToggleButton.uiTarget.obj ~= self and ToggleButton.uiTarget.guid .."/" or ""
  local btnXML = {
    tag = "Button",
    attributes = {
      isOn = false,
      id = params.id,
      transition = "SpriteSwap",
      sprite = toggleBtn.offIcon,
      highlightedSprite = toggleBtn.offIcon_Hover,
      pressedSprite =  toggleBtn.offIcon_Pressed,
      disabledSprite =  toggleBtn.offIcon_Disabled,
      onClick = appendGUID .. "onToggleClicked"
    },
    children = {}
  }
  --copy attributes to xml
  if params.attributes and type(params.attributes) == 'table' then
    for key,val in pairs(params.attributes) do
      btnXML.attributes[key] = val
    end
  end
  --copy children to xml
  if params.children and type(params.children) == 'table' then
    btnXML.children = {}
    for key,val in pairs(params.children) do
      btnXML.children[key] = val
    end
  end
  ToggleButton.btns[toggleBtn.id] = toggleBtn
  return btnXML
end

ToggleButton.setState = function(button, bool, targetUI)
  assert(button ~= nil and button.isToggleButton)
  local uiObj = targetUI ~= nil and targetUI or ToggleButton.uiTarget.obj
  local toState = bool and true or false
  --if bool ~= nil and type(bool) == 'boolean' then toState = bool end
  if uiObj == ToggleButton.uiTarget.obj then
    if button.isOn == toState then return end
  elseif uiObj.UI.getAttribute(button.id, "isOn") == toState then return end --if the button has been copied to multiple objct ui's

  button.isOn = toState
  uiObj.UI.setAttributes(button.id,
    {
      sprite = toState and button.onIcon or button.offIcon,
      highlightedSprite = toState and button.onIcon_Hover or button.offIcon_Hover,
      pressedSprite = toState and button.onIcon_Pressed or button.offIcon_Pressed,
      disabledSprite = toState and button.onIcon_Disabled or button.offIcon_Disabled,
      isOn = toState,
    }
  )
  if button.group then ToggleButton.onGroupMemberStateChange(button.group, button.id, button.isOn) end
  if type(button.onValueChanged) == 'function' then
    button.onValueChanged(button.id, toState)
  end
end

ToggleButton.toggle = function(button)
  assert(button ~= nil and button.isToggleButton)
  ToggleButton.setState(button, not button.isOn)
end

ToggleButton.setSprite = function(button, toState, targetUI)
  assert(button ~= nil and button.isToggleButton)
  local uiObj = targetUI ~= nil and targetUI or ToggleButton.uiTarget.obj
  local _toState = false
  if toState ~= nil and type(toState) == 'boolean' then _toState = toState end

  uiObj.UI.setAttributes(button.id,
    {
      sprite = _toState and button.onIcon or button.offIcon,
      highlightedSprite = _toState and button.onIcon_Hover or button.offIcon_Hover,
      pressedSprite = _toState and button.onIcon_Pressed or button.offIcon_Pressed,
      disabledSprite = _toState and button.onIcon_Disabled or button.offIcon_Disabled,
    }
  )
end

-- UI onClick cannot call ToggleButton.someFunc or ToggleButton (using __call metaTable)
function onToggleClicked(player, value, id)
  assert(ToggleButton.btns[id])
  local button = ToggleButton.btns[id]

  ToggleButton.toggle(button)
  if type(button.onClick) ~= 'function' then return end
  button.onClick(player, button.isOn, id)
end

--------------------------------------------------------------------------------

-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)