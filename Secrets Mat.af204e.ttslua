--- Snap secret objectives to grid.
-- @author Darrell

function getHelperClient(helperObjectName)
    local helperObject = Global.call('getHelper', helperObjectName)
    local function getCallWrapper(functionName)
        helperObject = helperObject == nil and Global.call('getHelper', helperObjectName) or helperObject
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

local SNAP_POINTS = {
    PADDING = {  -- around edge of grid
        x = 0.5,
        z = 0.5
    },
    CARD_SIZE = {
        x = 2,
        z = 3
    },
    ROTATION = {
        x = 0,
        y = 180,
        z = 180
    },
    BOX_SIZE = {
        x = 2,
        z = 3
    }
}

-- Snap points are layed out in a 8x3 grid, [row][col] indexing.
local _snapPointsGrid = false
local _waitId = false

--These values are updated when querried for, max 1 update per frame
local _objsOnMe = {}--{[guid] = objRef,}--feteched from Physics cast
local _objColumns = {}--{[guid] = color} --color will be "Grey" if the object is in an uncolored column
local _colorToObj = {}--{[color] = {[guid] = obj,...}}

--Public getters to find objects on this mat------------------------------------

--is this object on the mat? And in which player's column?
function contains(guid)
  _getColumnObjs()
  return _objColumns[guid] or false
end

--params = {guid, color}
function columnContains(params)
  params = params or {}
  _getColumnObjs()
  return _objColumns[params.guid] == params.color
end

--3 types of results to querry for:
--1.colorFilter is optional. Defaults to getting all objects on the mat: {[guid] = objRef}
--2.If colorFilter is a color, returns {} if no objects are found or a table of objects in the column: {[guid] = objRef}
--3.If colorFilter is a non-color value, returns all objects indexed by their column color: {[eachColor] = {[guid] = obj}}
function getObjects(colorFilter)
  if not colorFilter then return _getObjsOnMe() end
  _getColumnObjs()
  return _colorToObj[colorFilter] or _objColumns
end

-------------------------------------------------------------------------------
local _castResultThisFrame = false --
function _getObjsOnMe()
  if _castResultThisFrame then return _objsOnMe end


  local _myBounds = self.getBoundsNormalized()
  local _myPos = self.getPosition()
  local _boxCast = Physics.cast({
    origin = {_myPos.x, _myPos.y + (_myBounds.size.y * 1.5) + 0.01, _myPos.z},
    orientation = self.getRotation(),
    direction = {0,1,0},
    max_distance  = 1,
    size = _myBounds.size,
    type = 3,
    --debug = true
  })
  --
  _objsOnMe = {}
  for _,eachHit in ipairs(_boxCast or {}) do
    local obj = eachHit.hit_object
    _objsOnMe[obj.getGUID()] = obj
  end

  _castResultThisFrame = true
  Wait.frames(function() _castResultThisFrame = false end, 1)
  return _objsOnMe
end

local _columnsThisFrame = false
function _getColumnObjs()
  if _columnsThisFrame then return end

  _objColumns = {}
  _colorToObj = {["Grey"] = {}}
  _getObjsOnMe()
  local _colors = _zoneHelper.zones()--_zones gives these colors in their index order
  for i,eachCol in ipairs(_colors or {}) do
    _colorToObj[eachCol] = {}--init colors
  end
  --assign each objOnMe to its column color
  local bounds = self.getBoundsNormalized()
  local _columnOrigin = -(bounds.size.x/2)--shifting to mid-left
  for eachGUID, eachObj in pairs(_objsOnMe) do
    local oPos = self.positionToLocal(eachObj.getPosition())
    local _distX = oPos.x - _columnOrigin
    local col = 1 + math.floor(_distX/(bounds.size.x/8))

    _colorToObj[_colors[col] or "Grey"][eachGUID] = eachObj
    _objColumns[eachGUID] = _colors[col] or "Grey"
    --eachObj.highlightOn(_colors[col] or "Grey")
    --print(col," | ",_colors[col] or "Grey")
  end

  _columnsThisFrame = true
  Wait.frames(function() _columnsThisFrame = false end, 1)
end

--Mat Creation-----------------------------------------------------------------

-- Compute a good location for owner tokens.
local _slotToTokenSpot = {}

function suggestedOwnerTokenLocation(color)
    local zoneAttributes = _zoneHelper and _zoneHelper.zoneAttributes(color)
    local slot = zoneAttributes and zoneAttributes.index
    local p = slot and _slotToTokenSpot[slot]
    return p and self.positionToWorld(p)
end

-------------------------------------------------------------------------------

function onLoad(save_state)
    math.randomseed(tonumber(self.getGUID(), 16))
    self.addContextMenuItem('Redraw boxes', drawSnapPoints, false)
    resetSnapPoints()
    delayedDrawSnapPoints()
end

function onPlayerTurnStart(player_color_start, player_color_previous)
    -- in case all lines are erased, redraw on turn start
    delayedDrawSnapPoints()
end

-- Helper "event" it triggers when changing player count.
function onSetupHelperPlayerCountChanged()
    delayedDrawSnapPoints()
end

function resetSnapPoints()
    local bounds = self.getBoundsNormalized()

    -- Create as many snap points as fit inside bounds.
    local numCols = math.floor(bounds.size.x / (SNAP_POINTS.CARD_SIZE.x + SNAP_POINTS.PADDING.x))
    local numRows = math.floor(bounds.size.z / (SNAP_POINTS.CARD_SIZE.z + SNAP_POINTS.PADDING.z))

    -- Compute spacing in local space.
    local size = bounds.size
    local cardSize = SNAP_POINTS.CARD_SIZE
    local padding = SNAP_POINTS.PADDING

    local x0 = -(size.x / 2) + padding.x + (cardSize.x / 2)
    local z0 = -(size.z / 2) + padding.z + (cardSize.z / 2)
    local dx = cardSize.x + padding.x
    local dz = cardSize.z + padding.x

    _snapPointsGrid = {}
    local allSnapPoints = {}
    for row = 0, numRows - 1 do
        local columnEntries = {}
        for col = 0, numCols - 1 do
            local snapPoint = {
                position = {
                    x = x0 + col * dx,
                    y = bounds.size.y,
                    z = z0 + row * dz
                },
                rotation = SNAP_POINTS.ROTATION,
                rotation_snap = true
            }
            table.insert(columnEntries, snapPoint)
            table.insert(allSnapPoints, snapPoint)

            -- Reserve last slot as designed owner token area.
            if row == numRows - 1 then
                _slotToTokenSpot[col + 1] = snapPoint.position
            end
        end
        table.insert(_snapPointsGrid, columnEntries)
    end
    self.setSnapPoints(allSnapPoints)
end

function drawSnapPoints()
    local y = self.getBoundsNormalized().size.y + 0.01

    local defaultColor = { r = 0.15, g = 0.15, b = 0.15, a = 0.4 }

    local colIdxToColor = {}
    for i, color in ipairs(_zoneHelper and _zoneHelper.zones() or {}) do
        local rgba = Color.fromString(color)
        rgba = {
            r = (rgba.r + defaultColor.r) / 2,
            g = (rgba.g + defaultColor.g) / 2,
            b = (rgba.b + defaultColor.b) / 2,
            a = defaultColor.a
        }
        colIdxToColor[i] = rgba
    end

    local thickness = SNAP_POINTS.BOX_SIZE.x
    local lines = {}
    local dz = SNAP_POINTS.BOX_SIZE.z / 2

    for rowIdx, row in ipairs(_snapPointsGrid) do
        for colIdx, snapPoint in ipairs(row) do
            local p = assert(snapPoint.position)
            table.insert(lines, {
                points = {
                    { x = p.x, y = y, z = p.z - dz },
                    { x = p.x, y = y, z = p.z + dz },
                },
                thickness = thickness,
                color = colIdxToColor[colIdx] or defaultColor,
                loop = true,
                square = true
            })
        end
    end
    self.setVectorLines(lines)
end

function delayedDrawSnapPoints()
    local function drawSnapPointsWrapper()
        _waitId = false
        drawSnapPoints()
    end
    if _waitId then
        Wait.stop(_waitId)
    end
    _waitId = Wait.time(drawSnapPointsWrapper, 0.2 + math.random())
end

-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)